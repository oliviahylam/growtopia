<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Growtopia - P5.js Isometric Garden MVP</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            font-family: 'Press Start 2P', cursive;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        /* Full-screen game container with new background */
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('assets/isometric_garden.png');
            background-size: 130%; /* Zoom to 130% to show center of image */
            background-position: center center; /* Center the image */
            background-repeat: no-repeat; /* Don't repeat the image */
            background-color: #87ceeb; /* Fallback color if image fails to load */
            cursor: grab;
        }
        
        #game-container:active {
            cursor: grabbing;
        }
        
        /* Canvas scaling transitions for Focus Mode */
        #defaultCanvas0, #game-container canvas {
            transition: transform 0.5s ease-in-out;
            transform-origin: center center;
        }
        
        /* Zoom and pan wrapper for the grid */
        #grid-viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            pointer-events: auto;
        }
        
        /* Ensure UI panels stay above the transformed grid and transition video */
        .ui-panel, .focus-mode-button, .restart-button, .top-ui-bar, .focus-mode-nav, 
        .focus-mode-overlay, .focus-game-overlay, .shop-panel, .inventory-panel, 
        .plant-condition-panel, .focus-widget, .focus-top-bar, .focus-side-panel, 
        .focus-music-player {
            position: fixed !important;
            pointer-events: auto !important;
            z-index: 1000 !important; /* Ensure UI stays above transition video */
        }
        
        /* Ensure focus mode overlays cover the full screen */
        .focus-mode-overlay, .focus-game-overlay {
            width: 100vw !important;
            height: 100vh !important;
            top: 0 !important;
            left: 0 !important;
        }
        
        /* Zoom indicator */
        .zoom-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 9px;
            z-index: 1000;
            pointer-events: none;
            line-height: 1.4;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .zoom-indicator .zoom-level {
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 3px;
        }
        
        .zoom-indicator .zoom-controls {
            font-size: 8px;
            opacity: 0.8;
        }
        
        /* Intro Pop-ups */
        .intro-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .popup-content {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 3px solid #f39c12;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            color: white;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }
        
        .popup-content h2 {
            color: #f39c12;
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        .popup-content p {
            font-size: 10px;
            line-height: 1.6;
            margin-bottom: 25px;
        }
        
        .popup-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .popup-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        /* TOP UI BAR */
        .top-ui-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border-bottom: 3px solid #f39c12;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            font-size: 10px;
            color: white;
        }
        
        .weather-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .weather-icon {
            font-size: 20px;
            animation: weatherPulse 3s ease-in-out infinite;
        }
        
        @keyframes weatherPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .currency-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .coin-counter {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #f39c12;
        }
        
        .xp-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .xp-bar {
            width: 120px;
            height: 6px;
            background: #34495e;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.5s ease;
        }

        /* Main UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 9px;
            backdrop-filter: blur(5px);
            z-index: 1000;
        }
        
        .ui-panel h3 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 10px;
            text-align: center;
            border-bottom: 1px solid #34495e;
            padding-bottom: 8px;
        }
        
        /* Resources Panel */
        #resources-panel {
            top: 150px;
            left: 10px;
            width: 180px;
        }
        
        .resource-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            align-items: center;
        }
        
        /* Weather Panel */
        #weather-panel {
            bottom: 410px;
            right: 10px;
            width: 200px;
        }
        
        .weather-info {
            text-align: center;
            margin: 8px 0;
        }
        
        .weather-icon {
            font-size: 20px;
            margin: 5px 0;
        }
        
        /* Plant Status Panel */
        #plant-status-panel {
            top: 180px;
            right: 10px;
            width: 150px;
            max-height: 150px;
            overflow-y: auto;
            display: none !important; /* Hide the panel visually - force override */
            visibility: hidden !important; /* Additional hiding */
            opacity: 0 !important; /* Make completely transparent */
            pointer-events: none !important; /* Disable interactions */
        }
        
        .plant-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
            padding: 4px;
            background: rgba(52, 73, 94, 0.5);
            border-radius: 4px;
        }
        
        .plant-icons {
            display: flex;
            gap: 5px;
        }
        
        .status-icon {
            font-size: 10px;
        }
        
        .needs-water { color: #3498db; }
        .unhealthy { color: #e74c3c; }
        .ready-harvest { color: #f39c12; }
        .healthy { color: #27ae60; }
        
        /* Shop Panel */
        #shop-panel {
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 360px;
            overflow-y: auto;
        }
        
        .shop-category {
            margin: 10px 0;
        }
        
        .shop-category h4 {
            color: #f39c12;
            font-size: 8px;
            margin: 5px 0;
            border-bottom: 1px solid #34495e;
            padding-bottom: 3px;
        }
        
        .shop-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 1px solid #2ecc71;
            color: white;
            padding: 6px 8px;
            margin: 2px 0;
            cursor: pointer;
            font-family: inherit;
            font-size: 7px;
            border-radius: 3px;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .shop-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-1px);
        }
        
        .shop-button:disabled {
            background: #7f8c8d;
            border-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .shop-button:active {
            transform: translateY(1px);
        }
        
        /* Inventory Panel */
        #inventory-panel {
            top: 320px;
            left: 10px;
            width: 180px;
        }
        
        /* Narrative Panel */
        #narrative-panel {
            top: 280px;
            right: 10px;
            width: 160px;
        }
        
        .narrative-text {
            font-style: italic;
            color: #ecf0f1;
            font-size: 8px;
            line-height: 1.4;
            text-align: center;
        }
        
        /* Animal Helper */
        .animal-helper {
            position: absolute;
            font-size: 16px;
            z-index: 100;
            animation: hop 2s infinite ease-in-out;
        }
        
        @keyframes hop {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.95);
            color: #f39c12;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 10px;
            z-index: 9999;
            border: 2px solid #f39c12;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); background-color: rgba(46, 204, 113, 0.2); }
            50% { transform: scale(1.1); background-color: rgba(46, 204, 113, 0.4); }
            100% { transform: scale(1); background-color: rgba(46, 204, 113, 0.2); }
        }
        
        /* NEW: Coin sparkle animation for streak rewards */
        @keyframes coinSparkle {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 0 rgba(255, 215, 0, 0);
                color: inherit;
            }
            25% { 
                transform: scale(1.15); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
                color: #ffd700;
                text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: scale(1.2); 
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.6);
                color: #ffed4e;
                text-shadow: 0 0 15px rgba(255, 215, 0, 1);
            }
            75% { 
                transform: scale(1.1); 
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
                color: #ffd700;
                text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 rgba(255, 215, 0, 0);
                color: inherit;
                text-shadow: none;
            }
        }
        
        /* Tools Indicators */
        .tool-indicator {
            position: absolute;
            font-size: 12px;
            z-index: 50;
        }
        
        .sprinkler { color: #3498db; }
        .greenhouse { color: #27ae60; }
        
        /* ANIMATION ENHANCEMENTS */
        
        /* Plant animations */
        @keyframes plantSway {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }
        
        @keyframes plantGrow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes plantPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        
        /* Water animation */
        @keyframes waterDrop {
            0% { transform: translateY(-10px); opacity: 1; }
            100% { transform: translateY(20px); opacity: 0; }
        }
        
        .water-effect {
            position: absolute;
            color: #3498db;
            font-size: 12px;
            animation: waterDrop 1s ease-out forwards;
            pointer-events: none;
        }
        
        .pesticide-effect {
            position: absolute;
            color: #27ae60;
            font-size: 12px;
            animation: pesticideSpray 1.5s ease-out forwards;
            pointer-events: none;
        }
        
        /* NEW: HEALING ANIMATION */
        .healing-effect {
            position: absolute;
            color: #f1c40f;
            font-size: 16px;
            animation: healingSparkle 2s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }
        
        .sunlight-effect {
            position: absolute;
            color: #f39c12;
            font-size: 14px;
            animation: sunlightBeam 2s ease-out forwards;
            pointer-events: none;
        }
        
        .remove-effect {
            position: absolute;
            color: #e74c3c;
            font-size: 16px;
            animation: removeTree 1.2s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes pesticideSpray {
            0% { transform: translateY(0) scale(0.3) rotate(0deg); opacity: 1; }
            50% { transform: translateY(-20px) scale(1) rotate(180deg); opacity: 0.8; }
            100% { transform: translateY(-40px) scale(0.5) rotate(360deg); opacity: 0; }
        }
        
        /* NEW: HEALING SPARKLE ANIMATION */
        @keyframes healingSparkle {
            0% { transform: translateY(0) scale(0.5) rotate(0deg); opacity: 0; }
            20% { transform: translateY(-10px) scale(1) rotate(90deg); opacity: 1; }
            50% { transform: translateY(-20px) scale(1.2) rotate(180deg); opacity: 0.9; }
            80% { transform: translateY(-30px) scale(1) rotate(270deg); opacity: 0.6; }
            100% { transform: translateY(-40px) scale(0.3) rotate(360deg); opacity: 0; }
        }
        
        @keyframes sunlightBeam {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-10px) scale(1); opacity: 1; }
            80% { transform: translateY(-30px) scale(1.2); opacity: 0.8; }
            100% { transform: translateY(-50px) scale(0.8); opacity: 0; }
        }
        
        @keyframes removeTree {
            0% { transform: translateY(0) scale(1) rotate(0deg); opacity: 1; }
            50% { transform: translateY(-15px) scale(1.2) rotate(180deg); opacity: 0.8; }
            100% { transform: translateY(-30px) scale(0.3) rotate(360deg); opacity: 0; }
        }
        
        /* Coin collection animation */
        @keyframes coinCollect {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            50% { transform: scale(1.5) translateY(-20px); opacity: 0.8; }
            100% { transform: scale(0) translateY(-40px); opacity: 0; }
        }
        
        .coin-animation {
            position: absolute;
            font-size: 14px;
            color: #f39c12;
            animation: coinCollect 1s ease-out forwards;
            pointer-events: none;
            z-index: 1001;
        }
        
        /* Enhanced Weather Effects */
        .weather-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 2s ease-in-out;
        }
        
        /* Background tints for different weather */
        .weather-tint {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .weather-tint.rain {
            background: linear-gradient(to bottom, rgba(52, 152, 219, 0.1), rgba(52, 152, 219, 0.2));
        }
        
        .weather-tint.heavy-rain {
            background: linear-gradient(to bottom, rgba(31, 81, 119, 0.4), rgba(31, 81, 119, 0.6));
        }
        
        .weather-tint.snow {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.25));
        }
        
        .weather-tint.cloudy {
            background: linear-gradient(to bottom, rgba(149, 165, 166, 0.1), rgba(149, 165, 166, 0.2));
        }
        
        .weather-tint.sunny {
            background: linear-gradient(to bottom, rgba(255, 193, 7, 0.05), rgba(255, 193, 7, 0.1));
        }
        
        /* Enhanced Rain Effects */
        .rain-drop {
            position: absolute;
            width: 3px;
            height: 20px;
            background: linear-gradient(transparent, #3498db, transparent);
            animation: rainFall linear infinite;
            opacity: 0.8;
        }
        
        .rain-drop.heavy {
            width: 4px;
            height: 30px;
            background: linear-gradient(to bottom, transparent 0%, #1f4e79 10%, #2980b9 40%, #3498db 60%, #2980b9 85%, transparent 100%);
            opacity: 0.5;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 5px rgba(31, 78, 121, 0.7), 0 0 2px rgba(52, 152, 219, 0.8);
            filter: brightness(1.2);
            animation: heavyRainFall linear infinite;
        }
        
        .rain-drop.light {
            width: 1px;
            height: 8px;
            opacity: 0.6;
        }
        
        @keyframes rainFall {
            0% { 
                transform: translateY(-20px) rotate(15deg); 
                opacity: 0;
            }
            5% { opacity: 0.8; }
            95% { opacity: 0.8; }
            100% { 
                transform: translateY(100vh) rotate(15deg); 
                opacity: 0;
            }
        }
        
        /* Special enhanced animation for heavy rain only */
        
        @keyframes heavyRainFall {
            0% { 
                transform: translateY(-30px) rotate(15deg) scaleY(0.8); 
                opacity: 0;
            }
            3% { 
                opacity: 1; 
                transform: translateY(-10px) rotate(15deg) scaleY(1);
            }
            97% { 
                opacity: 1; 
                transform: translateY(calc(100vh - 10px)) rotate(15deg) scaleY(1.2);
            }
            100% { 
                transform: translateY(100vh) rotate(15deg) scaleY(0.8); 
                opacity: 0;
            }
        }
        
        /* Enhanced Snow Effects */
        .snow-flake {
            position: absolute;
            color: white;
            font-size: 10px;
            animation: snowFall linear infinite;
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
        }
        
        .snow-flake.large {
            font-size: 14px;
        }
        
        .snow-flake.small {
            font-size: 6px;
            opacity: 0.7;
        }
        
        @keyframes snowFall {
            0% { 
                transform: translateY(-20px) rotate(0deg); 
                opacity: 0;
            }
            5% { opacity: 1; }
            95% { opacity: 1; }
            100% { 
                transform: translateY(100vh) rotate(360deg) translateX(50px); 
                opacity: 0;
            }
        }
        
        /* Enhanced Sun Effects */
        .sun-glow {
            position: absolute;
            top: 5%;
            right: 10%;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,193,7,0.3) 0%, rgba(255,193,7,0.1) 40%, rgba(255,193,7,0) 70%);
            animation: sunGlow 6s ease-in-out infinite;
            border-radius: 50%;
        }
        
        @keyframes sunGlow {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.6;
                box-shadow: 0 0 50px rgba(255,193,7,0.3);
            }
            50% { 
                transform: scale(1.1); 
                opacity: 0.8;
                box-shadow: 0 0 80px rgba(255,193,7,0.5);
            }
        }
        
        .sunbeam {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255,193,7,0.2) 0%, rgba(255,193,7,0) 70%);
            animation: sunbeamPulse 4s ease-in-out infinite;
            border-radius: 50%;
        }
        
        @keyframes sunbeamPulse {
            0%, 100% { 
                opacity: 0.3; 
                transform: scale(1) rotate(0deg); 
            }
            50% { 
                opacity: 0.6; 
                transform: scale(1.3) rotate(180deg); 
            }
        }
        
        /* Cloud Effects */
        .cloud {
            position: absolute;
            background: rgba(236, 240, 241, 0.8);
            border-radius: 50px;
            animation: cloudFloat linear infinite;
            box-shadow: 0 0 20px rgba(189, 195, 199, 0.5);
        }
        
        .cloud.large {
            width: 200px;
            height: 60px;
            top: 10%;
        }
        
        .cloud.medium {
            width: 150px;
            height: 45px;
            top: 20%;
        }
        
        .cloud.small {
            width: 100px;
            height: 30px;
            top: 15%;
        }
        
        @keyframes cloudFloat {
            0% { 
                transform: translateX(-250px); 
                opacity: 0;
            }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { 
                transform: translateX(calc(100vw + 50px)); 
                opacity: 0;
            }
        }
        
        /* Mist/Fog Effects */
        .mist {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30%;
            background: linear-gradient(to top, rgba(189, 195, 199, 0.4), rgba(189, 195, 199, 0));
            animation: mistMove 8s ease-in-out infinite;
        }
        
        @keyframes mistMove {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }
        
        /* Purchase notification */
        .purchase-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.95);
            color: #f39c12;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 9px;
            z-index: 9999;
            border: 2px solid #f39c12;
            animation: purchaseNotify 2s ease-in-out forwards;
        }
        
        @keyframes purchaseNotify {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* Plant status bubbles */
        .status-bubble {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            border-radius: 8px;
            font-size: 8px;
            z-index: 150;
            pointer-events: none;
        }
        
        .status-ring {
            position: absolute;
            border: 2px solid;
            border-radius: 50%;
            z-index: 149;
            pointer-events: none;
            animation: statusPulse 2s ease-in-out infinite;
        }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        .status-ring.healthy { border-color: #27ae60; }
        .status-ring.needs-care { border-color: #f39c12; }
        .status-ring.sick { border-color: #e74c3c; }
        
        /* NEW: Yellow tint for sick plants */
        .sick-tint {
            filter: sepia(0.3) hue-rotate(45deg) saturate(1.5) !important;
        }
        
        /* Button shake animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* Inventory panel enhancements */
        .inventory-section {
            margin: 8px 0;
        }
        
        .inventory-section h4 {
            color: #f39c12;
            font-size: 8px;
            margin: 5px 0 3px 0;
            border-bottom: 1px solid #34495e;
            padding-bottom: 2px;
        }
        
        .inventory-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 8px;
        }
        
        .clickable-item {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        
        .clickable-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        
        .clickable-item.selected {
            background-color: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }
        
        .selected-indicator {
            color: #27ae60;
            font-weight: bold;
            font-size: 10px;
        }
        
        /* Tool buttons in inventory */
        .tool-buttons-container {
            margin: 5px 0;
        }
        
        .tool-buttons-container .tool-button {
            width: 100%;
            margin: 2px 0;
            padding: 4px 8px;
            font-size: 8px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tool-buttons-container .tool-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(142, 68, 173, 0.3);
        }
        
        .tool-buttons-container .tool-button.selected {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }
        
        .tool-info {
            margin-top: 8px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        /* Disabled inventory items */
        .inventory-item.disabled {
            opacity: 0.4;
            pointer-events: none;
            background: rgba(100, 100, 100, 0.2);
        }
        
        .tool-button.disabled {
            opacity: 0.4;
            pointer-events: none;
            background: linear-gradient(145deg, #666, #777) !important;
            border-color: #666 !important;
        }
        
        .disabled-overlay {
            position: relative;
        }
        
        .disabled-overlay::after {
            content: "ðŸ”’ Purchase in Shop";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6px;
            color: #ccc;
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
        }
        
        .seed-count {
            background: rgba(46, 204, 113, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(46, 204, 113, 0.3);
            font-weight: bold;
            color: #2ecc71;
        }
        
        .inventory-note {
            font-size: 7px;
            color: #95a5a6;
            font-style: italic;
            margin-top: 5px;
            text-align: center;
        }
        
        .clickable-inventory-item {
            cursor: pointer;
            transition: background-color 0.2s ease;
            padding: 4px 6px;
            border-radius: 3px;
            position: relative;
        }
        
        .clickable-inventory-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        
        .clickable-inventory-item.selected {
            background-color: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }
        
        .selection-indicator {
            font-size: 7px;
            color: #f39c12;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .tool-count, .animal-count {
            background: rgba(52, 152, 219, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            font-weight: bold;
            color: #3498db;
        }
        
        /* NEW: Tool Selection Styles */
        .tool-button {
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            padding: 8px 12px;
            margin: 3px 0;
            width: 100%;
            font-family: inherit;
            font-size: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tool-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-1px);
        }
        
        .tool-button.selected {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border-color: #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .tool-button:disabled {
            background: linear-gradient(145deg, #7f8c8d, #95a5a6);
            border-color: #95a5a6;
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .tool-section {
            margin: 10px 0;
        }
        
        .tool-info {
            border-top: 1px solid #34495e;
            padding-top: 8px;
            margin-top: 8px;
        }
        
        /* Debug mode styles */
        .debug-info {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px;
            font-size: 8px;
            font-family: monospace;
            border-radius: 4px;
            min-width: 200px;
        }

        /* =============================================================================
           FOCUS MODE STYLES
           ============================================================================= */
        
        /* Focus Mode Button */
        .focus-mode-button {
            position: fixed;
            top: 60px;
            right: 20px; /* Moved to top-right for better accessibility */
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            padding: 12px 18px; /* Slightly larger for better visibility */
            font-family: inherit;
            font-size: 11px; /* Slightly larger text */
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2000 !important; /* Highest z-index to stay above transition video */
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto !important; /* Ensure it's always clickable */
            box-shadow: 0 4px 12px rgba(142, 68, 173, 0.3); /* Add shadow for visibility */
        }
        
        .focus-mode-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        
        .focus-mode-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
            animation: focusPulse 2s ease-in-out infinite;
        }
        
        @keyframes focusPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(46, 204, 113, 0.5); }
            50% { box-shadow: 0 0 20px rgba(46, 204, 113, 0.8); }
        }
        
        /* Restart Button */
        .restart-button {
            position: fixed;
            top: 100px;
            left: 10px;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border: 2px solid #e74c3c;
            color: white;
            padding: 10px 15px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .restart-button:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .restart-button:active {
            transform: translateY(0);
        }
        
        /* ENHANCED PLANT HEALTH VISUAL EFFECTS */
        .plant-sick {
            animation: plantSick 0.8s ease-in-out infinite;
        }
        
        .plant-dead {
            filter: grayscale(80%) brightness(0.6);
        }
        
        @keyframes plantSick {
            0%, 100% { 
                filter: hue-rotate(0deg) brightness(1);
                transform: scale(1) translateX(0);
            }
            25% { 
                filter: hue-rotate(15deg) brightness(1.2);
                transform: scale(1.05) translateX(-1px);
            }
            50% { 
                filter: hue-rotate(30deg) brightness(1.3);
                transform: scale(1.1) translateX(1px);
            }
            75% { 
                filter: hue-rotate(15deg) brightness(1.2);
                transform: scale(1.05) translateX(-1px);
            }
        }
        
        /* PLANT CONDITION HOVER PANEL */
        .plant-condition-panel {
            position: fixed;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 12px;
            z-index: 1000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease-in-out;
        }
        
        .plant-condition-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f39c12;
        }
        
        .plant-icon {
            font-size: 20px;
        }
        
        .plant-name {
            font-weight: bold;
            font-size: 14px;
            color: #f39c12;
        }
        
        .plant-stage {
            font-size: 11px;
            color: #bdc3c7;
            margin-left: auto;
        }
        
        .condition-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .condition-label {
            min-width: 60px;
            font-weight: bold;
        }
        
        .health-bar, .water-bar, .sunlight-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }
        
        .water-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            transition: width 0.3s ease;
        }
        
        .sunlight-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #f39c12);
            transition: width 0.3s ease;
        }
        
        .health-value, .water-value, .sunlight-value {
            min-width: 35px;
            text-align: right;
            font-weight: bold;
        }
        
        .status-section {
            margin: 15px 0;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        
        .status-icon {
            font-size: 16px;
        }
        
        .status-text {
            font-weight: bold;
        }
        
        .treatment-section {
            margin-top: 15px;
        }
        
        .treatment-section h4 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 13px;
        }
        
        .treatment-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .treatment-item {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 3px;
            font-weight: normal;
            line-height: 1.3;
        }
        
        /* Treatment type styling */
        .treatment-dead {
            background: rgba(231, 76, 60, 0.3);
            border-left: 4px solid #e74c3c;
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
        }
        
        .treatment-condition {
            background: rgba(230, 126, 34, 0.2);
            border-left: 3px solid #e67e22;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        .treatment-task {
            background: rgba(52, 152, 219, 0.2);
            border-left: 3px solid #3498db;
            color: #ecf0f1;
            font-size: 10px;
            margin-left: 10px;
        }
        
        .treatment-result {
            background: rgba(155, 89, 182, 0.2);
            border-left: 3px solid #9b59b6;
            color: #bdc3c7;
            font-size: 10px;
            margin-left: 10px;
            font-style: italic;
        }
        
        .treatment-warning {
            background: rgba(241, 196, 15, 0.2);
            border-left: 3px solid #f1c40f;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        .treatment-note {
            background: rgba(127, 140, 141, 0.2);
            border-left: 3px solid #7f8c8d;
            color: #bdc3c7;
            font-size: 10px;
            margin-left: 10px;
        }
        
        .treatment-success {
            background: rgba(39, 174, 96, 0.2);
            border-left: 3px solid #27ae60;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* Focus Mode Overlay */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: none;
            color: white;
            overflow-y: auto;
            padding: 20px;
        }
        
        .focus-mode-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
        }
        
        .focus-mode-overlay.active {
            display: flex;
        }
        
        /* Pomodoro Timer Styles */
        .pomodoro-main-display {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }
        
        .timer-time {
            font-size: 36px;
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .timer-phase {
            color: #f39c12;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .timer-session {
            color: #bdc3c7;
            font-size: 11px;
        }
        
        /* Session Controls */
        .session-controls {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .session-controls label {
            color: #ecf0f1;
            font-size: 11px;
            display: block;
            margin-bottom: 10px;
        }
        
        .cycle-adjuster {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .cycle-btn {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #f39c12;
            color: #f39c12;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .cycle-btn:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            transform: scale(1.1);
        }
        
        .cycle-count {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        /* Timer Controls */
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .timer-btn {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .timer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .timer-btn.start {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
        }
        
        .timer-btn.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .timer-btn.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        
        /* Phase-based styling */
        .pomodoro-main-display.focus {
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }
        
        .pomodoro-main-display.short-break {
            border-color: #2ecc71;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
        }
        
        .pomodoro-main-display.long-break {
            border-color: #9b59b6;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.3);
        }
        
        /* =============================================================================
           MAIN GARDEN TIMER PANEL (Synchronized with Focus Mode timer)
           ============================================================================= */
        
        .main-garden-timer-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
            z-index: 9998; /* Below focus mode overlays but above other UI */
            min-width: 380px;
            max-width: 500px;
            text-align: center;
        }
        
        .main-timer-content h3 {
            color: #f39c12;
            margin: 0 0 15px 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .main-timer-display {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .main-timer-time {
            font-size: 28px;
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .main-timer-phase {
            color: #f39c12;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .main-timer-session {
            color: #bdc3c7;
            font-size: 10px;
        }
        
        .main-timer-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .main-timer-btn {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .main-timer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .main-timer-btn.start {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
        }
        
        .main-timer-btn.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .main-timer-btn.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        
        .main-timer-settings {
            margin-bottom: 15px;
        }
        
        .main-setting-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .main-setting-group {
            flex: 1;
            text-align: center;
        }
        
        .main-setting-group label {
            display: block;
            color: #ecf0f1;
            font-size: 9px;
            margin-bottom: 4px;
        }
        
        .main-setting-group input {
            width: 100%;
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 1px solid #f39c12;
            border-radius: 4px;
            color: #ecf0f1;
            font-size: 10px;
            padding: 4px 6px;
            text-align: center;
        }
        
        .main-setting-group input:focus {
            outline: none;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.5);
        }
        
        .main-timer-cycles {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .main-timer-cycles label {
            color: #ecf0f1;
            font-size: 9px;
        }
        
        .main-cycle-adjuster {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .main-cycle-btn {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #f39c12;
            color: #f39c12;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-cycle-btn:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            transform: scale(1.1);
        }
        
        .main-cycle-count {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }
        
        /* Phase-based styling for main garden timer */
        .main-timer-display.focus {
            border: 1px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.2);
        }
        
        .main-timer-display.short-break {
            border: 1px solid #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.2);
        }
        
        .main-timer-display.long-break {
            border: 1px solid #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.2);
        }
        
        .timer-display {
            font-size: 48px;
            font-weight: bold;
            color: #f39c12;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .timer-phase {
            font-size: 18px;
            color: #ecf0f1;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .timer-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .timer-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 20px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .timer-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        .timer-button.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .timer-button.pause:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
        }
        
        .timer-button.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
        }
        
        .timer-button.stop:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }
        
        /* Timer Settings */
        .timer-settings {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .setting-group label {
            font-size: 10px;
            color: #bdc3c7;
        }
        
        .setting-group input {
            background: #34495e;
            border: 1px solid #2c3e50;
            color: white;
            padding: 5px;
            border-radius: 4px;
            width: 60px;
            text-align: center;
            font-family: inherit;
        }
        
        /* Music Panel */
        .music-panel {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-width: 300px;
        }
        
        .music-panel h3 {
            color: #9b59b6;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 14px;
        }
        
        .music-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .music-option {
            background: rgba(52, 73, 94, 0.5);
            border: 1px solid #7f8c8d;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .music-option:hover {
            background: rgba(155, 89, 182, 0.3);
            border-color: #9b59b6;
        }
        
        .music-option.active {
            background: rgba(155, 89, 182, 0.5);
            border-color: #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.3);
        }
        
        .music-icon {
            font-size: 20px;
        }
        
        .music-info {
            flex: 1;
        }
        
        .music-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .music-description {
            font-size: 9px;
            color: #bdc3c7;
        }
        
        /* Focus Streak */
        .focus-streak {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            min-width: 250px;
        }
        
        .streak-display {
            font-size: 24px;
            color: #e74c3c;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .streak-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin: 15px 0;
        }
        
        .streak-day {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #34495e;
            border: 1px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .streak-day.completed {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
            box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }
        
        .streak-day.today {
            border: 2px solid #f39c12;
            animation: todayPulse 2s ease-in-out infinite;
        }
        
        @keyframes todayPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(243, 156, 18, 0.5); }
            50% { box-shadow: 0 0 10px rgba(243, 156, 18, 0.8); }
        }
        
        /* Focus Stats */
        .focus-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: rgba(52, 73, 94, 0.5);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #bdc3c7;
        }
        
        /* Focus Mode Controls */
        .focus-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
        }
        
        .focus-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 20px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .focus-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        .focus-button.exit {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
        }
        
        .focus-button.exit:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }
        
        /* Pet System */
        .pet-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: none;
        }
        
        .pet {
            width: 60px;
            height: 60px;
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border: 2px solid #e67e22;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: petBounce 3s ease-in-out infinite;
        }
        
        .pet:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }
        
        @keyframes petBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .pet-accessory {
            position: absolute;
            font-size: 15px;
            pointer-events: none;
        }
        
        .pet-accessory.hat { top: -5px; }
        .pet-accessory.glasses { top: 10px; }
        .pet-accessory.scarf { bottom: -5px; }
        
        /* Focus Mode Game Overlay */
        .focus-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 62, 80, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }
        
        .focus-game-overlay.break {
            background: rgba(39, 174, 96, 0.8);
        }
        
        /* Focus Tokens */
        .focus-tokens {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 12px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .focus-token-icon {
            font-size: 16px;
            animation: tokenGlow 2s ease-in-out infinite;
        }
        
        @keyframes tokenGlow {
            0%, 100% { text-shadow: 0 0 5px rgba(155, 89, 182, 0.5); }
            50% { text-shadow: 0 0 15px rgba(155, 89, 182, 0.8); }
        }
        
        /* Focus Mode Notifications */
        .focus-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            border-radius: 10px;
            padding: 20px;
            color: white;
            text-align: center;
            z-index: 10000;
            animation: notificationSlide 0.5s ease-out;
        }
        
        /* Scroll to Top Button */
        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10001;
            font-size: 20px;
        }
        
        .scroll-to-top:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        
        @keyframes notificationSlide {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* Responsive Design for Focus Mode */
        @media (max-width: 768px) {
            .focus-mode-overlay {
                padding: 10px;
            }
            
            .focus-mode-content {
                gap: 20px;
                padding: 10px 0;
            }
            
            .pomodoro-timer {
                min-width: 280px;
                padding: 20px;
            }
            
            .timer-display {
                font-size: 32px;
            }
            
            .timer-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .timer-settings {
                flex-direction: column;
                gap: 15px;
            }
            
            .music-panel,
            .focus-streak {
                min-width: 280px;
            }
            
            .focus-stats {
                gap: 10px;
                flex-direction: column;
            }
            
            .stat-item {
                min-width: 200px;
                padding: 15px;
            }
            
            .focus-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .focus-button {
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            .pomodoro-timer {
                min-width: 250px;
                padding: 15px;
            }
            
            .timer-display {
                font-size: 28px;
            }
            
            .music-panel,
            .focus-streak {
                min-width: 250px;
            }
            
            .music-option {
                padding: 8px;
            }
            
            .music-title {
                font-size: 11px;
            }
            
            .music-description {
                font-size: 8px;
            }
        }

        /* FOCUS MODE TAB NAVIGATION */
        .focus-tab-navigation {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-bottom: 2px solid #f39c12;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 0 20px;
            z-index: 999;
        }

        .focus-tab-button {
            background: rgba(52, 73, 94, 0.7);
            border: 2px solid #34495e;
            color: #bdc3c7;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            text-align: center;
        }

        .focus-tab-button:hover {
            background: rgba(52, 73, 94, 0.9);
            color: #ecf0f1;
            border-color: #7f8c8d;
        }

        .focus-tab-button.active {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border-color: #f39c12;
            color: white;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        /* FOCUS MODE TAB CONTENT */
        .focus-tab-content {
            position: fixed;
            top: 90px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(5px);
            z-index: 998;
            display: none;
            overflow-y: auto;
            padding: 20px;
        }

        .focus-tab-content.active {
            display: block;
        }

        .focus-tab {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .focus-section {
            background: rgba(52, 73, 94, 0.8);
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 15px;
        }

        .focus-section h3 {
            color: #f39c12;
            margin: 0 0 15px 0;
            font-size: 14px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 8px;
        }

        .back-to-game-button {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 10px 16px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .back-to-game-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }

        /* FOCUS MODE UI PANELS */
        .focus-top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            font-size: 10px;
            border-bottom: 2px solid #3498db;
            backdrop-filter: blur(5px);
        }
        
        .focus-streak-info, .focus-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .focus-timer-display {
            text-align: center;
        }
        
        .pomodoro-timer {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        #focus-timer-display {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }
        
        #focus-timer-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
        }
        
        #focus-timer-btn:hover {
            background: #2980b9;
        }
        
        .focus-side-panel {
            position: fixed;
            left: 10px;
            top: 110px;
            width: 200px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            font-size: 9px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .focus-side-panel h3 {
            margin: 0 0 15px 0;
            color: #3498db;
            font-size: 11px;
        }
        
        .focus-side-panel h4 {
            margin: 10px 0 5px 0;
            font-size: 9px;
            color: #ecf0f1;
        }
        
        .focus-tip {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .focus-tip p {
            margin: 5px 0 0 0;
            line-height: 1.4;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            text-align: center;
            font-size: 8px;
            color: #bdc3c7;
        }
        
        .focus-task {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 8px;
        }
        
        .focus-task:last-child {
            border-bottom: none;
        }
        
        /* FOCUS MODE MUSIC PLAYER */
        .focus-music-player {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 80px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            border-radius: 30px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .music-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .music-controls button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .music-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .music-info {
            flex: 1;
            text-align: center;
            margin: 0 15px;
        }
        
        .track-title {
            font-size: 10px;
            margin-bottom: 5px;
            color: #3498db;
        }
        
        #track-selector {
            background: rgba(52, 73, 94, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 2px 5px;
            font-size: 9px;
            margin-bottom: 5px;
            cursor: pointer;
            outline: none;
            width: 100%;
        }
        
        #track-selector:hover {
            background: rgba(52, 73, 94, 1);
        }
        
        #track-selector option {
            background: rgba(52, 73, 94, 1);
            color: white;
        }
        
        .music-progress {
            width: 100%;
        }
        
        .music-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .music-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.1s ease;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .volume-control span {
            font-size: 12px;
        }
        
        #volume-slider {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        #volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* CUSTOM APPLE ICON */
        .apple-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-image: url('assets/apple/apple.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            vertical-align: middle;
        }
        
        .apple-icon-small {
            width: 12px;
            height: 12px;
        }
        
        .apple-icon-medium {
            width: 20px;
            height: 20px;
        }
        
        .apple-icon-large {
            width: 24px;
            height: 24px;
        }
        
        /* CUSTOM WATER ICON */
        .water-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-image: url('assets/water.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            vertical-align: middle;
        }
        
        .water-icon-small {
            width: 12px;
            height: 12px;
        }
        
        .water-icon-medium {
            width: 20px;
            height: 20px;
        }
        
        .water-icon-large {
            width: 24px;
            height: 24px;
        }
        
        /* FOCUS MODE TRANSITION VIDEO */
        .focus-transition-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 500; /* Below UI panels but above game */
            display: none;
            pointer-events: none !important; /* Never intercept clicks */
            transform: scale(1.3); /* Start at 130% zoom */
            transform-origin: center center;
        }
        
        /* Video zoom animation classes */
        .focus-transition-video.zoom-out {
            animation: zoomOutTransition 2s ease-out forwards;
        }
        
        @keyframes zoomOutTransition {
            from {
                transform: scale(1.3); /* Start at 130% */
            }
            to {
                transform: scale(1.0); /* End at 100% */
            }
        }
        
        /* FOCUS MODE EXIT TRANSITION VIDEO */
        .focus-exit-transition-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 500; /* Below UI panels but above game */
            display: none;
            pointer-events: none !important; /* Never intercept clicks */
            transform: scale(1.0); /* Start at 100% zoom */
            transform-origin: center center;
        }
        
        /* Exit video zoom animation classes */
        .focus-exit-transition-video.zoom-in {
            animation: zoomInTransition 2s ease-in forwards;
        }
        
        @keyframes zoomInTransition {
            from {
                transform: scale(1.0); /* Start at 100% */
            }
            to {
                transform: scale(1.3); /* End at 130% */
            }
        }
        
        /* FOCUS MODE VISUAL EFFECTS - LAYERED OVERLAY */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 997;
            transition: all 0.8s ease-in-out;
            opacity: 0;
            background: rgba(0, 0, 0, 0.3); /* Semi-transparent overlay */
        }
        
        .focus-mode-overlay.active {
            opacity: 1;
        }

        /* Sparkle effects */
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleFloat 4s ease-in-out infinite;
        }
        
        @keyframes sparkleFloat {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(80vh) scale(1);
            }
            80% {
                opacity: 1;
                transform: translateY(20vh) scale(1);
            }
            100% {
                transform: translateY(-20vh) scale(0);
                opacity: 0;
            }
        }

        .focus-mode-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.05);
            transition: all 2s ease-in-out;
        }

        .focus-mode-background.day {
            background: rgba(135, 206, 235, 0.03);
        }

        .focus-mode-background.sunset {
            background: rgba(255, 127, 80, 0.05);
        }

        .focus-mode-background.dusk {
            background: rgba(74, 144, 226, 0.08);
        }

        .focus-mode-background.night {
            background: rgba(26, 26, 46, 0.12);
        }

        .focus-mode-particles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        .focus-mode-sparkles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 6s infinite ease-in-out;
        }

        .firefly {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(255, 215, 0, 0.4);
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(255, 215, 0, 0.4);
            animation: firefly 8s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        @keyframes firefly {
            0%, 100% { transform: translateY(0px) translateX(0px); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-50px) translateX(20px); opacity: 0; }
        }

        .focus-mode-badge {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(243, 156, 18, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 9px;
            font-weight: bold;
            z-index: 1002;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.5s ease-in-out;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.2);
        }

        .focus-mode-badge.active {
            opacity: 1;
            transform: translateY(0);
        }

        .focus-mode-progress {
            position: fixed;
            top: 130px;
            left: 20px;
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            z-index: 1002;
            overflow: hidden;
        }

        .focus-mode-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            width: 0%;
            transition: width 0.3s ease-in-out;
            border-radius: 2px;
        }

        .ui-dim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.05);
            pointer-events: none;
            z-index: 996;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .ui-dim-overlay.active {
            opacity: 1;
        }

        /* FLOATING TIMER WIDGET */
        .floating-timer-widget {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(52, 73, 94, 0.95);
            border: 2px solid #f39c12;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 12px;
            z-index: 1003;
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.5s ease-in-out;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .floating-timer-widget.active {
            opacity: 1;
            transform: translateX(0);
        }

        .floating-timer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .floating-timer-display {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            color: #f39c12;
        }

        .floating-timer-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .floating-timer-button {
            background: rgba(52, 73, 94, 0.8);
            border: 1px solid #7f8c8d;
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .floating-timer-button:hover {
            background: rgba(52, 73, 94, 1);
            border-color: #f39c12;
        }

        .floating-timer-close {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #95a5a6;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
        }

        .floating-timer-close:hover {
            color: #f39c12;
        }

        /* RESPONSIVE DESIGN FOR FOCUS TAB */
        @media (max-width: 768px) {
            .focus-tab-navigation {
                height: 50px;
                gap: 3px;
                padding: 0 10px;
            }

            .focus-tab-button {
                font-size: 9px;
                padding: 6px 10px;
                min-width: 60px;
            }

            .focus-tab-content {
                top: 100px;
                padding: 15px;
            }

            .focus-mode-badge {
                top: 110px;
                left: 10px;
                font-size: 9px;
                padding: 6px 10px;
            }

            .focus-mode-progress {
                top: 140px;
                left: 10px;
                width: 150px;
            }
        }

        @media (max-width: 480px) {
            .focus-tab-navigation {
                flex-wrap: wrap;
                height: auto;
                padding: 5px 10px;
            }

            .focus-tab-button {
                font-size: 8px;
                padding: 4px 8px;
                min-width: 50px;
            }

            .focus-tab-content {
                top: 120px;
                padding: 10px;
            }

            .focus-mode-badge {
                top: 130px;
                left: 5px;
                font-size: 8px;
                padding: 4px 8px;
            }

            .focus-mode-progress {
                top: 160px;
                left: 5px;
                width: 120px;
            }
        }
    </style>
</head>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Growtopia - P5.js Isometric Garden MVP</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            font-family: 'Press Start 2P', cursive;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        /* Full-screen game container with new background */
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('assets/isometric_garden.png');
            background-size: 130%; /* Zoom to 130% to show center of image */
            background-position: center center; /* Center the image */
            background-repeat: no-repeat; /* Don't repeat the image */
            background-color: #87ceeb; /* Fallback color if image fails to load */
            cursor: grab;
        }
        
        #game-container:active {
            cursor: grabbing;
        }
        
        /* Canvas scaling transitions for Focus Mode */
        #defaultCanvas0, #game-container canvas {
            transition: transform 0.5s ease-in-out;
            transform-origin: center center;
        }
        
        /* Zoom and pan wrapper for the grid */
        #grid-viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            pointer-events: auto;
        }
        
        /* Ensure UI panels stay above the transformed grid and transition video */
        .ui-panel, .focus-mode-button, .restart-button, .top-ui-bar, .focus-mode-nav, 
        .focus-mode-overlay, .focus-game-overlay, .shop-panel, .inventory-panel, 
        .plant-condition-panel, .focus-widget, .focus-top-bar, .focus-side-panel, 
        .focus-music-player {
            position: fixed !important;
            pointer-events: auto !important;
            z-index: 1000 !important; /* Ensure UI stays above transition video */
        }
        
        /* Ensure focus mode overlays cover the full screen */
        .focus-mode-overlay, .focus-game-overlay {
            width: 100vw !important;
            height: 100vh !important;
            top: 0 !important;
            left: 0 !important;
        }
        
        /* Zoom indicator */
        .zoom-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 9px;
            z-index: 1000;
            pointer-events: none;
            line-height: 1.4;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .zoom-indicator .zoom-level {
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 3px;
        }
        
        .zoom-indicator .zoom-controls {
            font-size: 8px;
            opacity: 0.8;
        }
        
        /* Intro Pop-ups */
        .intro-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .popup-content {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 3px solid #f39c12;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            color: white;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }
        
        .popup-content h2 {
            color: #f39c12;
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        .popup-content p {
            font-size: 10px;
            line-height: 1.6;
            margin-bottom: 25px;
        }
        
        .popup-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .popup-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        /* TOP UI BAR */
        .top-ui-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border-bottom: 3px solid #f39c12;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            font-size: 10px;
            color: white;
        }
        
        .weather-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .weather-icon {
            font-size: 20px;
            animation: weatherPulse 3s ease-in-out infinite;
        }
        
        @keyframes weatherPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .currency-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .coin-counter {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #f39c12;
        }
        
        .xp-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .xp-bar {
            width: 120px;
            height: 6px;
            background: #34495e;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.5s ease;
        }

        /* Main UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 9px;
            backdrop-filter: blur(5px);
            z-index: 1000;
        }
        
        .ui-panel h3 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 10px;
            text-align: center;
            border-bottom: 1px solid #34495e;
            padding-bottom: 8px;
        }
        
        /* Resources Panel */
        #resources-panel {
            top: 150px;
            left: 10px;
            width: 180px;
        }
        
        .resource-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            align-items: center;
        }
        
        /* Weather Panel */
        #weather-panel {
            bottom: 410px;
            right: 10px;
            width: 200px;
        }
        
        .weather-info {
            text-align: center;
            margin: 8px 0;
        }
        
        .weather-icon {
            font-size: 20px;
            margin: 5px 0;
        }
        
        /* Plant Status Panel */
        #plant-status-panel {
            top: 180px;
            right: 10px;
            width: 150px;
            max-height: 150px;
            overflow-y: auto;
            display: none !important; /* Hide the panel visually - force override */
            visibility: hidden !important; /* Additional hiding */
            opacity: 0 !important; /* Make completely transparent */
            pointer-events: none !important; /* Disable interactions */
        }
        
        .plant-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
            padding: 4px;
            background: rgba(52, 73, 94, 0.5);
            border-radius: 4px;
        }
        
        .plant-icons {
            display: flex;
            gap: 5px;
        }
        
        .status-icon {
            font-size: 10px;
        }
        
        .needs-water { color: #3498db; }
        .unhealthy { color: #e74c3c; }
        .ready-harvest { color: #f39c12; }
        .healthy { color: #27ae60; }
        
        /* Shop Panel */
        #shop-panel {
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 360px;
            overflow-y: auto;
        }
        
        .shop-category {
            margin: 10px 0;
        }
        
        .shop-category h4 {
            color: #f39c12;
            font-size: 8px;
            margin: 5px 0;
            border-bottom: 1px solid #34495e;
            padding-bottom: 3px;
        }
        
        .shop-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 1px solid #2ecc71;
            color: white;
            padding: 6px 8px;
            margin: 2px 0;
            cursor: pointer;
            font-family: inherit;
            font-size: 7px;
            border-radius: 3px;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .shop-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-1px);
        }
        
        .shop-button:disabled {
            background: #7f8c8d;
            border-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .shop-button:active {
            transform: translateY(1px);
        }
        
        /* Inventory Panel */
        #inventory-panel {
            top: 320px;
            left: 10px;
            width: 180px;
        }
        
        /* Narrative Panel */
        #narrative-panel {
            top: 280px;
            right: 10px;
            width: 160px;
        }
        
        .narrative-text {
            font-style: italic;
            color: #ecf0f1;
            font-size: 8px;
            line-height: 1.4;
            text-align: center;
        }
        
        /* Animal Helper */
        .animal-helper {
            position: absolute;
            font-size: 16px;
            z-index: 100;
            animation: hop 2s infinite ease-in-out;
        }
        
        @keyframes hop {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.95);
            color: #f39c12;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 10px;
            z-index: 9999;
            border: 2px solid #f39c12;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); background-color: rgba(46, 204, 113, 0.2); }
            50% { transform: scale(1.1); background-color: rgba(46, 204, 113, 0.4); }
            100% { transform: scale(1); background-color: rgba(46, 204, 113, 0.2); }
        }
        
        /* NEW: Coin sparkle animation for streak rewards */
        @keyframes coinSparkle {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 0 rgba(255, 215, 0, 0);
                color: inherit;
            }
            25% { 
                transform: scale(1.15); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
                color: #ffd700;
                text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: scale(1.2); 
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.6);
                color: #ffed4e;
                text-shadow: 0 0 15px rgba(255, 215, 0, 1);
            }
            75% { 
                transform: scale(1.1); 
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
                color: #ffd700;
                text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 rgba(255, 215, 0, 0);
                color: inherit;
                text-shadow: none;
            }
        }
        
        /* Tools Indicators */
        .tool-indicator {
            position: absolute;
            font-size: 12px;
            z-index: 50;
        }
        
        .sprinkler { color: #3498db; }
        .greenhouse { color: #27ae60; }
        
        /* ANIMATION ENHANCEMENTS */
        
        /* Plant animations */
        @keyframes plantSway {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }
        
        @keyframes plantGrow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes plantPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        
        /* Water animation */
        @keyframes waterDrop {
            0% { transform: translateY(-10px); opacity: 1; }
            100% { transform: translateY(20px); opacity: 0; }
        }
        
        .water-effect {
            position: absolute;
            color: #3498db;
            font-size: 12px;
            animation: waterDrop 1s ease-out forwards;
            pointer-events: none;
        }
        
        .pesticide-effect {
            position: absolute;
            color: #27ae60;
            font-size: 12px;
            animation: pesticideSpray 1.5s ease-out forwards;
            pointer-events: none;
        }
        
        /* NEW: HEALING ANIMATION */
        .healing-effect {
            position: absolute;
            color: #f1c40f;
            font-size: 16px;
            animation: healingSparkle 2s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }
        
        .sunlight-effect {
            position: absolute;
            color: #f39c12;
            font-size: 14px;
            animation: sunlightBeam 2s ease-out forwards;
            pointer-events: none;
        }
        
        .remove-effect {
            position: absolute;
            color: #e74c3c;
            font-size: 16px;
            animation: removeTree 1.2s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes pesticideSpray {
            0% { transform: translateY(0) scale(0.3) rotate(0deg); opacity: 1; }
            50% { transform: translateY(-20px) scale(1) rotate(180deg); opacity: 0.8; }
            100% { transform: translateY(-40px) scale(0.5) rotate(360deg); opacity: 0; }
        }
        
        /* NEW: HEALING SPARKLE ANIMATION */
        @keyframes healingSparkle {
            0% { transform: translateY(0) scale(0.5) rotate(0deg); opacity: 0; }
            20% { transform: translateY(-10px) scale(1) rotate(90deg); opacity: 1; }
            50% { transform: translateY(-20px) scale(1.2) rotate(180deg); opacity: 0.9; }
            80% { transform: translateY(-30px) scale(1) rotate(270deg); opacity: 0.6; }
            100% { transform: translateY(-40px) scale(0.3) rotate(360deg); opacity: 0; }
        }
        
        @keyframes sunlightBeam {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-10px) scale(1); opacity: 1; }
            80% { transform: translateY(-30px) scale(1.2); opacity: 0.8; }
            100% { transform: translateY(-50px) scale(0.8); opacity: 0; }
        }
        
        @keyframes removeTree {
            0% { transform: translateY(0) scale(1) rotate(0deg); opacity: 1; }
            50% { transform: translateY(-15px) scale(1.2) rotate(180deg); opacity: 0.8; }
            100% { transform: translateY(-30px) scale(0.3) rotate(360deg); opacity: 0; }
        }
        
        /* Coin collection animation */
        @keyframes coinCollect {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            50% { transform: scale(1.5) translateY(-20px); opacity: 0.8; }
            100% { transform: scale(0) translateY(-40px); opacity: 0; }
        }
        
        .coin-animation {
            position: absolute;
            font-size: 14px;
            color: #f39c12;
            animation: coinCollect 1s ease-out forwards;
            pointer-events: none;
            z-index: 1001;
        }
        
        /* Enhanced Weather Effects */
        .weather-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 2s ease-in-out;
        }
        
        /* Background tints for different weather */
        .weather-tint {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .weather-tint.rain {
            background: linear-gradient(to bottom, rgba(52, 152, 219, 0.1), rgba(52, 152, 219, 0.2));
        }
        
        .weather-tint.heavy-rain {
            background: linear-gradient(to bottom, rgba(31, 81, 119, 0.4), rgba(31, 81, 119, 0.6));
        }
        
        .weather-tint.snow {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.25));
        }
        
        .weather-tint.cloudy {
            background: linear-gradient(to bottom, rgba(149, 165, 166, 0.1), rgba(149, 165, 166, 0.2));
        }
        
        .weather-tint.sunny {
            background: linear-gradient(to bottom, rgba(255, 193, 7, 0.05), rgba(255, 193, 7, 0.1));
        }
        
        /* Enhanced Rain Effects */
        .rain-drop {
            position: absolute;
            width: 3px;
            height: 20px;
            background: linear-gradient(transparent, #3498db, transparent);
            animation: rainFall linear infinite;
            opacity: 0.8;
        }
        
        .rain-drop.heavy {
            width: 4px;
            height: 30px;
            background: linear-gradient(to bottom, transparent 0%, #1f4e79 10%, #2980b9 40%, #3498db 60%, #2980b9 85%, transparent 100%);
            opacity: 0.5;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 5px rgba(31, 78, 121, 0.7), 0 0 2px rgba(52, 152, 219, 0.8);
            filter: brightness(1.2);
            animation: heavyRainFall linear infinite;
        }
        
        .rain-drop.light {
            width: 1px;
            height: 8px;
            opacity: 0.6;
        }
        
        @keyframes rainFall {
            0% { 
                transform: translateY(-20px) rotate(15deg); 
                opacity: 0;
            }
            5% { opacity: 0.8; }
            95% { opacity: 0.8; }
            100% { 
                transform: translateY(100vh) rotate(15deg); 
                opacity: 0;
            }
        }
        
        /* Special enhanced animation for heavy rain only */
        
        @keyframes heavyRainFall {
            0% { 
                transform: translateY(-30px) rotate(15deg) scaleY(0.8); 
                opacity: 0;
            }
            3% { 
                opacity: 1; 
                transform: translateY(-10px) rotate(15deg) scaleY(1);
            }
            97% { 
                opacity: 1; 
                transform: translateY(calc(100vh - 10px)) rotate(15deg) scaleY(1.2);
            }
            100% { 
                transform: translateY(100vh) rotate(15deg) scaleY(0.8); 
                opacity: 0;
            }
        }
        
        /* Enhanced Snow Effects */
        .snow-flake {
            position: absolute;
            color: white;
            font-size: 10px;
            animation: snowFall linear infinite;
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
        }
        
        .snow-flake.large {
            font-size: 14px;
        }
        
        .snow-flake.small {
            font-size: 6px;
            opacity: 0.7;
        }
        
        @keyframes snowFall {
            0% { 
                transform: translateY(-20px) rotate(0deg); 
                opacity: 0;
            }
            5% { opacity: 1; }
            95% { opacity: 1; }
            100% { 
                transform: translateY(100vh) rotate(360deg) translateX(50px); 
                opacity: 0;
            }
        }
        
        /* Enhanced Sun Effects */
        .sun-glow {
            position: absolute;
            top: 5%;
            right: 10%;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,193,7,0.3) 0%, rgba(255,193,7,0.1) 40%, rgba(255,193,7,0) 70%);
            animation: sunGlow 6s ease-in-out infinite;
            border-radius: 50%;
        }
        
        @keyframes sunGlow {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.6;
                box-shadow: 0 0 50px rgba(255,193,7,0.3);
            }
            50% { 
                transform: scale(1.1); 
                opacity: 0.8;
                box-shadow: 0 0 80px rgba(255,193,7,0.5);
            }
        }
        
        .sunbeam {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255,193,7,0.2) 0%, rgba(255,193,7,0) 70%);
            animation: sunbeamPulse 4s ease-in-out infinite;
            border-radius: 50%;
        }
        
        @keyframes sunbeamPulse {
            0%, 100% { 
                opacity: 0.3; 
                transform: scale(1) rotate(0deg); 
            }
            50% { 
                opacity: 0.6; 
                transform: scale(1.3) rotate(180deg); 
            }
        }
        
        /* Cloud Effects */
        .cloud {
            position: absolute;
            background: rgba(236, 240, 241, 0.8);
            border-radius: 50px;
            animation: cloudFloat linear infinite;
            box-shadow: 0 0 20px rgba(189, 195, 199, 0.5);
        }
        
        .cloud.large {
            width: 200px;
            height: 60px;
            top: 10%;
        }
        
        .cloud.medium {
            width: 150px;
            height: 45px;
            top: 20%;
        }
        
        .cloud.small {
            width: 100px;
            height: 30px;
            top: 15%;
        }
        
        @keyframes cloudFloat {
            0% { 
                transform: translateX(-250px); 
                opacity: 0;
            }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { 
                transform: translateX(calc(100vw + 50px)); 
                opacity: 0;
            }
        }
        
        /* Mist/Fog Effects */
        .mist {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30%;
            background: linear-gradient(to top, rgba(189, 195, 199, 0.4), rgba(189, 195, 199, 0));
            animation: mistMove 8s ease-in-out infinite;
        }
        
        @keyframes mistMove {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }
        
        /* Purchase notification */
        .purchase-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.95);
            color: #f39c12;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 9px;
            z-index: 9999;
            border: 2px solid #f39c12;
            animation: purchaseNotify 2s ease-in-out forwards;
        }
        
        @keyframes purchaseNotify {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* Plant status bubbles */
        .status-bubble {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            border-radius: 8px;
            font-size: 8px;
            z-index: 150;
            pointer-events: none;
        }
        
        .status-ring {
            position: absolute;
            border: 2px solid;
            border-radius: 50%;
            z-index: 149;
            pointer-events: none;
            animation: statusPulse 2s ease-in-out infinite;
        }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        .status-ring.healthy { border-color: #27ae60; }
        .status-ring.needs-care { border-color: #f39c12; }
        .status-ring.sick { border-color: #e74c3c; }
        
        /* NEW: Yellow tint for sick plants */
        .sick-tint {
            filter: sepia(0.3) hue-rotate(45deg) saturate(1.5) !important;
        }
        
        /* Button shake animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* Inventory panel enhancements */
        .inventory-section {
            margin: 8px 0;
        }
        
        .inventory-section h4 {
            color: #f39c12;
            font-size: 8px;
            margin: 5px 0 3px 0;
            border-bottom: 1px solid #34495e;
            padding-bottom: 2px;
        }
        
        .inventory-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 8px;
        }
        
        .clickable-item {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        
        .clickable-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        
        .clickable-item.selected {
            background-color: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }
        
        .selected-indicator {
            color: #27ae60;
            font-weight: bold;
            font-size: 10px;
        }
        
        /* Tool buttons in inventory */
        .tool-buttons-container {
            margin: 5px 0;
        }
        
        .tool-buttons-container .tool-button {
            width: 100%;
            margin: 2px 0;
            padding: 4px 8px;
            font-size: 8px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tool-buttons-container .tool-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(142, 68, 173, 0.3);
        }
        
        .tool-buttons-container .tool-button.selected {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }
        
        .tool-info {
            margin-top: 8px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        /* Disabled inventory items */
        .inventory-item.disabled {
            opacity: 0.4;
            pointer-events: none;
            background: rgba(100, 100, 100, 0.2);
        }
        
        .tool-button.disabled {
            opacity: 0.4;
            pointer-events: none;
            background: linear-gradient(145deg, #666, #777) !important;
            border-color: #666 !important;
        }
        
        .disabled-overlay {
            position: relative;
        }
        
        .disabled-overlay::after {
            content: "ðŸ”’ Purchase in Shop";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6px;
            color: #ccc;
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
        }
        
        .seed-count {
            background: rgba(46, 204, 113, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(46, 204, 113, 0.3);
            font-weight: bold;
            color: #2ecc71;
        }
        
        .inventory-note {
            font-size: 7px;
            color: #95a5a6;
            font-style: italic;
            margin-top: 5px;
            text-align: center;
        }
        
        .clickable-inventory-item {
            cursor: pointer;
            transition: background-color 0.2s ease;
            padding: 4px 6px;
            border-radius: 3px;
            position: relative;
        }
        
        .clickable-inventory-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        
        .clickable-inventory-item.selected {
            background-color: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }
        
        .selection-indicator {
            font-size: 7px;
            color: #f39c12;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .tool-count, .animal-count {
            background: rgba(52, 152, 219, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            font-weight: bold;
            color: #3498db;
        }
        
        /* NEW: Tool Selection Styles */
        .tool-button {
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            padding: 8px 12px;
            margin: 3px 0;
            width: 100%;
            font-family: inherit;
            font-size: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tool-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-1px);
        }
        
        .tool-button.selected {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border-color: #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .tool-button:disabled {
            background: linear-gradient(145deg, #7f8c8d, #95a5a6);
            border-color: #95a5a6;
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .tool-section {
            margin: 10px 0;
        }
        
        .tool-info {
            border-top: 1px solid #34495e;
            padding-top: 8px;
            margin-top: 8px;
        }
        
        /* Debug mode styles */
        .debug-info {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px;
            font-size: 8px;
            font-family: monospace;
            border-radius: 4px;
            min-width: 200px;
        }

        /* =============================================================================
           FOCUS MODE STYLES
           ============================================================================= */
        
        /* Focus Mode Button */
        .focus-mode-button {
            position: fixed;
            top: 60px;
            right: 20px; /* Moved to top-right for better accessibility */
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            padding: 12px 18px; /* Slightly larger for better visibility */
            font-family: inherit;
            font-size: 11px; /* Slightly larger text */
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2000 !important; /* Highest z-index to stay above transition video */
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto !important; /* Ensure it's always clickable */
            box-shadow: 0 4px 12px rgba(142, 68, 173, 0.3); /* Add shadow for visibility */
        }
        
        .focus-mode-button:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        
        .focus-mode-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
            animation: focusPulse 2s ease-in-out infinite;
        }
        
        @keyframes focusPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(46, 204, 113, 0.5); }
            50% { box-shadow: 0 0 20px rgba(46, 204, 113, 0.8); }
        }
        
        /* Restart Button */
        .restart-button {
            position: fixed;
            top: 100px;
            left: 10px;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border: 2px solid #e74c3c;
            color: white;
            padding: 10px 15px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .restart-button:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .restart-button:active {
            transform: translateY(0);
        }
        
        /* ENHANCED PLANT HEALTH VISUAL EFFECTS */
        .plant-sick {
            animation: plantSick 0.8s ease-in-out infinite;
        }
        
        .plant-dead {
            filter: grayscale(80%) brightness(0.6);
        }
        
        @keyframes plantSick {
            0%, 100% { 
                filter: hue-rotate(0deg) brightness(1);
                transform: scale(1) translateX(0);
            }
            25% { 
                filter: hue-rotate(15deg) brightness(1.2);
                transform: scale(1.05) translateX(-1px);
            }
            50% { 
                filter: hue-rotate(30deg) brightness(1.3);
                transform: scale(1.1) translateX(1px);
            }
            75% { 
                filter: hue-rotate(15deg) brightness(1.2);
                transform: scale(1.05) translateX(-1px);
            }
        }
        
        /* PLANT CONDITION HOVER PANEL */
        .plant-condition-panel {
            position: fixed;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 12px;
            z-index: 1000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease-in-out;
        }
        
        .plant-condition-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f39c12;
        }
        
        .plant-icon {
            font-size: 20px;
        }
        
        .plant-name {
            font-weight: bold;
            font-size: 14px;
            color: #f39c12;
        }
        
        .plant-stage {
            font-size: 11px;
            color: #bdc3c7;
            margin-left: auto;
        }
        
        .condition-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .condition-label {
            min-width: 60px;
            font-weight: bold;
        }
        
        .health-bar, .water-bar, .sunlight-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            transition: width 0.3s ease;
        }
        
        .water-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            transition: width 0.3s ease;
        }
        
        .sunlight-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #f39c12);
            transition: width 0.3s ease;
        }
        
        .health-value, .water-value, .sunlight-value {
            min-width: 35px;
            text-align: right;
            font-weight: bold;
        }
        
        .status-section {
            margin: 15px 0;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        
        .status-icon {
            font-size: 16px;
        }
        
        .status-text {
            font-weight: bold;
        }
        
        .treatment-section {
            margin-top: 15px;
        }
        
        .treatment-section h4 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 13px;
        }
        
        .treatment-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .treatment-item {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 3px;
            font-weight: normal;
            line-height: 1.3;
        }
        
        /* Treatment type styling */
        .treatment-dead {
            background: rgba(231, 76, 60, 0.3);
            border-left: 4px solid #e74c3c;
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
        }
        
        .treatment-condition {
            background: rgba(230, 126, 34, 0.2);
            border-left: 3px solid #e67e22;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        .treatment-task {
            background: rgba(52, 152, 219, 0.2);
            border-left: 3px solid #3498db;
            color: #ecf0f1;
            font-size: 10px;
            margin-left: 10px;
        }
        
        .treatment-result {
            background: rgba(155, 89, 182, 0.2);
            border-left: 3px solid #9b59b6;
            color: #bdc3c7;
            font-size: 10px;
            margin-left: 10px;
            font-style: italic;
        }
        
        .treatment-warning {
            background: rgba(241, 196, 15, 0.2);
            border-left: 3px solid #f1c40f;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        .treatment-note {
            background: rgba(127, 140, 141, 0.2);
            border-left: 3px solid #7f8c8d;
            color: #bdc3c7;
            font-size: 10px;
            margin-left: 10px;
        }
        
        .treatment-success {
            background: rgba(39, 174, 96, 0.2);
            border-left: 3px solid #27ae60;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* Focus Mode Overlay */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: none;
            color: white;
            overflow-y: auto;
            padding: 20px;
        }
        
        .focus-mode-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
        }
        
        .focus-mode-overlay.active {
            display: flex;
        }
        
        /* Pomodoro Timer Styles */
        .pomodoro-main-display {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }
        
        .timer-time {
            font-size: 36px;
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .timer-phase {
            color: #f39c12;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .timer-session {
            color: #bdc3c7;
            font-size: 11px;
        }
        
        /* Session Controls */
        .session-controls {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .session-controls label {
            color: #ecf0f1;
            font-size: 11px;
            display: block;
            margin-bottom: 10px;
        }
        
        .cycle-adjuster {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .cycle-btn {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #f39c12;
            color: #f39c12;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .cycle-btn:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            transform: scale(1.1);
        }
        
        .cycle-count {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        /* Timer Controls */
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .timer-btn {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .timer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .timer-btn.start {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
        }
        
        .timer-btn.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .timer-btn.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        
        /* Phase-based styling */
        .pomodoro-main-display.focus {
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }
        
        .pomodoro-main-display.short-break {
            border-color: #2ecc71;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
        }
        
        .pomodoro-main-display.long-break {
            border-color: #9b59b6;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.3);
        }
        
        /* =============================================================================
           MAIN GARDEN TIMER PANEL (Synchronized with Focus Mode timer)
           ============================================================================= */
        
        .main-garden-timer-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
            z-index: 9998; /* Below focus mode overlays but above other UI */
            min-width: 380px;
            max-width: 500px;
            text-align: center;
        }
        
        .main-timer-content h3 {
            color: #f39c12;
            margin: 0 0 15px 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .main-timer-display {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .main-timer-time {
            font-size: 28px;
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .main-timer-phase {
            color: #f39c12;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .main-timer-session {
            color: #bdc3c7;
            font-size: 10px;
        }
        
        .main-timer-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .main-timer-btn {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .main-timer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .main-timer-btn.start {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border-color: #2ecc71;
        }
        
        .main-timer-btn.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .main-timer-btn.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        
        .main-timer-settings {
            margin-bottom: 15px;
        }
        
        .main-setting-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .main-setting-group {
            flex: 1;
            text-align: center;
        }
        
        .main-setting-group label {
            display: block;
            color: #ecf0f1;
            font-size: 9px;
            margin-bottom: 4px;
        }
        
        .main-setting-group input {
            width: 100%;
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 1px solid #f39c12;
            border-radius: 4px;
            color: #ecf0f1;
            font-size: 10px;
            padding: 4px 6px;
            text-align: center;
        }
        
        .main-setting-group input:focus {
            outline: none;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.5);
        }
        
        .main-timer-cycles {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .main-timer-cycles label {
            color: #ecf0f1;
            font-size: 9px;
        }
        
        .main-cycle-adjuster {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .main-cycle-btn {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #f39c12;
            color: #f39c12;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-cycle-btn:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            transform: scale(1.1);
        }
        
        .main-cycle-count {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #2c3e50;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }
        
        /* Phase-based styling for main garden timer */
        .main-timer-display.focus {
            border: 1px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.2);
        }
        
        .main-timer-display.short-break {
            border: 1px solid #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.2);
        }
        
        .main-timer-display.long-break {
            border: 1px solid #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.2);
        }
        
        .timer-display {
            font-size: 48px;
            font-weight: bold;
            color: #f39c12;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .timer-phase {
            font-size: 18px;
            color: #ecf0f1;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .timer-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .timer-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 20px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .timer-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        .timer-button.pause {
            background: linear-gradient(145deg, #e67e22, #f39c12);
            border-color: #f39c12;
        }
        
        .timer-button.pause:hover {
            background: linear-gradient(145deg, #f39c12, #e67e22);
        }
        
        .timer-button.stop {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
        }
        
        .timer-button.stop:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }
        
        /* Timer Settings */
        .timer-settings {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .setting-group label {
            font-size: 10px;
            color: #bdc3c7;
        }
        
        .setting-group input {
            background: #34495e;
            border: 1px solid #2c3e50;
            color: white;
            padding: 5px;
            border-radius: 4px;
            width: 60px;
            text-align: center;
            font-family: inherit;
        }
        
        /* Music Panel */
        .music-panel {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-width: 300px;
        }
        
        .music-panel h3 {
            color: #9b59b6;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 14px;
        }
        
        .music-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .music-option {
            background: rgba(52, 73, 94, 0.5);
            border: 1px solid #7f8c8d;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .music-option:hover {
            background: rgba(155, 89, 182, 0.3);
            border-color: #9b59b6;
        }
        
        .music-option.active {
            background: rgba(155, 89, 182, 0.5);
            border-color: #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.3);
        }
        
        .music-icon {
            font-size: 20px;
        }
        
        .music-info {
            flex: 1;
        }
        
        .music-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .music-description {
            font-size: 9px;
            color: #bdc3c7;
        }
        
        /* Focus Streak */
        .focus-streak {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            min-width: 250px;
        }
        
        .streak-display {
            font-size: 24px;
            color: #e74c3c;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .streak-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin: 15px 0;
        }
        
        .streak-day {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #34495e;
            border: 1px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .streak-day.completed {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
            box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }
        
        .streak-day.today {
            border: 2px solid #f39c12;
            animation: todayPulse 2s ease-in-out infinite;
        }
        
        @keyframes todayPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(243, 156, 18, 0.5); }
            50% { box-shadow: 0 0 10px rgba(243, 156, 18, 0.8); }
        }
        
        /* Focus Stats */
        .focus-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: rgba(52, 73, 94, 0.5);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #bdc3c7;
        }
        
        /* Focus Mode Controls */
        .focus-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
        }
        
        .focus-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 12px 20px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .focus-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }
        
        .focus-button.exit {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
        }
        
        .focus-button.exit:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }
        
        /* Pet System */
        .pet-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: none;
        }
        
        .pet {
            width: 60px;
            height: 60px;
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border: 2px solid #e67e22;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: petBounce 3s ease-in-out infinite;
        }
        
        .pet:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }
        
        @keyframes petBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .pet-accessory {
            position: absolute;
            font-size: 15px;
            pointer-events: none;
        }
        
        .pet-accessory.hat { top: -5px; }
        .pet-accessory.glasses { top: 10px; }
        .pet-accessory.scarf { bottom: -5px; }
        
        /* Focus Mode Game Overlay */
        .focus-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 62, 80, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }
        
        .focus-game-overlay.break {
            background: rgba(39, 174, 96, 0.8);
        }
        
        /* Focus Tokens */
        .focus-tokens {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 12px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .focus-token-icon {
            font-size: 16px;
            animation: tokenGlow 2s ease-in-out infinite;
        }
        
        @keyframes tokenGlow {
            0%, 100% { text-shadow: 0 0 5px rgba(155, 89, 182, 0.5); }
            50% { text-shadow: 0 0 15px rgba(155, 89, 182, 0.8); }
        }
        
        /* Focus Mode Notifications */
        .focus-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            border-radius: 10px;
            padding: 20px;
            color: white;
            text-align: center;
            z-index: 10000;
            animation: notificationSlide 0.5s ease-out;
        }
        
        /* Scroll to Top Button */
        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(145deg, #8e44ad, #9b59b6);
            border: 2px solid #9b59b6;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10001;
            font-size: 20px;
        }
        
        .scroll-to-top:hover {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        
        @keyframes notificationSlide {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* Responsive Design for Focus Mode */
        @media (max-width: 768px) {
            .focus-mode-overlay {
                padding: 10px;
            }
            
            .focus-mode-content {
                gap: 20px;
                padding: 10px 0;
            }
            
            .pomodoro-timer {
                min-width: 280px;
                padding: 20px;
            }
            
            .timer-display {
                font-size: 32px;
            }
            
            .timer-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .timer-settings {
                flex-direction: column;
                gap: 15px;
            }
            
            .music-panel,
            .focus-streak {
                min-width: 280px;
            }
            
            .focus-stats {
                gap: 10px;
                flex-direction: column;
            }
            
            .stat-item {
                min-width: 200px;
                padding: 15px;
            }
            
            .focus-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .focus-button {
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            .pomodoro-timer {
                min-width: 250px;
                padding: 15px;
            }
            
            .timer-display {
                font-size: 28px;
            }
            
            .music-panel,
            .focus-streak {
                min-width: 250px;
            }
            
            .music-option {
                padding: 8px;
            }
            
            .music-title {
                font-size: 11px;
            }
            
            .music-description {
                font-size: 8px;
            }
        }

        /* FOCUS MODE TAB NAVIGATION */
        .focus-tab-navigation {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-bottom: 2px solid #f39c12;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 0 20px;
            z-index: 999;
        }

        .focus-tab-button {
            background: rgba(52, 73, 94, 0.7);
            border: 2px solid #34495e;
            color: #bdc3c7;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            text-align: center;
        }

        .focus-tab-button:hover {
            background: rgba(52, 73, 94, 0.9);
            color: #ecf0f1;
            border-color: #7f8c8d;
        }

        .focus-tab-button.active {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border-color: #f39c12;
            color: white;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        /* FOCUS MODE TAB CONTENT */
        .focus-tab-content {
            position: fixed;
            top: 90px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(5px);
            z-index: 998;
            display: none;
            overflow-y: auto;
            padding: 20px;
        }

        .focus-tab-content.active {
            display: block;
        }

        .focus-tab {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .focus-section {
            background: rgba(52, 73, 94, 0.8);
            border: 2px solid #34495e;
            border-radius: 8px;
            padding: 15px;
        }

        .focus-section h3 {
            color: #f39c12;
            margin: 0 0 15px 0;
            font-size: 14px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 8px;
        }

        .back-to-game-button {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            color: white;
            padding: 10px 16px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .back-to-game-button:hover {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
        }

        /* FOCUS MODE UI PANELS */
        .focus-top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            font-size: 10px;
            border-bottom: 2px solid #3498db;
            backdrop-filter: blur(5px);
        }
        
        .focus-streak-info, .focus-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .focus-timer-display {
            text-align: center;
        }
        
        .pomodoro-timer {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        #focus-timer-display {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }
        
        #focus-timer-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
        }
        
        #focus-timer-btn:hover {
            background: #2980b9;
        }
        
        .focus-side-panel {
            position: fixed;
            left: 10px;
            top: 110px;
            width: 200px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            font-size: 9px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .focus-side-panel h3 {
            margin: 0 0 15px 0;
            color: #3498db;
            font-size: 11px;
        }
        
        .focus-side-panel h4 {
            margin: 10px 0 5px 0;
            font-size: 9px;
            color: #ecf0f1;
        }
        
        .focus-tip {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .focus-tip p {
            margin: 5px 0 0 0;
            line-height: 1.4;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            text-align: center;
            font-size: 8px;
            color: #bdc3c7;
        }
        
        .focus-task {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 8px;
        }
        
        .focus-task:last-child {
            border-bottom: none;
        }
        
        /* FOCUS MODE MUSIC PLAYER */
        .focus-music-player {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 80px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            border-radius: 30px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .music-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .music-controls button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .music-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .music-info {
            flex: 1;
            text-align: center;
            margin: 0 15px;
        }
        
        .track-title {
            font-size: 10px;
            margin-bottom: 5px;
            color: #3498db;
        }
        
        #track-selector {
            background: rgba(52, 73, 94, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 2px 5px;
            font-size: 9px;
            margin-bottom: 5px;
            cursor: pointer;
            outline: none;
            width: 100%;
        }
        
        #track-selector:hover {
            background: rgba(52, 73, 94, 1);
        }
        
        #track-selector option {
            background: rgba(52, 73, 94, 1);
            color: white;
        }
        
        .music-progress {
            width: 100%;
        }
        
        .music-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .music-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.1s ease;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .volume-control span {
            font-size: 12px;
        }
        
        #volume-slider {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        #volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* CUSTOM APPLE ICON */
        .apple-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-image: url('assets/apple/apple.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            vertical-align: middle;
        }
        
        .apple-icon-small {
            width: 12px;
            height: 12px;
        }
        
        .apple-icon-medium {
            width: 20px;
            height: 20px;
        }
        
        .apple-icon-large {
            width: 24px;
            height: 24px;
        }
        
        /* CUSTOM WATER ICON */
        .water-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-image: url('assets/water.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            vertical-align: middle;
        }
        
        .water-icon-small {
            width: 12px;
            height: 12px;
        }
        
        .water-icon-medium {
            width: 20px;
            height: 20px;
        }
        
        .water-icon-large {
            width: 24px;
            height: 24px;
        }
        
        /* FOCUS MODE TRANSITION VIDEO */
        .focus-transition-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 500; /* Below UI panels but above game */
            display: none;
            pointer-events: none !important; /* Never intercept clicks */
            transform: scale(1.3); /* Start at 130% zoom */
            transform-origin: center center;
        }
        
        /* Video zoom animation classes */
        .focus-transition-video.zoom-out {
            animation: zoomOutTransition 2s ease-out forwards;
        }
        
        @keyframes zoomOutTransition {
            from {
                transform: scale(1.3); /* Start at 130% */
            }
            to {
                transform: scale(1.0); /* End at 100% */
            }
        }
        
        /* FOCUS MODE EXIT TRANSITION VIDEO */
        .focus-exit-transition-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 500; /* Below UI panels but above game */
            display: none;
            pointer-events: none !important; /* Never intercept clicks */
            transform: scale(1.0); /* Start at 100% zoom */
            transform-origin: center center;
        }
        
        /* Exit video zoom animation classes */
        .focus-exit-transition-video.zoom-in {
            animation: zoomInTransition 2s ease-in forwards;
        }
        
        @keyframes zoomInTransition {
            from {
                transform: scale(1.0); /* Start at 100% */
            }
            to {
                transform: scale(1.3); /* End at 130% */
            }
        }
        
        /* FOCUS MODE VISUAL EFFECTS - LAYERED OVERLAY */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 997;
            transition: all 0.8s ease-in-out;
            opacity: 0;
            background: rgba(0, 0, 0, 0.3); /* Semi-transparent overlay */
        }
        
        .focus-mode-overlay.active {
            opacity: 1;
        }

        /* Sparkle effects */
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleFloat 4s ease-in-out infinite;
        }
        
        @keyframes sparkleFloat {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(80vh) scale(1);
            }
            80% {
                opacity: 1;
                transform: translateY(20vh) scale(1);
            }
            100% {
                transform: translateY(-20vh) scale(0);
                opacity: 0;
            }
        }

        .focus-mode-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.05);
            transition: all 2s ease-in-out;
        }

        .focus-mode-background.day {
            background: rgba(135, 206, 235, 0.03);
        }

        .focus-mode-background.sunset {
            background: rgba(255, 127, 80, 0.05);
        }

        .focus-mode-background.dusk {
            background: rgba(74, 144, 226, 0.08);
        }

        .focus-mode-background.night {
            background: rgba(26, 26, 46, 0.12);
        }

        .focus-mode-particles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        .focus-mode-sparkles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 6s infinite ease-in-out;
        }

        .firefly {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(255, 215, 0, 0.4);
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(255, 215, 0, 0.4);
            animation: firefly 8s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        @keyframes firefly {
            0%, 100% { transform: translateY(0px) translateX(0px); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-50px) translateX(20px); opacity: 0; }
        }

        .focus-mode-badge {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(243, 156, 18, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 9px;
            font-weight: bold;
            z-index: 1002;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.5s ease-in-out;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.2);
        }

        .focus-mode-badge.active {
            opacity: 1;
            transform: translateY(0);
        }

        .focus-mode-progress {
            position: fixed;
            top: 130px;
            left: 20px;
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            z-index: 1002;
            overflow: hidden;
        }

        .focus-mode-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            width: 0%;
            transition: width 0.3s ease-in-out;
            border-radius: 2px;
        }

        .ui-dim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.05);
            pointer-events: none;
            z-index: 996;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .ui-dim-overlay.active {
            opacity: 1;
        }

        /* FLOATING TIMER WIDGET */
        .floating-timer-widget {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(52, 73, 94, 0.95);
            border: 2px solid #f39c12;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 12px;
            z-index: 1003;
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.5s ease-in-out;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .floating-timer-widget.active {
            opacity: 1;
            transform: translateX(0);
        }

        .floating-timer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .floating-timer-display {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            color: #f39c12;
        }

        .floating-timer-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .floating-timer-button {
            background: rgba(52, 73, 94, 0.8);
            border: 1px solid #7f8c8d;
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .floating-timer-button:hover {
            background: rgba(52, 73, 94, 1);
            border-color: #f39c12;
        }

        .floating-timer-close {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #95a5a6;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
        }

        .floating-timer-close:hover {
            color: #f39c12;
        }

        /* RESPONSIVE DESIGN FOR FOCUS TAB */
        @media (max-width: 768px) {
            .focus-tab-navigation {
                height: 50px;
                gap: 3px;
                padding: 0 10px;
            }

            .focus-tab-button {
                font-size: 9px;
                padding: 6px 10px;
                min-width: 60px;
            }

            .focus-tab-content {
                top: 100px;
                padding: 15px;
            }

            .focus-mode-badge {
                top: 110px;
                left: 10px;
                font-size: 9px;
                padding: 6px 10px;
            }

            .focus-mode-progress {
                top: 140px;
                left: 10px;
                width: 150px;
            }
        }

        @media (max-width: 480px) {
            .focus-tab-navigation {
                flex-wrap: wrap;
                height: auto;
                padding: 5px 10px;
            }

            .focus-tab-button {
                font-size: 8px;
                padding: 4px 8px;
                min-width: 50px;
            }

            .focus-tab-content {
                top: 120px;
                padding: 10px;
            }

            .focus-mode-badge {
                top: 130px;
                left: 5px;
                font-size: 8px;
                padding: 4px 8px;
            }

            .focus-mode-progress {
                top: 160px;
                left: 5px;
                width: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- TOP UI BAR -->
    <div class="top-ui-bar">
        <div class="weather-section">
                            <div class="weather-icon" id="top-weather-icon"><img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;"></div>
            <div>
                <div id="top-weather-condition">Sunny</div>
            </div>
        </div>
        
        <div class="currency-section">
            <div class="coin-counter">
                <img src="assets/coin.png" alt="Coin" style="width: 20px; height: 20px; vertical-align: middle;">
                <span id="top-coin-count">150</span>
            </div>
            
            <div class="xp-section">
                <span>â­</span>
                <div class="xp-bar">
                    <div class="xp-fill" id="xp-fill" style="width: 35%;"></div>
                </div>
                <span id="xp-level">Lv.1</span>
            </div>
        </div>
    </div>

    <!-- FOCUS MODE TAB NAVIGATION -->
    <div class="focus-tab-navigation">
                                <button class="focus-tab-button active" onclick="switchToGarden()" id="focus-tab-garden">
                            ðŸŒ± Garden
                        </button>
        <button class="focus-tab-button" onclick="switchToFocus()" id="focus-tab-focus">
            ðŸŽ¯ Focus Mode
        </button>
    </div>

    <!-- FOCUS MODE TAB CONTENT -->
    <div class="focus-tab-content" id="focus-tab-content">
        <div class="focus-tab">
            <!-- Focus Mode Timer (Pomodoro) -->
            <div class="focus-section">
                <h3>ðŸ… Pomodoro Timer</h3>
                
                <!-- Main Timer Display -->
                <div class="pomodoro-main-display">
                    <div class="timer-time" id="focus-timer-display">25:00</div>
                    <div class="timer-phase" id="focus-timer-phase">Ready to Focus</div>
                    <div class="timer-session" id="focus-timer-session">Session 1 of 4</div>
                </div>
                
                <!-- Session Controls -->
                <div class="session-controls">
                    <label>Cycles before long break:</label>
                    <div class="cycle-adjuster">
                        <button class="cycle-btn" onclick="adjustCycles(-1)">âˆ’</button>
                        <span class="cycle-count" id="cycle-count">4</span>
                        <button class="cycle-btn" onclick="adjustCycles(1)">+</button>
                    </div>
                </div>
                
                <!-- Timer Controls -->
                <div class="timer-controls">
                    <button class="timer-btn start" id="focus-timer-btn" onclick="toggleFocusTimer()">â–¶ï¸ Start</button>
                    <button class="timer-btn pause" id="focus-timer-pause" onclick="pauseFocusTimer()" style="display: none;">â¸ï¸ Pause</button>
                    <button class="timer-btn stop" id="focus-timer-stop" onclick="stopFocusTimer()">â¹ï¸ Reset</button>
                </div>
            </div>
            
            <div class="focus-section">
                <div class="timer-settings">
                    <div class="setting-group">
                        <label>Focus (min)</label>
                        <input type="number" id="focus-duration" value="25" min="1" max="120">
                    </div>
                    <div class="setting-group">
                        <label>Break (min)</label>
                        <input type="number" id="break-duration" value="5" min="1" max="30">
                    </div>
                    <div class="setting-group">
                        <label>Long Break (min)</label>
                        <input type="number" id="long-break-duration" value="15" min="1" max="60">
                    </div>
                </div>
            </div>

            <div class="focus-section">
                <h3>ðŸŽµ Focus Music</h3>
                <div class="music-options">
                    <div class="music-option" onclick="selectMusic('lofi')" id="music-lofi">
                        <div class="music-icon">ðŸŽ§</div>
                        <div class="music-info">
                            <div class="music-title">Lofi Beats</div>
                            <div class="music-description">Chill background music</div>
                        </div>
                    </div>
                    <div class="music-option" onclick="selectMusic('rain')" id="music-rain">
                        <div class="music-icon">ðŸŒ§ï¸</div>
                        <div class="music-info">
                            <div class="music-title">Rain Sounds</div>
                            <div class="music-description">Calming rain ambience</div>
                        </div>
                    </div>
                    <div class="music-option" onclick="selectMusic('fireplace')" id="music-fireplace">
                        <div class="music-icon">ðŸ”¥</div>
                        <div class="music-info">
                            <div class="music-title">Fireplace</div>
                            <div class="music-description">Cozy crackling sounds</div>
                        </div>
                    </div>
                    <div class="music-option" onclick="selectMusic('forest')" id="music-forest">
                        <div class="music-icon">ðŸŒ²</div>
                        <div class="music-info">
                            <div class="music-title">Forest Ambience</div>
                            <div class="music-description">Nature sounds</div>
                        </div>
                    </div>
                    <div class="music-option" onclick="selectMusic('none')" id="music-none">
                        <div class="music-icon">ðŸ”‡</div>
                        <div class="music-info">
                            <div class="music-title">No Music</div>
                            <div class="music-description">Silence</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="focus-section">
                <h3>ðŸ”¥ Focus Streak</h3>
                <div class="streak-display" id="focus-streak-display">0 Days</div>
                <div class="streak-calendar" id="focus-streak-calendar">
                    <!-- Calendar days will be generated by JavaScript -->
                </div>
            </div>

            <div class="focus-section">
                <h3>ðŸ“Š Focus Stats</h3>
                <div class="focus-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="focus-total-sessions">0</div>
                        <div class="stat-label">Total Sessions</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="focus-total-focus-time">0h</div>
                        <div class="stat-label">Focus Time</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="focus-current-streak">0</div>
                        <div class="stat-label">Day Streak</div>
                    </div>
                </div>
            </div>

            <div class="focus-section">
                <h3>ðŸŽ® Focus Controls</h3>
                <div class="focus-controls">
                    <button class="focus-button" onclick="startFocusSession()">ðŸš€ Start Focus Session</button>
                </div>
            </div>
        </div>
    </div>

    <!-- FOCUS MODE VISUAL EFFECTS -->
    <div class="focus-mode-overlay" id="focus-mode-overlay" style="display: none;">
        <div class="focus-mode-background day" id="focus-mode-background"></div>
        <div class="focus-mode-particles" id="focus-mode-particles"></div>
        <div class="focus-mode-sparkles" id="focus-mode-sparkles"></div>
    </div>
    
    <!-- FOCUS MODE TRANSITION VIDEO -->
    <video class="focus-transition-video" id="focus-transition-video" muted preload="auto">
        <source src="assets/transition.mp4" type="video/mp4">
    </video>
    
    <!-- FOCUS MODE EXIT TRANSITION VIDEO -->
    <video class="focus-exit-transition-video" id="focus-exit-transition-video" muted preload="auto">
        <source src="assets/transition1.mp4" type="video/mp4">
    </video>

    <!-- UI DIM OVERLAY -->
    <div class="ui-dim-overlay" id="ui-dim-overlay"></div>

    <!-- FOCUS MODE BADGE -->
    <div class="focus-mode-badge" id="focus-mode-badge">
        ðŸŽ¯ Focus Mode Active
    </div>

    <!-- FOCUS MODE PROGRESS -->
    <div class="focus-mode-progress" id="focus-mode-progress">
        <div class="focus-mode-progress-bar" id="focus-mode-progress-bar"></div>
    </div>

    <!-- FLOATING TIMER WIDGET -->
    <div class="floating-timer-widget" id="floating-timer-widget">
        <button class="floating-timer-close" onclick="exitFocusMode()">Ã—</button>
        <div class="floating-timer-header">
            ðŸŽ¯ Focus Mode Active
        </div>
        <!-- Floating timer removed - now using integrated Pomodoro timer -->
    </div>

    <!-- Back to Game Button (only visible in focus tab) -->
                    <button class="back-to-game-button" id="back-to-game-button" onclick="switchToGarden()" style="display: none;">
                    ðŸŒ± Back to Garden
                </button>

    <!-- Focus Mode Button -->
    <button class="focus-mode-button" id="focus-mode-button">
        ðŸŽ¯ Focus Mode
    </button>
    
    <!-- Pomodoro Timer Panel for Main Garden Page (only visible in Focus Mode) -->
    <div class="main-garden-timer-panel" id="main-garden-timer-panel" style="display: none;">
        <div class="main-timer-content">
            <h3>ðŸ… Pomodoro Timer</h3>
            
            <!-- Timer Display -->
            <div class="main-timer-display">
                <div class="main-timer-time" id="main-timer-time">25:00</div>
                <div class="main-timer-phase" id="main-timer-phase">Ready to Focus</div>
                <div class="main-timer-session" id="main-timer-session">Session 1 of 4</div>
            </div>
            
            <!-- Timer Controls -->
            <div class="main-timer-controls">
                <button class="main-timer-btn start" id="main-timer-start" onclick="toggleFocusTimer()">â–¶ï¸ Start</button>
                <button class="main-timer-btn pause" id="main-timer-pause" onclick="pauseFocusTimer()" style="display: none;">â¸ï¸ Pause</button>
                <button class="main-timer-btn stop" id="main-timer-stop" onclick="stopFocusTimer()">ðŸ”„ Reset</button>
            </div>
            
            <!-- Duration Settings -->
            <div class="main-timer-settings">
                <div class="main-setting-row">
                    <div class="main-setting-group">
                        <label>Focus (min)</label>
                        <input type="number" id="main-focus-duration" value="25" min="1" max="120" onchange="onMainTimerSettingChange()">
                    </div>
                    <div class="main-setting-group">
                        <label>Break (min)</label>
                        <input type="number" id="main-break-duration" value="5" min="1" max="30" onchange="onMainTimerSettingChange()">
                    </div>
                    <div class="main-setting-group">
                        <label>Long Break (min)</label>
                        <input type="number" id="main-long-break-duration" value="15" min="1" max="60" onchange="onMainTimerSettingChange()">
                    </div>
                </div>
            </div>
            
            <!-- Cycle Controls -->
            <div class="main-timer-cycles">
                <label>Cycles before long break:</label>
                <div class="main-cycle-adjuster">
                    <button class="main-cycle-btn" onclick="adjustCycles(-1)">âˆ’</button>
                    <span class="main-cycle-count" id="main-cycle-count">4</span>
                    <button class="main-cycle-btn" onclick="adjustCycles(1)">+</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Restart Game Button -->
    <button class="restart-button" id="restart-button" onclick="confirmRestart()">
        ðŸ”„ Restart Game
    </button>
    
            <!-- Focus Session Leaf Coins Display -->
        <div class="focus-session-coins" id="focus-session-coins">
            <span class="focus-coin-icon">ðŸƒ</span>
            <span id="focus-session-coin-count">0</span>
            <span style="font-size: 8px; margin-left: 3px;">Session Coins</span>
        </div>
    
    <!-- Plant Condition Hover Panel -->
    <div class="plant-condition-panel" id="plant-condition-panel" style="display: none;">
        <div class="panel-header">
            <span class="plant-icon" id="hover-plant-icon">ðŸŒ±</span>
            <span class="plant-name" id="hover-plant-name">Plant</span>
            <span class="plant-stage" id="hover-plant-stage">Stage 1</span>
        </div>
        
        <div class="panel-content">
            <div class="condition-row">
                <span class="condition-label">Health:</span>
                <div class="health-bar">
                    <div class="health-fill" id="hover-health-fill"></div>
                </div>
                <span class="health-value" id="hover-health-value">100%</span>
            </div>
            
            <div class="condition-row">
                <span class="condition-label">Water:</span>
                <div class="water-bar">
                    <div class="water-fill" id="hover-water-fill"></div>
                </div>
                <span class="water-value" id="hover-water-value">100%</span>
            </div>
            
            <div class="condition-row">
                <span class="condition-label">Sunlight:</span>
                <div class="sunlight-bar">
                    <div class="sunlight-fill" id="hover-sunlight-fill"></div>
                </div>
                <span class="sunlight-value" id="hover-sunlight-value">50%</span>
            </div>
            
            <div class="status-section">
                <div class="status-item" id="hover-status-item">
                    <span class="status-icon">âœ…</span>
                    <span class="status-text">Healthy</span>
                </div>
            </div>
            
            <div class="treatment-section">
                <h4>Treatment Required:</h4>
                <div class="treatment-list" id="hover-treatment-list">
                    <div class="treatment-item">No treatment needed</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="game-container">
        <!-- P5.js canvas will be inserted here -->
        
        <!-- Zoom Indicator -->
        <div class="zoom-indicator" id="zoom-indicator">
            <div class="zoom-level">Zoom: 100%</div>
            <div class="zoom-controls">+/- keys â€¢ 0 to reset<br/>Scroll wheel â€¢ Click & drag</div>
        </div>
        
        <!-- Focus Mode Game Overlay -->
        <div class="focus-game-overlay" id="focus-game-overlay" style="display: none;">
            <div>
                <h2 id="focus-overlay-title">Focus Session Active</h2>
                <p id="focus-overlay-message">Stay focused! Your plants are growing while you work.</p>
            </div>
        </div>
    </div>
    
    <!-- Weather Overlay for Effects -->
    <div class="weather-overlay" id="weather-overlay"></div>
    
    <!-- Focus Mode Overlay - REMOVED (now in focus tab) -->
    
    <!-- Pet Container -->
    <div class="pet-container" id="pet-container">
        <div class="pet" id="pet" onclick="interactWithPet()">
            ðŸ•
        </div>
        <div class="pet-accessory hat" id="pet-hat" style="display: none;">ðŸŽ©</div>
        <div class="pet-accessory glasses" id="pet-glasses" style="display: none;">ðŸ‘“</div>
        <div class="pet-accessory scarf" id="pet-scarf" style="display: none;">ðŸ§£</div>
    </div>
    
    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scroll-to-top" onclick="scrollToTop()" style="display: none;">
        â¬†ï¸
    </div>
    
    <!-- Intro Pop-ups -->
    <div id="intro-popup-1" class="intro-popup" style="display: none;">
        <div class="popup-content">
            <h2>ðŸŒ± Welcome to Growtopia!</h2>
            <p>
                            Welcome, gardener! You've inherited a magical plot of land where crops grow with the rhythm of nature and weather.
            Your goal is to build a thriving garden by planting seeds, caring for your crops, and expanding your agricultural empire.
            </p>
            <p>
                The land responds to weather patterns, so pay attention to rain, drought, and seasonal changes. 
                Your crops need water, protection from pollution, and animal helpers to truly flourish!
            </p>
            <button class="popup-button" onclick="showIntroPopup2()">Continue â†’</button>
        </div>
    </div>
    
    <div id="intro-popup-2" class="intro-popup" style="display: none;">
        <div class="popup-content">
            <h2>ðŸŽ® How to Get Started</h2>
            <p>
                <strong>Basic Controls:</strong><br>
                â€¢ Click any empty green tile to plant seeds<br>
                â€¢ Right-click mature crops to harvest them<br>
                â€¢ Buy seeds and tools from the shop<br>
                â€¢ Watch the weather - it affects your crops!
            </p>
            <p>
                <strong>Pro Tips:</strong><br>
                â€¢ Plants need water regularly (watch for blue droplets)<br>
                â€¢ Animal helpers protect crops from pests<br>
                â€¢ Sprinklers auto-water nearby tiles<br>
                â€¢ Check plant status panel for crop health
            </p>
                            <button class="popup-button" onclick="startGame()">Start Gardening! ðŸŒ±</button>
        </div>
    </div>
    
    <!-- Main UI Panels -->
    
    <!-- NEW: Tool Selection Panel (HIDDEN - now integrated into inventory) -->
    <div id="tool-panel" class="ui-panel" style="top: 320px; left: 10px; width: 180px; display: none;">
        <h3>ðŸ§° Tools</h3>
        <div class="tool-section">
            <button class="tool-button" onclick="selectTool('watering_can')" id="tool-watering-can">
                ðŸª£ Watering Can <span id="tool-watering-count">1</span>
            </button>
            <button class="tool-button" onclick="selectTool('pesticide')" id="tool-pesticide">
                ðŸ§ª Pesticide <span id="tool-pesticide-count">0</span>
            </button>
            <button class="tool-button" onclick="selectTool('solar_lamp')" id="tool-solar-lamp">
                <img src="assets/sun.png" alt="Solar Lamp" style="width: 16px; height: 16px; vertical-align: middle;"> Solar Lamp <span id="tool-solar-count">0</span>
            </button>
            <button class="tool-button" onclick="selectTool('shovel')" id="tool-shovel">
                ðŸ—¡ï¸ Shovel <span id="tool-shovel-count">1</span>
            </button>
        </div>
        <div class="tool-info">
            <p style="font-size: 8px; margin: 5px 0;">
                <strong>Selected:</strong> <span id="selected-tool-display">None</span>
            </p>
            <p style="font-size: 7px; margin: 0; color: #777;">
                Click tool, then click crop to use<br/>
                Shovel: Select + left-click to dig up trees
            </p>
        </div>
    </div>
    
    <!-- Resources Panel -->
    <div id="resources-panel" class="ui-panel" style="top: 150px;">
                        <h3>ðŸŒ¾ Garden Resources</h3>
        <div class="resource-item">
                            <span><img src="assets/coin.png" alt="Coin" style="width: 20px; height: 20px; vertical-align: middle;"> Coins:</span>
            <span id="coins">150</span>
        </div>
        <div class="resource-item">
            <span>ðŸŒ° Apple Seeds:</span>
            <span id="apple-seeds">8</span>
        </div>
        <div class="resource-item">
            <span>ðŸ¥• Carrot Seeds:</span>
            <span id="carrot-seeds">5</span>
        </div>
        <div class="resource-item">
                            <span><span class="apple-icon"></span> Harvested:</span>
                <span id="harvested">0</span>
        </div>
        <div class="resource-item">
                            <span>â­ Garden Level:</span>
                <span id="garden-level">1</span>
        </div>
    </div>
    
    <!-- Enhanced Live Weather Panel -->
    <div id="weather-panel" class="ui-panel" style="bottom: 410px; right: 10px; width: 200px;">
        <h3>ðŸŒ Live Weather</h3>
        <div class="weather-info">
            <div class="weather-icon" id="weather-icon"><img src="assets/sun.png" alt="Sun" style="width: 24px; height: 24px;"></div>
            <div id="weather-condition">Sunny</div>
            <div id="temperature">22Â°C</div>
        </div>
        <div style="font-size: 7px; color: #7f8c8d; margin: 2px 0; text-align: center;">
            <span id="weather-location">Getting location...</span>
        </div>
        <div style="font-size: 6px; color: #95a5a6; margin: 2px 0; text-align: center; font-style: italic;">
            <span id="weather-description">clear sky</span>
        </div>
        <div class="resource-item">
            <span><span class="water-icon water-icon-small"></span> Humidity:</span>
            <span id="humidity">65%</span>
        </div>
        <div class="resource-item">
            <span>ðŸ’¨ Wind:</span>
            <span id="wind-speed">0 km/h</span>
        </div>
        <div class="resource-item">
            <span>ðŸ“Š Pressure:</span>
            <span id="pressure">1013 hPa</span>
        </div>
        <div class="resource-item">
            <span>ðŸ‘ï¸ Visibility:</span>
            <span id="visibility">10 km</span>
        </div>
        <div class="resource-item">
            <span>ðŸ­ Pollution:</span>
            <span id="pollution">Low</span>
        </div>
        <div class="resource-item">
            <span>ðŸŒ± Soil Quality:</span>
            <span id="soil-quality">Rich</span>
        </div>
        <button onclick="requestLocationWeather()" 
                style="width: 100%; margin-top: 5px; padding: 3px; font-size: 7px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;"
                id="location-weather-btn">
            ðŸŒ Enable Live Weather
        </button>
        
        <!-- Weather Effects Tester -->
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #34495e;">
            <div style="font-size: 8px; font-weight: bold; margin-bottom: 5px; text-align: center; color: #f39c12;">ðŸ§ª Weather Effects Tester</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2px;">
                <button onclick="testWeatherEffect('Sunny')" 
                        onmouseover="showWeatherEffectInfo('Sunny')"
                        style="padding: 2px; font-size: 6px; background: #f39c12; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    â˜€ï¸ Sunny
                </button>
                <button onclick="testWeatherEffect('Rain')" 
                        onmouseover="showWeatherEffectInfo('Rain')"
                        style="padding: 2px; font-size: 6px; background: #3498db; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    ðŸŒ§ï¸ Rain
                </button>
                <button onclick="testWeatherEffect('Heavy Rain')" 
                        onmouseover="showWeatherEffectInfo('Heavy Rain')"
                        style="padding: 2px; font-size: 6px; background: #2980b9; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    â›ˆï¸ Heavy
                </button>
                <button onclick="testWeatherEffect('Light Rain')" 
                        onmouseover="showWeatherEffectInfo('Light Rain')"
                        style="padding: 2px; font-size: 6px; background: #5dade2; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    ðŸŒ¦ï¸ Light
                </button>
                <button onclick="testWeatherEffect('Snow')" 
                        onmouseover="showWeatherEffectInfo('Snow')"
                        style="padding: 2px; font-size: 6px; background: #ecf0f1; color: #2c3e50; border: none; border-radius: 2px; cursor: pointer;">
                    â„ï¸ Snow
                </button>
                <button onclick="testWeatherEffect('Cloudy')" 
                        onmouseover="showWeatherEffectInfo('Cloudy')"
                        style="padding: 2px; font-size: 6px; background: #95a5a6; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    â˜ï¸ Cloudy
                </button>
                <button onclick="testWeatherEffect('Foggy')" 
                        onmouseover="showWeatherEffectInfo('Foggy')"
                        style="padding: 2px; font-size: 6px; background: #bdc3c7; color: #2c3e50; border: none; border-radius: 2px; cursor: pointer;">
                    ðŸŒ«ï¸ Foggy
                </button>
                <button onclick="clearWeatherEffects()" 
                        style="padding: 2px; font-size: 6px; background: #e74c3c; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    ðŸš« Clear
                </button>
            </div>
            <div style="font-size: 5px; color: #7f8c8d; text-align: center; margin-top: 3px;">
                Click to test â€¢ Hover for details
            </div>
            <div style="margin-top: 4px;">
                <button onclick="runWeatherDemo()" 
                        style="width: 100%; padding: 3px; font-size: 6px; background: #9b59b6; color: white; border: none; border-radius: 2px; cursor: pointer;">
                    ðŸŽ¬ Auto Demo (All Effects)
                </button>
            </div>
        </div>
    </div>
    
    <!-- Plant Status Panel -->
    <div id="plant-status-panel" class="ui-panel" style="top: 180px; right: 10px; width: 150px; display: none;">
        <h3>ðŸŒ± Plant Status</h3>
        <div id="plant-status-list">
            <div style="text-align: center; color: #95a5a6; font-size: 8px;">
                No crops planted yet
            </div>
        </div>
    </div>
    
    <!-- Enhanced Inventory Panel -->
            <div id="inventory-panel" class="ui-panel" style="top: 320px; left: 10px; width: 180px;">
        <h3>ðŸ“¦ Inventory</h3>
        
        <div class="inventory-section">
            <h4>Seeds</h4>
            <div class="inventory-item clickable-item" onclick="selectItem('apple-seeds')" id="item-apple-seeds">
                <span>ðŸŒ° Apple Seeds:</span>
                <span id="inv-apple-seeds">8</span>
                <span class="selected-indicator" style="display: none;">âœ“</span>
            </div>
            <div class="inventory-item clickable-item" onclick="selectItem('carrot-seeds')" id="item-carrot-seeds">
                <span>ðŸ¥• Carrot Seeds:</span>
                <span id="inv-carrot-seeds">5</span>
                <span class="selected-indicator" style="display: none;">âœ“</span>
            </div>
        </div>
        
        <div class="inventory-section">
            <h4>ðŸ§° Active Tools</h4>
            <div class="tool-buttons-container">
                <button class="tool-button" onclick="selectTool('watering_can')" id="tool-watering-can">
                    ðŸª£ Watering Can <span id="tool-watering-count">1</span>
                </button>
                <button class="tool-button" onclick="selectTool('pesticide')" id="tool-pesticide">
                    ðŸ§ª Pesticide <span id="tool-pesticide-count">0</span>
                </button>
                <button class="tool-button" onclick="selectTool('solar_lamp')" id="tool-solar-lamp">
                    <img src="assets/sun.png" alt="Solar Lamp" style="width: 16px; height: 16px; vertical-align: middle;"> Solar Lamp <span id="tool-solar-count">0</span>
                </button>
                <button class="tool-button" onclick="selectTool('shovel')" id="tool-shovel">
                    ðŸ—¡ï¸ Shovel <span id="tool-shovel-count">1</span>
                </button>
            </div>
            <div class="tool-info">
                <p style="font-size: 8px; margin: 5px 0;">
                    <strong>Selected:</strong> <span id="selected-tool-display">None</span>
                </p>
                <p style="font-size: 7px; margin: 0; color: #777;">
                    Click tool, then click crop to use<br/>
                    Shovel: Select + left-click to dig up trees
                </p>
            </div>
        </div>
        
        <div class="inventory-section">
            <h4>Items & Equipment</h4>
            <div class="inventory-item clickable-item" onclick="selectItem('sprinkler')" id="item-sprinkler">
                <span><span class="water-icon water-icon-small"></span> Sprinklers:</span>
                <span id="inv-sprinklers">0</span>
                <span class="selected-indicator" style="display: none;">âœ“</span>
            </div>
            <div class="inventory-item clickable-item" onclick="selectItem('greenhouse')" id="item-greenhouse">
                <span>ðŸ  Greenhouses:</span>
                <span id="inv-greenhouses">0</span>
                <span class="selected-indicator" style="display: none;">âœ“</span>
            </div>
            <div class="inventory-item clickable-item" onclick="selectItem('chicken')" id="item-chicken">
                <span>ðŸ“ Chickens:</span>
                <span id="inv-animals">0</span>
                <span class="selected-indicator" style="display: none;">âœ“</span>
            </div>
        </div>
        
        <div class="inventory-section">
            <h4>Harvested Fruits</h4>
            <div class="inventory-item">
                <span><span class="apple-icon"></span> Apples:</span>
                <span id="inv-harvested-apples">0</span>
            </div>
            <div class="inventory-item">
                <span>ðŸ¥• Carrots:</span>
                <span id="inv-harvested-carrots">0</span>
            </div>
        </div>
    </div>
    
    <!-- Shop Panel -->
    <div id="shop-panel" class="ui-panel" style="bottom: 10px; right: 10px; width: 200px; height: 360px;">
                        <h3>ðŸ›’ Garden Shop</h3>
        
        <div class="shop-category">
            <h4>Seeds</h4>
            <button class="shop-button" onclick="buyItem('apple-seeds', 15, 3)">ðŸŒ° Apple Seeds x3 (15<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
            <button class="shop-button" onclick="buyItem('carrot-seeds', 10, 3)">ðŸ¥• Carrot Seeds x3 (10<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
        </div>
        
        <div class="shop-category">
            <h4>Tools & Equipment</h4>
            <button class="shop-button" onclick="buyItem('pesticide', 10, 3)">ðŸ§ª Pesticide x3 (10<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
            <button class="shop-button" onclick="buyItem('solar_lamp', 25, 1)"><img src="assets/sun.png" alt="Solar Lamp" style="width: 16px; height: 16px; vertical-align: middle;"> Solar Lamp (25<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
            <button class="shop-button" onclick="buyItem('sprinkler', 75, 1)"><span class="water-icon water-icon-small"></span> Sprinkler (75<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
            <button class="shop-button" onclick="buyItem('greenhouse', 200, 1)">ðŸ  Greenhouse (200<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
        </div>
        
        <div class="shop-category">
            <h4>Helpers</h4>
            <button class="shop-button" onclick="buyItem('animal', 100, 1)">ðŸ“ Chicken Helper (100<img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 2px;">)</button>
        </div>
    </div>
    
    <!-- Narrative Panel -->
    <div id="narrative-panel" class="ui-panel" style="top: 280px; left: 1000px;">
        <h3>ðŸ§™â€â™‚ï¸ Garden Spirit</h3>
        <div class="narrative-text" id="narrative-text">
            "Welcome to your new garden! The soil here is rich with ancient magic..."
        </div>
    </div>
    
    <!-- Soft Narrative Character -->
    <div class="narrative-character" id="narrative-character">
        <img src="assets/softnarrative.png" alt="Narrative Character" id="character-image">
    </div>
    
    <!-- Speech Bubble -->
    <div class="speech-bubble" id="speech-bubble">
        <div id="speech-text"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // =============================================================================
        // APPLE ICON HELPER FUNCTION
        // =============================================================================
        
        function getAppleIconHTML(size = '') {
            const sizeClass = size ? ` apple-icon-${size}` : '';
            return `<span class="apple-icon${sizeClass}"></span>`;
        }
        
        // Apple image for canvas rendering
        let appleImage = null;
        
        // Water image for all water effects
        let waterImage = null;
        
        // For DOM elements, use HTML
        function getAppleIconForDOM(size = '') {
            return getAppleIconHTML(size);
        }
        
        // For canvas/P5.js, return special marker to indicate apple image should be used
        function getAppleIconForCanvas() {
            return 'APPLE_IMAGE';
        }
        
        // =============================================================================
        // WATER ICON HELPER FUNCTIONS
        // =============================================================================
        
        function getWaterIconHTML(size = '') {
            const sizeClass = size ? ` water-icon-${size}` : '';
            return `<span class="water-icon${sizeClass}"></span>`;
        }
        
        // For DOM elements, use HTML
        function getWaterIconForDOM(size = '') {
            return getWaterIconHTML(size);
        }
        
        // For canvas/P5.js, return special marker to indicate water image should be used
        function getWaterIconForCanvas() {
            return 'WATER_IMAGE';
        }
        
        // =============================================================================
        // GAME CONFIGURATION
        // =============================================================================
        
        const CONFIG = {
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
                                GRID_WIDTH: 6,
            GRID_HEIGHT: 5,
            BASE_TILE_WIDTH: 128,   // Original tile size for scaling calculations
            BASE_TILE_HEIGHT: 64,  // Original tile height for scaling calculations
            TILE_WIDTH: 128,   // Dynamic tile size (will be updated by responsive scaling)
            TILE_HEIGHT: 64,  // Dynamic tile height (will be updated by responsive scaling)
            
            // Background image responsive scaling settings
            BACKGROUND_BASE_WIDTH: 1920,  // Assumed original background image width
            BACKGROUND_BASE_HEIGHT: 1080, // Assumed original background image height
            BACKGROUND_SCALE: 1.3, // Current background-size: 130%
            GROWTH_INTERVAL: 30000, // 30 seconds per stage
            WATER_INTERVAL: 60000, // 60 seconds before needing water (much more reasonable)
            WEATHER_API_KEY: '82b76cced925fdddfbe8866df6f66045', // From previous Growtopia
            
            // NEW: Enhanced weather and plant status system
            WEATHER_UPDATE_INTERVAL: 60000, // 1 minute
            PEST_CHANCE: 0.001, // 0.1% per update cycle (much less frequent)
            SICKNESS_THRESHOLD: 0.1, // Hours without care (much more reasonable)
            DEBUG_MODE: true, // Toggle for testing (TEMPORARILY ENABLED)
            
            // Tool effects
            TOOL_EFFECTS: {
                watering_can: { water: 100, cost: 0 },
                solar_lamp: { sunlight: 50, cost: 25 },
                pesticide: { pest_removal: true, cost: 10 },
                shovel: { dig_tree: true, cost: 0 }
            },
            
            // FOCUS MODE CONFIGURATION
            FOCUS_MODE: {
                DEFAULT_FOCUS_DURATION: 25, // minutes
                DEFAULT_BREAK_DURATION: 5, // minutes
                DEFAULT_LONG_BREAK_DURATION: 15, // minutes
                SESSIONS_BEFORE_LONG_BREAK: 4,
                            FOCUS_LEAF_COIN_REWARD: 100, // leaf coins per completed session
            COIN_REWARD: 25, // coins per completed session (legacy)
                XP_REWARD: 50, // XP per completed session
                PET_UNLOCK_SESSIONS: 10, // sessions needed to unlock first pet
                STREAK_BONUS_MULTIPLIER: 1.5 // bonus for maintaining streaks
            },
            
            // POMODORO TIMER CONFIGURATION
            POMODORO: {
                FOCUS_DURATION: 25, // minutes
                SHORT_BREAK_DURATION: 5, // minutes
                LONG_BREAK_DURATION: 15, // minutes
                SESSIONS_BEFORE_LONG_BREAK: 4,
                AUTO_START_BREAKS: true,
                AUTO_START_FOCUS: true,
                NOTIFICATION_ENABLED: true
            }
        };
        
        // =============================================================================
        // GAME STATE
        // =============================================================================
        
        let gameState = {
            // NEW: Tab system state
            currentTab: 'garden',
            // Core game data
            grid: [],
            coins: 150,
            appleSeeds: 8,
            carrotSeeds: 5,
            harvested: 0,
            gardenLevel: 1,
            
            // Inventory
            wateringCans: 1,
            sprinklers: 0,
            greenhouses: 0,
            animals: 0,
            
            // NEW: Tool inventory and selection
            tools: {
                watering_can: 1,  // Active by default
                solar_lamp: 0,    // Must be purchased
                pesticide: 0,     // Must be purchased
                shovel: 1         // Active by default
            },
            selectedTool: null, // Currently selected tool
            
            // Interaction
            selectedTile: null,
            showPlantMenu: false,
            plantMenuPos: { x: 0, y: 0 },
            
            // Environment - Enhanced weather system
            weather: {
                condition: 'Sunny', // Rain, Sunny, Cloudy, Snow
                temperature: 22,
                humidity: 65,
                pollution: 'Low',
                soilQuality: 'Rich',
                icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">',
                lastApiUpdate: 0
            },
            
            // Game flow
            gameStarted: false,
            lastWeatherUpdate: 0,
            lastNarrativeUpdate: 0,
            
            // Tools placed on grid
            placedSprinklers: [],
            placedGreenhouses: [],
            animalHelpers: [],
            
            // NEW: Loaded tool/weather assets
            toolAssets: {},
            weatherAssets: {},
            
            // FOCUS MODE STATE
            focusMode: {
                isActive: false,
                isInSession: false,
                currentPhase: 'focus', // 'focus', 'break', 'long_break'
                timer: {
                    isRunning: false,
                    isPaused: false,
                    startTime: 0,
                    pauseTime: 0,
                    totalPausedTime: 0,
                    duration: CONFIG.FOCUS_MODE.DEFAULT_FOCUS_DURATION * 60 * 1000, // in milliseconds
                    remaining: CONFIG.FOCUS_MODE.DEFAULT_FOCUS_DURATION * 60 * 1000
                },
                settings: {
                    focusDuration: CONFIG.FOCUS_MODE.DEFAULT_FOCUS_DURATION,
                    breakDuration: CONFIG.FOCUS_MODE.DEFAULT_BREAK_DURATION,
                    longBreakDuration: CONFIG.FOCUS_MODE.DEFAULT_LONG_BREAK_DURATION
                },
                stats: {
                    totalSessions: 0,
                    totalFocusTime: 0, // in minutes
                    currentStreak: 0,
                    longestStreak: 0,
                    lastSessionDate: null,
                    streakDates: [], // Array of dates with completed sessions
                    lastStreakRewardDate: null // NEW: Track when last streak reward was given
                },
                rewards: {
                    sessionLeafCoins: 0, // Leaf coins earned in current focus session
                    unlockedPets: [],
                    petAccessories: []
                },
                music: {
                    currentTrack: 'none',
                    isPlaying: false
                },
                pets: {
                    currentPet: null,
                    unlockedPets: ['dog', 'cat', 'rabbit'],
                    accessories: ['hat', 'glasses', 'scarf'],
                    equippedAccessories: {}
                }
            },
            
            // POMODORO TIMER STATE (replacing old focus timer)
            pomodoro: {
                isActive: false,
                isRunning: false,
                isPaused: false,
                currentPhase: 'focus', // 'focus', 'short_break', 'long_break'
                currentSession: 1,
                completedSessions: 0,
                totalCycles: 4, // User-adjustable (1-8)
                timer: {
                    startTime: 0,
                    interval: null,
                    duration: CONFIG.POMODORO.FOCUS_DURATION * 60 * 1000, // in milliseconds
                    remaining: CONFIG.POMODORO.FOCUS_DURATION * 60 * 1000,
                    lastUpdate: 0
                },
                settings: {
                    focusDuration: CONFIG.POMODORO.FOCUS_DURATION,
                    shortBreakDuration: CONFIG.POMODORO.SHORT_BREAK_DURATION,
                    longBreakDuration: CONFIG.POMODORO.LONG_BREAK_DURATION,
                    autoStartBreaks: CONFIG.POMODORO.AUTO_START_BREAKS,
                    autoStartFocus: CONFIG.POMODORO.AUTO_START_FOCUS
                }
            }
        };
        
        // =============================================================================
        // FOCUS MODE VISUAL EFFECTS SYSTEM
        // =============================================================================
        
        // Focus Mode Visual Effects Manager
        const FocusModeVisuals = {
            isActive: false,
            currentPhase: 'day',
            startTime: 0,
            totalDuration: 0,
            particles: [],
            fireflies: [],
            
            // Initialize visual effects
            init() {
                this.createParticles();
                this.createFireflies();
            },
            
            // Start focus mode visual effects
            start(duration) {
                this.isActive = true;
                this.startTime = Date.now();
                this.totalDuration = duration;
                this.currentPhase = 'day';
                
                // Show visual elements with layered approach
                const overlay = document.getElementById('focus-mode-overlay');
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                
                document.getElementById('focus-mode-badge').classList.add('active');
                document.getElementById('focus-mode-progress').style.display = 'block';
                document.getElementById('ui-dim-overlay').classList.add('active');
                
                // Start background transition
                this.updateBackground();
                
                console.log('ðŸŒ… Focus Mode Visual Effects Started');
            },
            
            // Stop focus mode visual effects
            stop() {
                this.isActive = false;
                
                // Hide visual elements with smooth transition
                const overlay = document.getElementById('focus-mode-overlay');
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 800);
                
                document.getElementById('focus-mode-badge').classList.remove('active');
                document.getElementById('focus-mode-progress').style.display = 'none';
                document.getElementById('ui-dim-overlay').classList.remove('active');
                
                // Reset background to day
                const background = document.getElementById('focus-mode-background');
                background.className = 'focus-mode-background day';
                
                // Reset progress
                document.getElementById('focus-mode-progress-bar').style.width = '0%';
                
                console.log('ðŸŒ… Focus Mode Visual Effects Stopped');
            },
            
            // Update visual effects (called every frame)
            update() {
                if (!this.isActive) return;
                
                const elapsed = Date.now() - this.startTime;
                const progress = Math.min(elapsed / this.totalDuration, 1);
                
                // Update progress bar
                document.getElementById('focus-mode-progress-bar').style.width = (progress * 100) + '%';
                
                // Update background based on progress
                this.updateBackgroundPhase(progress);
                
                // Update particles
                this.updateParticles();
            },
            
            // Update background phase based on progress
            updateBackgroundPhase(progress) {
                const background = document.getElementById('focus-mode-background');
                let newPhase = 'day';
                
                if (progress < 0.25) {
                    newPhase = 'day';
                } else if (progress < 0.5) {
                    newPhase = 'sunset';
                } else if (progress < 0.75) {
                    newPhase = 'dusk';
                } else {
                    newPhase = 'night';
                }
                
                if (newPhase !== this.currentPhase) {
                    this.currentPhase = newPhase;
                    background.className = `focus-mode-background ${newPhase}`;
                }
            },
            
            // Create floating particles
            createParticles() {
                const particlesContainer = document.getElementById('focus-mode-particles');
                
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 6 + 's';
                    particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                    particlesContainer.appendChild(particle);
                    this.particles.push(particle);
                }
            },
            
            // Create fireflies
            createFireflies() {
                const particlesContainer = document.getElementById('focus-mode-particles');
                
                for (let i = 0; i < 4; i++) {
                    const firefly = document.createElement('div');
                    firefly.className = 'firefly';
                    firefly.style.left = Math.random() * 100 + '%';
                    firefly.style.top = Math.random() * 100 + '%';
                    firefly.style.animationDelay = Math.random() * 8 + 's';
                    firefly.style.animationDuration = (6 + Math.random() * 4) + 's';
                    particlesContainer.appendChild(firefly);
                    this.fireflies.push(firefly);
                }
            },
            
            // Update particle positions
            updateParticles() {
                // Particles are animated via CSS, but we can add additional effects here
                this.particles.forEach((particle, index) => {
                    // Add subtle swaying effect
                    const time = Date.now() * 0.001;
                    const sway = Math.sin(time + index) * 2;
                    particle.style.transform = `translateX(${sway}px)`;
                });
            }
        };
        
        // =============================================================================
        // FLOATING TIMER WIDGET FUNCTIONS
        // =============================================================================
        
        function showFloatingTimer() {
            const widget = document.getElementById('floating-timer-widget');
            widget.classList.add('active');
        }
        
        function hideFloatingTimer() {
            const widget = document.getElementById('floating-timer-widget');
            widget.classList.remove('active');
        }
        
        function updateFocusModeButton() {
            const button = document.getElementById('focus-mode-button');
            console.log('ðŸ”„ Updating Focus Mode button. State:', gameState.focusMode.isActive);
            
            if (button) {
                if (gameState.focusMode.isActive) {
                    button.innerHTML = 'ðŸŽ¯ Focus Mode ON';
                    button.classList.add('active');
                    console.log('ðŸ”„ Button set to ON state');
                } else {
                    button.innerHTML = 'ðŸŽ¯ Focus Mode';
                    button.classList.remove('active');
                    console.log('ðŸ”„ Button set to OFF state');
                }
            } else {
                console.log('âŒ Focus Mode button not found!');
            }
        }
        
        // Apply Focus Mode visual effects (DISABLED - keeping UI clean)
        function applyFocusModeVisuals(enable) {
            // Visual effects disabled per user request
            // Focus Mode now only changes panels and background, no blurring or zoom effects
            console.log(`ðŸŽ¯ Focus Mode visual effects disabled (enable: ${enable})`);
        }
        
        // Create sparkle effects
        function createSparkles() {
            const sparkleContainer = document.getElementById('focus-mode-sparkles');
            if (sparkleContainer) {
                sparkleContainer.innerHTML = '';
                
                for (let i = 0; i < 12; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    sparkle.style.left = Math.random() * 100 + '%';
                    sparkle.style.animationDelay = Math.random() * 3 + 's';
                    sparkleContainer.appendChild(sparkle);
                }
            }
        }
        
        // Remove sparkle effects
        function removeSparkles() {
            const sparkleContainer = document.getElementById('focus-mode-sparkles');
            if (sparkleContainer) {
                sparkleContainer.innerHTML = '';
            }
        }
        
        // =============================================================================
        // FOCUS MODE TAB FUNCTIONS
        // =============================================================================
        
        function switchToGarden() {
            // Update tab buttons
            document.getElementById('focus-tab-garden').classList.add('active');
            document.getElementById('focus-tab-focus').classList.remove('active');
            
            // Hide focus tab content
            document.getElementById('focus-tab-content').classList.remove('active');
            
            // Hide back button
            document.getElementById('back-to-game-button').style.display = 'none';
            
            // Show game container
            document.getElementById('game-container').style.display = 'block';
        }
        
        function switchToFocus() {
            // Update tab buttons
            document.getElementById('focus-tab-garden').classList.remove('active');
            document.getElementById('focus-tab-focus').classList.add('active');
            
            // Show focus tab content
            document.getElementById('focus-tab-content').classList.add('active');
            
            // Show back button
            document.getElementById('back-to-game-button').style.display = 'block';
            
            // Hide game container
            document.getElementById('game-container').style.display = 'none';
            
            // Update focus tab UI
            updateFocusTab();
        }
        
        function updateFocusTab() {
            // Update focus mode UI elements
            document.getElementById('focus-timer-display').textContent = formatTime(gameState.focusMode.timer.remaining);
            document.getElementById('focus-timer-phase').textContent = gameState.focusMode.currentPhase === 'focus' ? 'Focus Session' : 'Break Time';
            document.getElementById('focus-streak-display').textContent = gameState.focusMode.stats.currentStreak + ' Days';
            document.getElementById('focus-total-sessions').textContent = gameState.focusMode.stats.totalSessions;
            document.getElementById('focus-total-focus-time').textContent = Math.floor(gameState.focusMode.stats.totalFocusTime / 60) + 'h';
            document.getElementById('focus-current-streak').textContent = gameState.focusMode.stats.currentStreak;
            
            // Update music selection
            updateMusicSelection();
            
            // Update streak calendar
            generateStreakCalendar();
        }
        
        function formatTime(milliseconds) {
            const minutes = Math.floor(milliseconds / 60000);
            const seconds = Math.floor((milliseconds % 60000) / 1000);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Update music selection UI
        function updateMusicSelection() {
            const musicOptions = ['lofi', 'rain', 'fireplace', 'forest', 'none'];
            musicOptions.forEach(option => {
                const element = document.getElementById('music-' + option);
                if (element) {
                    if (gameState.focusMode.music.currentTrack === option) {
                        element.classList.add('active');
                    } else {
                        element.classList.remove('active');
                    }
                }
            });
        }
        
        const PRICES = {
            'apple-seeds': 15,
            'carrot-seeds': 10,
            'sprinkler': 75,
            'greenhouse': 200,
            'animal': 100
        };
        
        const HARVEST_REWARDS = {
            apple: 25,
            carrot: 15
        };
        
        const NARRATIVE_MESSAGES = [
            "The morning dew makes crops grow faster...",
            "Your chickens are keeping the pests away!",
            "The soil here has ancient gardening magic...",
            "Rain clouds are gathering - perfect for crops!",
            "Your garden is becoming the talk of the village!",
            "The sprinklers are working beautifully today.",
            "Plant diversity makes the ecosystem stronger!",
            "Your green thumb is truly magical!",
            "The harvest moon brings good fortune...",
            "Wildlife is returning to your healthy garden!"
        ];
        
        // =============================================================================
        // ENHANCED CROP CLASS
        // =============================================================================
        
        class Crop {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.stage = 0; // Growth stages 0-4 (5 total stages)
                this.maxStage = 4; // Stage 4 = fully grown (stage 5 PNG)
                this.plantTime = Date.now();
                this.lastGrowthTime = Date.now();
                this.lastWaterTime = Date.now();
                this.lastCareTime = Date.now();
                this.isReady = false;
                this.health = 100;
                this.needsWater = false;
                this.isProtected = false; // By animal helpers
                this.growthInterval = CONFIG.GROWTH_INTERVAL; // Use CONFIG value (5 seconds per stage)
                
                // NEW: Enhanced plant status system
                this.waterLevel = 100; // 0-100
                this.sunlightLevel = 50; // 0-100, affected by weather and solar lamps
                this.hasPests = false;
                this.needsSunlight = false;
                this.isSick = false;
                this.isDead = false;
                this.lastPestCheck = Date.now();
                this.statusEmoji = null; // Current status emoji to display
                this.tintColor = 'healthy'; // healthy, attention, sick, dead
                
                // NEW: Plant condition system - 50% get conditions, 50% grow automatically
                this.plantId = `${this.x}-${this.y}`;
                this.hash = this.simpleHash(this.plantId);
                this.canGetConditions = (this.hash % 100) < 50; // Only 50% of plants can get conditions
                this.currentCondition = null; // null, 'water', 'sunlight', 'pests'
                this.conditionStartTime = null;
                this.conditionIcon = null; // Icon to display for current condition
                this.hasYellowTint = false; // Visual indicator for sick plants
                
                // ENHANCED: Plant Health & Environmental Maintenance System
                this.lastWatered = Date.now(); // Timestamp for water tracking
                this.lastSunlight = Date.now(); // Timestamp for sunlight tracking
                this.status = 'healthy'; // 'healthy' | 'warning' | 'sick' | 'dead'
                this.visualEffects = {
                    flashIntensity: 0,
                    shakeIntensity: 0,
                    desaturation: 0
                };
                
                // NEW: Apple regeneration system
                this.applesAvailable = false; // Whether apples are ready to harvest
                this.lastHarvestTime = null; // When apples were last harvested
                this.appleRegenTime = 10 * 60 * 1000; // 10 minutes in milliseconds
                this.fruitReadyTime = null; // When fruit first became ready for harvest
                this.fruitHarvestTimeout = 5 * 60 * 1000; // 5 minutes to harvest before tree dies
                
                console.log(`ðŸŒ± NEW CROP: Planted ${this.type} at (${this.x}, ${this.y}) - Starting healthy, canGetConditions: ${this.canGetConditions}`);
            }
            
            update() {
                const now = Date.now();
                
                // NEW: Update water level over time (for display purposes only)
                const timeSinceWater = now - this.lastWaterTime;
                this.waterLevel = Math.max(0, 100 - (timeSinceWater / CONFIG.WATER_INTERVAL) * 100);
                
                // IMPORTANT: Do NOT automatically set needsWater based on waterLevel
                // Only plants with water conditions should need water
                
                // NEW: Simplified condition system - only check for conditions if plant can get them
                if (this.canGetConditions && !this.isDead) {
                    this.checkForRandomConditions(now);
                }
                
                // NEW: Check for death from untreated conditions
                this.checkForDeath(now);
                
                // NEW: Check for death from unharvested fruit
                this.checkFruitHarvestTimeout(now);
                
                // NEW: Enhanced condition system - pause growth when conditions are not met
                this.isGrowthPaused = this.currentCondition !== null;
                
                // IMPORTANT: Clear needsWater if plant doesn't have water condition
                if (this.currentCondition !== 'water') {
                    this.needsWater = false;
                }
                
                // IMPORTANT: Clear needsSunlight if plant doesn't have sunlight condition
                if (this.currentCondition !== 'sunlight') {
                    this.needsSunlight = false;
                }
                
                // IMPORTANT: Clear hasPests if plant doesn't have pest condition
                if (this.currentCondition !== 'pests') {
                    this.hasPests = false;
                }
                
                // ENHANCED: Plant Health & Environmental Maintenance
                this.checkPlantHealth(now);
                this.updatePlantVisuals();
                
                // NEW: Update sunlight based on weather
                this.updateSunlightLevel();
                
                // NEW: Apple regeneration system
                if (this.type === 'apple' && this.stage === this.maxStage && this.lastHarvestTime) {
                    const timeSinceHarvest = now - this.lastHarvestTime;
                    if (timeSinceHarvest >= this.appleRegenTime && !this.applesAvailable) {
                        this.applesAvailable = true;
                        this.fruitReadyTime = now; // Start the 5-minute harvest countdown
                        console.log(`ðŸŽ Apples regenerated on tree at (${this.x}, ${this.y})`);
                        showPurchaseNotification(`ðŸŽ Apples are ready to harvest again!`);
                    }
                }
                
                // NEW: Determine current status emoji and tint
                this.updateStatus();
                
                // Check for sprinkler auto-watering (only if plant has water condition)
                if (this.currentCondition === 'water') {
                    this.checkSprinklerCoverage();
                }
                
                // Check for pollution effects (minimal impact)
                this.applyEnvironmentalEffects();
                
                // Apple Tree Growth Logic - 4 seconds per stage
                // NEW: Growth affected by overall plant health and conditions
                const growthModifier = this.calculateGrowthModifier();
                const adjustedGrowthInterval = this.growthInterval / growthModifier;
                
                // DETAILED DEBUG LOGGING
                if (CONFIG.DEBUG_MODE && this.stage < this.maxStage) {
                    const timeLeft = adjustedGrowthInterval - (now - this.lastGrowthTime);
                    const canGrow = this.health > 30 && !this.isGrowthPaused;
                    
                    // Log every 2 seconds to avoid spam
                    if (Math.floor(timeLeft / 2000) !== Math.floor((timeLeft + 100) / 2000)) {
                        console.log(`ðŸ› DEBUG ${this.type}(${this.x},${this.y}): stage=${this.stage}, timeLeft=${Math.ceil(timeLeft/1000)}s, health=${this.health}, condition=${this.currentCondition}, paused=${this.isGrowthPaused}, canGrow=${canGrow}, modifier=${growthModifier.toFixed(2)}, interval=${this.growthInterval}ms`);
                    }
                }
                
                // NEW: Only grow if not paused by conditions and not dead
                if (this.stage < this.maxStage && 
                    now - this.lastGrowthTime > adjustedGrowthInterval &&
                    this.health > 30 && !this.isGrowthPaused && !this.isDead) {
                    
                    const oldStage = this.stage;
                    this.stage++;
                    this.lastGrowthTime = now;
                    
                                        // Debug logging
                    console.log(`ðŸŒ± GROWTH: ${this.type} at (${this.x}, ${this.y}) grew from stage ${oldStage + 1} to ${this.stage + 1} (PNG: apple_stage_0${this.stage + 1}.png)`);
                    
                                    if (this.stage === this.maxStage) {
                    this.isReady = true;
                    // NEW: When apple tree reaches full maturity, apples become available
                    if (this.type === 'apple') {
                        this.applesAvailable = true;
                        this.fruitReadyTime = now; // Start the 5-minute harvest countdown
                    }
                                                        this.statusEmoji = getAppleIconForCanvas();
                console.log(`ðŸŽ ${this.type} at (${this.x}, ${this.y}) is fully grown! (Stage ${this.stage + 1})`);
                showPurchaseNotification(`${getAppleIconForDOM('small')} Apple tree fully grown!`);
                } else {
                    console.log(`ðŸŒ¿ ${this.type} at (${this.x}, ${this.y}) grew to stage ${this.stage + 1}`);
                    showPurchaseNotification(`ðŸŒ¿ Apple tree grew to stage ${this.stage + 1}!`);
                }
                }
            }
            
            checkSprinklerCoverage() {
                for (let sprinkler of gameState.placedSprinklers) {
                    const distance = Math.abs(this.x - sprinkler.x) + Math.abs(this.y - sprinkler.y);
                    if (distance <= 2) { // Sprinkler range
                        this.water();
                        break;
                    }
                }
            }
            
            applyEnvironmentalEffects() {
                // Weather effects
                if (gameState.weather.condition === 'Rainy') {
                    this.water(); // Rain helps all plants
                }
                // REMOVED: Drought effect that was forcing water needs on all plants
                
                // REMOVED: Pollution effects that were reducing health
                // Only conditions should affect plant health, not environmental pollution
            }
            
            water() {
                this.needsWater = false;
                this.lastWaterTime = Date.now();
                this.waterLevel = 100;
                this.health = Math.min(100, this.health + 10);
                this.lastCareTime = Date.now();
                
                // NEW: Clear water condition if it was the current condition
                if (this.currentCondition === 'water') {
                    this.currentCondition = null;
                    this.conditionStartTime = null;
                    this.conditionIcon = null;
                    this.hasYellowTint = false; // Remove yellow tint
                    this.health = Math.min(100, this.health + 30); // Restore health when cured
                    console.log(`âœ… ${this.type} at (${this.x}, ${this.y}) water condition cured! Plant is healthy again.`);
                    showPurchaseNotification(`ðŸ’§ Plant watered! ${this.type} is healthy again!`);
                    
                    // NEW: Trigger healing animation
                    this.triggerHealingAnimation();
                }
                
                // ENHANCED: Update water tracking
                this.lastWatered = Date.now();
                this.waterPlant();
            }
            
            // NEW: Cure pests with pesticide
            curePests() {
                if (this.hasPests) {
                    const pestType = this.getStagePestType();
                    this.hasPests = false;
                    this.health = Math.min(100, this.health + 30); // Restore health when cured
                    this.lastCareTime = Date.now();
                    
                    // NEW: Clear pest condition if it was the current condition
                    if (this.currentCondition === 'pests') {
                        this.currentCondition = null;
                        this.conditionStartTime = null;
                        this.conditionIcon = null;
                        this.hasYellowTint = false; // Remove yellow tint
                        this.health = Math.min(100, this.health + 30); // Additional health restoration
                        console.log(`âœ… ${pestType} cured on ${this.type} at (${this.x}, ${this.y}) with pesticide! Plant is healthy again.`);
                        showPurchaseNotification(`âœ… ${pestType} cured! ${this.type} is healthy again!`);
                        
                        // NEW: Trigger healing animation
                        this.triggerHealingAnimation();
                    }
                    return true; // Successfully cured
                }
                return false; // No pests to cure
            }
            
            // NEW: Enhanced plant status methods
            updateSunlightLevel() {
                const weather = gameState.weather.condition;
                let baseSunlight = 50;
                
                // Weather effects on sunlight
                switch(weather) {
                    case 'Sunny': baseSunlight = 100; break;
                    case 'Cloudy': baseSunlight = 30; break;
                    case 'Rain': baseSunlight = 20; break;
                    case 'Snow': baseSunlight = 10; break;
                }
                
                this.sunlightLevel = Math.min(100, baseSunlight);
                
                // REMOVED: Old sunlight check that was interfering with condition system
                // The new condition system handles sunlight needs automatically
            }
            
            // NEW: Check for random conditions during growth
            checkForRandomConditions(now) {
                // Only check if plant doesn't already have a condition
                if (this.currentCondition !== null) {
                    return;
                }
                
                // Check every 15 seconds for random conditions
                if (now - this.lastPestCheck > 15000) {
                    // Stage-specific condition chances
                    const stageConditionChances = this.getStageConditionChances();
                    const totalChance = stageConditionChances.total;
                    
                    if (Math.random() < totalChance) {
                        this.assignRandomCondition(now);
                    }
                    
                    this.lastPestCheck = now;
                }
            }
            
            // NEW: Get condition chances based on growth stage
            getStageConditionChances() {
                const chances = {
                    water: 0,
                    sunlight: 0,
                    pests: 0,
                    total: 0
                };
                
                // Stage 0-1 (Seed/Sprout): Water condition - early stages
                if (this.stage <= 1) {
                    chances.water = 0.10; // 10% chance per check (15 second intervals)
                }
                
                // Stage 2-3 (Small/Big Tree): Sunlight condition - mid stages  
                if (this.stage >= 2 && this.stage <= 3) {
                    chances.sunlight = 0.10; // 10% chance per check
                }
                
                // Any stage: Pest infestation - can happen anytime
                chances.pests = 0.10; // 10% chance per check
                
                // Calculate total chance
                chances.total = chances.water + chances.sunlight + chances.pests;
                
                return chances;
            }
            
            // NEW: Assign a random condition to the plant
            assignRandomCondition(now) {
                const stageChances = this.getStageConditionChances();
                const random = Math.random();
                let selectedCondition = null;
                
                // Determine which condition based on weighted chances
                if (random < stageChances.water) {
                    selectedCondition = 'water';
                } else if (random < stageChances.water + stageChances.sunlight) {
                    selectedCondition = 'sunlight';
                } else if (random < stageChances.water + stageChances.sunlight + stageChances.pests) {
                    selectedCondition = 'pests';
                }
                
                if (selectedCondition) {
                    this.currentCondition = selectedCondition;
                    this.conditionStartTime = now;
                    this.hasYellowTint = true; // Apply yellow tint to sick plants
                    
                    switch(selectedCondition) {
                        case 'water':
                            this.needsWater = true;
                            this.conditionIcon = 'ðŸ’§'; // Water droplet icon
                            this.health = Math.max(50, this.health - 20);
                            console.log(`ðŸ’§ ${this.type} at (${this.x}, ${this.y}) needs water at stage ${this.stage + 1} (Seed/Sprout)`);
                            break;
                        case 'sunlight':
                            this.needsSunlight = true;
                            this.conditionIcon = 'â˜€ï¸'; // Sun icon (will be rendered as sun.png in UI)
                            this.health = Math.max(50, this.health - 15);
                            console.log(`â˜€ï¸ ${this.type} at (${this.x}, ${this.y}) needs sunlight at stage ${this.stage + 1} (Small/Big Tree)`);
                            break;
                        case 'pests':
                            this.hasPests = true;
                            this.conditionIcon = this.getPestEmoji(); // Bug icon based on stage
                            this.health = Math.max(50, this.health - 25);
                            const pestType = this.getStagePestType();
                            console.log(`ðŸ› ${pestType} infestation on ${this.type} at stage ${this.stage + 1}! (${this.x}, ${this.y})`);
                            break;
                    }
                }
            }
            
            // NEW: Get pest chance based on growth stage
            getStagePestChance() {
                const stageChances = {
                    0: 0.002, // Seed stage - very low chance
                    1: 0.003, // Sprout stage - low chance
                    2: 0.005, // Small plant - medium chance
                    3: 0.008, // Medium plant - higher chance
                    4: 0.010  // Mature plant - highest chance
                };
                return stageChances[this.stage] || 0.005;
            }
            
            // NEW: Get pest type based on growth stage
            getStagePestType() {
                const stagePests = {
                    0: 'Soil grubs',      // Seed stage
                    1: 'Root aphids',     // Sprout stage
                    2: 'Leaf miners',     // Small plant
                    3: 'Fruit flies',     // Medium plant
                    4: 'Apple maggots'    // Mature plant
                };
                return stagePests[this.stage] || 'General pests';
            }
            
            // Simple hash function to determine if plant can get pests
            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            // NEW: Check for death from untreated conditions (60-90 seconds)
            checkForDeath(now) {
                if (this.currentCondition !== null && this.conditionStartTime !== null) {
                    const timeInCondition = (now - this.conditionStartTime) / 1000; // seconds
                    const deathThreshold = 60 + Math.random() * 30; // Random 60-90 seconds
                    
                    if (timeInCondition > deathThreshold) {
                        this.isDead = true;
                        this.currentCondition = null;
                        this.conditionIcon = null;
                        this.hasYellowTint = false;
                        console.log(`ðŸ’€ ${this.type} at (${this.x}, ${this.y}) died from untreated condition after ${timeInCondition.toFixed(1)} seconds`);
                    }
                }
            }
            
            // NEW: Check for death from unharvested fruit (5 minutes)
            checkFruitHarvestTimeout(now) {
                if (this.type === 'apple' && this.applesAvailable && this.fruitReadyTime !== null && !this.isDead) {
                    const timeUnharvested = now - this.fruitReadyTime;
                    
                    if (timeUnharvested > this.fruitHarvestTimeout) {
                        this.isDead = true;
                        this.applesAvailable = false;
                        this.fruitReadyTime = null;
                        this.currentCondition = null;
                        this.conditionIcon = null;
                        this.hasYellowTint = false;
                        const minutesUnharvested = (timeUnharvested / 60000).toFixed(1);
                        console.log(`ðŸ’€ ${this.type} at (${this.x}, ${this.y}) died from unharvested fruit after ${minutesUnharvested} minutes`);
                        showPurchaseNotification(`ðŸ’€ Apple tree died! Fruit was left unharvested for ${minutesUnharvested} minutes!`);
                    }
                }
            }
            
            updateStatus() {
                // Priority order for status emoji
                if (this.isDead) {
                    this.statusEmoji = 'ðŸ’€';
                    this.tintColor = 'dead';
                } else if (this.isReady && this.type === 'apple' && this.applesAvailable) {
                    this.statusEmoji = getAppleIconForCanvas();
                    this.tintColor = 'healthy';
                } else if (this.isReady && this.type !== 'apple') {
                    this.statusEmoji = getAppleIconForCanvas(); // Keep original logic for non-apple crops
                    this.tintColor = 'healthy';
                } else if (this.currentCondition === 'pests') {
                    // NEW: Different pest emojis based on growth stage
                    this.statusEmoji = this.getPestEmoji();
                    this.tintColor = 'sick'; // Yellow tint for sick plants
                } else if (this.currentCondition === 'water') {
                    this.statusEmoji = getWaterIconForCanvas();
                    this.tintColor = 'sick'; // Yellow tint for sick plants
                } else if (this.currentCondition === 'sunlight') {
                    this.statusEmoji = 'â˜€ï¸'; // Will be rendered as sun.png
                    this.tintColor = 'sick'; // Yellow tint for sick plants
                } else {
                    this.statusEmoji = null;
                    this.tintColor = 'healthy'; // No tint for healthy plants
                }
            }
            
            // NEW: Get pest emoji based on growth stage
            getPestEmoji() {
                const stagePestEmojis = {
                    0: 'ðŸª±', // Soil grubs
                    1: 'ðŸ¦—', // Root aphids
                    2: 'ðŸ¦‹', // Leaf miners
                    3: 'ðŸª°', // Fruit flies
                    4: 'ðŸ›'  // Apple maggots
                };
                return stagePestEmojis[this.stage] || 'ðŸ›';
            }
            
            // NEW: Trigger healing animation
            triggerHealingAnimation() {
                // Create sparkle effect at plant location
                addHealingAnimation(this.x, this.y);
            }
            
            // NEW: Harvest apples without removing tree
            harvestApples() {
                if (this.type === 'apple' && this.stage === this.maxStage && this.applesAvailable) {
                    this.applesAvailable = false;
                    this.lastHarvestTime = Date.now();
                    this.fruitReadyTime = null; // Reset the harvest timeout
                    console.log(`ðŸŽ Harvested apples from tree at (${this.x}, ${this.y}) - will regenerate in 10 minutes`);
                    return true;
                }
                return false;
            }
            
            // NEW: Dig up tree with shovel
            digUpTree() {
                if (this.stage >= 0) { // Can dig up any tree at any stage
                    console.log(`ðŸ—¡ï¸ Dug up ${this.type} tree at (${this.x}, ${this.y}) with shovel (stage ${this.stage})`);
                    return true;
                }
                return false;
            }
            
            calculateGrowthModifier() {
                // SIMPLIFIED: Just use a basic modifier to avoid complications
                let modifier = 1.0;
                
                // Only apply weather effects if they're positive
                switch(gameState.weather.condition) {
                    case 'Sunny': modifier *= 1.1; break;
                    case 'Rain': modifier *= 1.05; break;
                    default: modifier *= 1.0; break;
                }
                
                return modifier;
            }
            
            // NEW: Tool usage methods
            useTool(toolType) {
                this.lastCareTime = Date.now();
                
                switch(toolType) {
                    case 'watering_can':
                        this.water();
                        return true;
                        
                    case 'pesticide':
                        return this.curePests(); // Use the new curePests method
                        
                    case 'solar_lamp':
                        this.needsSunlight = false;
                        this.sunlightLevel = Math.min(100, this.sunlightLevel + 50);
                        this.health = Math.min(100, this.health + 15);
                        this.lastCareTime = Date.now();
                        
                        // NEW: Clear sunlight condition if it was the current condition
                        if (this.currentCondition === 'sunlight') {
                            this.currentCondition = null;
                            this.conditionStartTime = null;
                            this.conditionIcon = null;
                            this.hasYellowTint = false; // Remove yellow tint
                            this.health = Math.min(100, this.health + 30); // Restore health when cured
                            console.log(`ðŸ’¡ Solar lamp applied to ${this.type} at (${this.x}, ${this.y}) - Plant is healthy again.`);
                            showPurchaseNotification(`ðŸ’¡ Sunlight restored! ${this.type} is healthy again!`);
                            
                            // NEW: Trigger healing animation
                            this.triggerHealingAnimation();
                        }
                        return true;
                        
                    case 'shovel':
                        // Shovel is handled in mousePressed function for special logic
                        return false;
                        
                    default:
                        return false;
                }
            }
            
            getColor() {
                if (this.health < 30) {
                    return color(139, 69, 19); // Brown for unhealthy
                }
                
                const colors = {
                    apple: [color(144, 238, 144), color(50, 205, 50), color(34, 139, 34), color(0, 100, 0), color(255, 0, 0)],
                    carrot: [color(144, 238, 144), color(50, 205, 50), color(255, 140, 0), color(255, 99, 71)]
                };
                return colors[this.type][this.stage] || colors[this.type][0];
            }
            
            getSize() {
                return 15 + this.stage * 5;
            }
            
            getStatusIcons() {
                let icons = [];
                if (this.needsWater) icons.push({ icon: getWaterIconForDOM('small'), class: 'needs-water' });
                if (this.health < 50) icons.push({ icon: 'ðŸš¨', class: 'unhealthy' });
                if (this.isReady) icons.push({ icon: 'âœ…', class: 'ready-harvest' });
                if (this.health >= 80 && !this.needsWater) icons.push({ icon: 'ðŸŒ¿', class: 'healthy' });
                return icons;
            }
            
            // =============================================================================
            // ENHANCED PLANT HEALTH & ENVIRONMENTAL MAINTENANCE SYSTEM
            // =============================================================================
            
            // NEW: Simplified plant health check - only for plants with conditions
            checkPlantHealth(now) {
                // Only apply health effects if plant has a current condition
                if (this.currentCondition !== null) {
                    const timeInCondition = (now - this.conditionStartTime) / 1000; // seconds
                    
                    // Gradual health loss while in condition (very slow)
                    if (timeInCondition > 30) { // After 30 seconds in condition
                        const healthLoss = (timeInCondition - 30) / 300; // 1 health per 5 minutes
                        this.health = Math.max(20, this.health - healthLoss);
                    }
                } else {
                    // IMPORTANT: Healthy plants should maintain full health
                    this.health = 100;
                }
                
                // Update status based on current condition
                if (this.isDead) {
                    this.status = 'dead';
                } else if (this.currentCondition !== null) {
                    this.status = 'sick';
                } else {
                    this.status = 'healthy';
                }
            }
            
            // NEW: Simplified visual effects based on plant status
            updatePlantVisuals() {
                const now = Date.now();
                
                switch (this.status) {
                    case 'healthy':
                        this.visualEffects.flashIntensity = 0;
                        this.visualEffects.shakeIntensity = 0;
                        this.visualEffects.desaturation = 0;
                        break;
                        
                    case 'sick':
                        // Gentle yellow flash for sick plants
                        this.visualEffects.flashIntensity = Math.sin(now / 500) * 0.3;
                        this.visualEffects.shakeIntensity = 0;
                        this.visualEffects.desaturation = 0;
                        break;
                        
                    case 'dead':
                        // Desaturated, no animation
                        this.visualEffects.flashIntensity = 0;
                        this.visualEffects.shakeIntensity = 0;
                        this.visualEffects.desaturation = 0.8;
                        break;
                }
            }
            
            // Water plant - resets water timer and restores health if alive
            waterPlant() {
                if (this.status !== 'dead') {
                    this.lastWatered = Date.now();
                    this.lastWaterTime = Date.now();
                    this.waterLevel = 100;
                    this.health = Math.min(100, this.health + 20);
                    
                    // Restore status only if ALL conditions are resolved
                    if (this.status === 'sick' && this.health > 50 && !this.hasPests && this.sunlightLevel >= 30 && this.waterLevel >= 30) {
                        this.status = 'healthy';
                    }
                    
                    console.log(`ðŸ’§ Plant at (${this.x}, ${this.y}) watered - Health: ${this.health.toFixed(1)}`);
                    return true;
                }
                return false;
            }
            
            // Give sunlight - resets sunlight timer
            giveSunlight() {
                this.lastSunlight = Date.now();
                this.sunlightLevel = Math.min(100, this.sunlightLevel + 30);
                this.health = Math.min(100, this.health + 5);
                
                // Restore status only if ALL conditions are resolved
                if (this.status === 'sick' && this.health > 50 && !this.hasPests && this.sunlightLevel >= 30 && this.waterLevel >= 30) {
                    this.status = 'healthy';
                }
                
                console.log(`â˜€ï¸ Plant at (${this.x}, ${this.y}) received sunlight - Level: ${this.sunlightLevel.toFixed(1)}`);
                return true;
            }
            

            
            // Treat pests - removes pest infestation and resumes normal growth
            treatPests() {
                if (this.hasPests) {
                    this.hasPests = false;
                    this.lastPestCheck = Date.now();
                    this.health = Math.min(100, this.health + 10);
                    
                    console.log(`ðŸ§½ Pests removed from plant at (${this.x}, ${this.y}) - growth can now resume`);
                    return true;
                }
                return false;
            }
            
            // Remove dead tree - clears the tile without rewards
            removeDeadTree() {
                if (this.status === 'dead') {
                    console.log(`ðŸ—‘ï¸ Dead tree removed from (${this.x}, ${this.y})`);
                    return true;
                }
                return false;
            }
            
            // Check if plant is clickable (dead plants are not)
            isClickable() {
                return this.status !== 'dead';
            }
            
            // Save plant health data for localStorage
            toSaveData() {
                return {
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    stage: this.stage,
                    plantTime: this.plantTime,
                    lastGrowthTime: this.lastGrowthTime,
                    lastWaterTime: this.lastWaterTime,
                    lastCareTime: this.lastCareTime,
                    isReady: this.isReady,
                    health: this.health,
                    needsWater: this.needsWater,
                    isProtected: this.isProtected,
                    waterLevel: this.waterLevel,
                    sunlightLevel: this.sunlightLevel,
                    hasPests: this.hasPests,
                    isSick: this.isSick,
                    lastPestCheck: this.lastPestCheck,
                    // ENHANCED: Save health system data
                    lastWatered: this.lastWatered,
                    lastSunlight: this.lastSunlight,
                    status: this.status,
                    // NEW: Apple regeneration system data
                    applesAvailable: this.applesAvailable,
                    lastHarvestTime: this.lastHarvestTime,
                    fruitReadyTime: this.fruitReadyTime
                };
            }
            
            // Load plant health data from localStorage
            fromSaveData(data) {
                this.type = data.type;
                this.x = data.x;
                this.y = data.y;
                this.stage = data.stage;
                this.plantTime = data.plantTime;
                this.lastGrowthTime = data.lastGrowthTime;
                this.lastWaterTime = data.lastWaterTime;
                this.lastCareTime = data.lastCareTime;
                this.isReady = data.isReady;
                this.health = data.health;
                this.needsWater = data.needsWater;
                this.isProtected = data.isProtected;
                this.waterLevel = data.waterLevel;
                this.sunlightLevel = data.sunlightLevel;
                this.hasPests = data.hasPests;
                this.isSick = data.isSick;
                this.lastPestCheck = data.lastPestCheck;
                
                // ENHANCED: Load health system data
                this.lastWatered = data.lastWatered || Date.now();
                this.lastSunlight = data.lastSunlight || Date.now();
                this.status = data.status || 'healthy';
                
                // NEW: Load apple regeneration system data
                this.applesAvailable = data.applesAvailable || false;
                this.lastHarvestTime = data.lastHarvestTime || null;
                this.fruitReadyTime = data.fruitReadyTime || null;
                
                // Calculate health consequences for time passed
                this.calculateHealthConsequences();
            }
            
            // Calculate health consequences for time passed since last save
            calculateHealthConsequences() {
                const now = Date.now();
                const timeSinceWatered = now - this.lastWatered;
                const waterThreshold = 2 * 60 * 1000; // 2 minutes
                
                if (timeSinceWatered > waterThreshold) {
                    const healthLoss = (timeSinceWatered - waterThreshold) / (1000 * 60);
                    this.health = Math.max(0, this.health - healthLoss);
                    
                    // Update status based on health
                    if (this.health <= 0) {
                        this.status = 'dead';
                    } else if (this.health < 20) {
                        this.status = 'sick';
                    } else if (this.health < 50) {
                        this.status = 'warning';
                    }
                    
                    console.log(`ðŸŒ± Plant at (${this.x}, ${this.y}) lost ${healthLoss.toFixed(1)} health during offline time`);
                }
            }
        }
        
        // =============================================================================
        // ENHANCED TILE CLASS
        // =============================================================================
        
        class Tile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.crop = null;
                this.type = 'grass';
                this.hasSprinkler = false;
                this.hasGreenhouse = false;
                this.fertility = 75 + Math.random() * 25; // Random fertility
            }
            
            plantCrop(cropType = 'apple') {
                const seedCount = gameState[cropType + 'Seeds'];
                
                // Only check if tile is empty and player has seeds (no coin deduction during planting)
                if (this.crop === null && seedCount > 0) {
                    this.crop = new Crop(cropType, this.x, this.y);
                    this.type = 'soil';
                    gameState[cropType + 'Seeds']--; // Use up one seed from inventory
                    
                    console.log(`âœ… Planted ${cropType} at (${this.x}, ${this.y})`);
                    showPurchaseNotification(`ðŸŒ± Planted ${cropType} tree!`);
                    
                    // Check for animal protection
                    this.crop.isProtected = this.checkAnimalProtection();
                    
                    updateAllUI();
                    // Updated notification - no coin deduction shown
                    showNotification(`ðŸŒ± Planted ${cropType} tree! Seeds remaining: ${gameState[cropType + 'Seeds']}`);
                    return true;
                } else if (this.crop !== null) {
                    showNotification(`âŒ Tile already has a crop!`);
                } else if (seedCount <= 0) {
                    showNotification(`âŒ No ${cropType} seeds! Buy more from the shop.`);
                }
                return false;
            }
            
            harvestCrop() {
                if (this.crop && this.crop.isReady) {
                    const reward = HARVEST_REWARDS[this.crop.type];
                    const cropType = this.crop.type;
                    
                    // NEW: Special handling for apple trees - don't remove them, just harvest apples
                    if (cropType === 'apple' && this.crop.stage === this.crop.maxStage) {
                        // For apple trees, use the apple harvesting system instead
                        return this.harvestApples();
                    }
                    
                    // Regular harvest logic for non-apple crops (removes the entire plant)
                    gameState.coins += reward;
                    gameState.harvested++;
                    
                    // Update harvested fruits inventory
                    if (cropType === 'apple') {
                        gameState.harvestedApples = (gameState.harvestedApples || 0) + 1;
                    } else if (cropType === 'carrot') {
                        gameState.harvestedCarrots = (gameState.harvestedCarrots || 0) + 1;
                    }
                    
                    // Level up logic
                    if (gameState.harvested % 10 === 0) {
                                        gameState.gardenLevel++;
                showPurchaseNotification(`ðŸŽ‰ Garden Level Up! Now level ${gameState.gardenLevel}!`);
                    }
                    
                    // Add coin animation
                    addCoinAnimation(this.x, this.y, reward);
                    
                    this.crop = null;
                    this.type = 'grass';
                    updateAllUI();
                    showPurchaseNotification(`âœ… Harvested ${cropType}! (+${reward} coins)`);
                    return true;
                }
                return false;
            }
            
            // NEW: Harvest apples without removing tree
            harvestApples() {
                if (this.crop && this.crop.type === 'apple' && this.crop.stage === this.crop.maxStage && this.crop.applesAvailable) {
                    const reward = HARVEST_REWARDS['apple'];
                    
                    // Harvest apples from the tree
                    if (this.crop.harvestApples()) {
                        // Update game state
                        gameState.coins += reward;
                        gameState.harvested++;
                        gameState.harvestedApples = (gameState.harvestedApples || 0) + 1;
                        
                        // Level up logic
                        if (gameState.harvested % 10 === 0) {
                            gameState.gardenLevel++;
                            showPurchaseNotification(`ðŸŽ‰ Garden Level Up! Now level ${gameState.gardenLevel}!`);
                        }
                        
                        // Add coin animation
                        addCoinAnimation(this.x, this.y, reward);
                        
                        updateAllUI();
                        showPurchaseNotification(`ðŸŽ Harvested apples! Tree remains (+${reward} coins)`);
                        return true;
                    }
                }
                return false;
            }
            
            // NEW: Dig up tree with shovel
            digUpTree() {
                if (this.crop) { // Can dig up any crop at any stage
                    const cropType = this.crop.type; // Store type before removing
                    if (this.crop.digUpTree()) {
                        // Add dig animation
                        addRemoveAnimation(this.x, this.y);
                        
                        // Remove the tree
                        this.crop = null;
                        this.type = 'grass';
                        
                        updateAllUI();
                        showPurchaseNotification(`ðŸ—¡ï¸ ${cropType} dug up! Plot is now empty.`);
                        return true;
                    }
                }
                return false;
            }
            
            checkAnimalProtection() {
                for (let animal of gameState.animalHelpers) {
                    const distance = Math.abs(this.x - animal.x) + Math.abs(this.y - animal.y);
                    if (distance <= 3) { // Animal protection range
                        return true;
                    }
                }
                return false;
            }
            
            update() {
                if (this.crop) {
                    this.crop.update();
                }
            }
        }
        
        // =============================================================================
        // WEATHER SYSTEM (Using API from previous Growtopia)
        // =============================================================================
        
        async function updateWeather() {
            try {
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=San Francisco&appid=${CONFIG.WEATHER_API_KEY}&units=metric`);
                const data = await response.json();
                
                // Map weather conditions
                const weatherMap = {
                    'clear sky': { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                    'few clouds': { condition: 'Partly Cloudy', icon: 'â›…' },
                    'scattered clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'broken clouds': { condition: 'Overcast', icon: 'â˜ï¸' },
                    'shower rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'thunderstorm': { condition: 'Stormy', icon: 'â›ˆï¸' },
                    'snow': { condition: 'Snowy', icon: 'â„ï¸' },
                    'mist': { condition: 'Foggy', icon: 'ðŸŒ«ï¸' }
                };
                
                const weather = weatherMap[data.weather[0].description] || { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' };
                
                gameState.weather = {
                    condition: weather.condition,
                    temperature: Math.round(data.main.temp),
                    humidity: data.main.humidity,
                    pollution: Math.random() > 0.7 ? 'High' : 'Low',
                    soilQuality: 'Rich',
                    icon: weather.icon
                };
                
                console.log('Weather updated from API:', gameState.weather);
            } catch (error) {
                console.log('Using simulated weather:', error);
                simulateWeather();
            }
            
            updateWeatherUI();
        }
        
        function simulateWeather() {
            const conditions = [
                { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                { condition: 'Partly Cloudy', icon: 'â›…' },
                { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                { condition: 'Cloudy', icon: 'â˜ï¸' },
                { condition: 'Drought', icon: 'ðŸŒµ' }
            ];
            
            const weather = conditions[Math.floor(Math.random() * conditions.length)];
            gameState.weather = {
                ...weather,
                temperature: Math.floor(Math.random() * 20) + 15,
                humidity: Math.floor(Math.random() * 40) + 40,
                pollution: Math.random() > 0.8 ? 'High' : 'Low',
                soilQuality: 'Rich',
                lastApiUpdate: Date.now()
            };
        }
        
        // =============================================================================
        // RESPONSIVE SCALING SYSTEM
        // =============================================================================
        
        let currentScaleFactor = 1;
        let gridOffsetX = 0;
        let gridOffsetY = 0;
        
        function calculateResponsiveScale() {
            // Get the current dimensions of the game container
            const container = document.getElementById('game-container');
            if (!container) {
                console.warn('âš ï¸ Game container not found, using default scale');
                return 1;
            }
            
            const containerWidth = container.offsetWidth || window.innerWidth;
            const containerHeight = container.offsetHeight || window.innerHeight;
            
            // Calculate the actual displayed size of the background image
            // background-size: 130% means the image is scaled to 130% of container size
            const backgroundDisplayWidth = containerWidth * CONFIG.BACKGROUND_SCALE;
            const backgroundDisplayHeight = containerHeight * CONFIG.BACKGROUND_SCALE;
            
            // Calculate scale factor relative to the original background image size
            const scaleX = backgroundDisplayWidth / CONFIG.BACKGROUND_BASE_WIDTH;
            const scaleY = backgroundDisplayHeight / CONFIG.BACKGROUND_BASE_HEIGHT;
            
            // Use the average of both scales for better alignment with isometric background
            const scaleFactor = Math.max(0.1, Math.min(3, (scaleX + scaleY) / 2)); // Clamp between 0.1x and 3x
            
            // Update current scale and tile dimensions
            currentScaleFactor = scaleFactor;
            CONFIG.TILE_WIDTH = CONFIG.BASE_TILE_WIDTH * scaleFactor;
            CONFIG.TILE_HEIGHT = CONFIG.BASE_TILE_HEIGHT * scaleFactor;
            
            // Calculate grid centering offsets to align with background image
            gridOffsetX = containerWidth / 2;
            gridOffsetY = containerHeight * 0.45; // Maintain current vertical positioning
            
            console.log(`ðŸ”§ Responsive scale updated: ${scaleFactor.toFixed(3)}x (Tile: ${CONFIG.TILE_WIDTH.toFixed(1)}x${CONFIG.TILE_HEIGHT.toFixed(1)}) Container: ${containerWidth}x${containerHeight}`);
            
            return scaleFactor;
        }
        
        function updateResponsiveScaling() {
            const oldScale = currentScaleFactor;
            const newScale = calculateResponsiveScale();
            
            // Only trigger redraw if scale changed significantly
            if (Math.abs(newScale - oldScale) > 0.01) {
                console.log(`ðŸ“ Scale changed: ${oldScale.toFixed(3)} â†’ ${newScale.toFixed(3)}`);
                // Trigger a redraw of the canvas
                if (typeof redraw === 'function') {
                    redraw();
                }
            }
        }
        
        // =============================================================================
        // COORDINATE CONVERSION
        // =============================================================================
        
        function worldToScreen(worldX, worldY) {
            const screenX = (worldX - worldY) * CONFIG.TILE_WIDTH / 2;
            const screenY = (worldX + worldY) * CONFIG.TILE_HEIGHT / 2;
            return {
                x: screenX + gridOffsetX - 30, // Use responsive offset
                y: screenY + gridOffsetY // Use responsive offset
            };
        }
        
        function screenToWorld(screenX, screenY) {
            const adjustedX = screenX - (gridOffsetX - 30); // Use responsive offset
            const adjustedY = screenY - gridOffsetY; // Use responsive offset
            const worldX = (adjustedX / (CONFIG.TILE_WIDTH / 2) + adjustedY / (CONFIG.TILE_HEIGHT / 2)) / 2;
            const worldY = (adjustedY / (CONFIG.TILE_HEIGHT / 2) - adjustedX / (CONFIG.TILE_WIDTH / 2)) / 2;
            return {
                x: Math.floor(worldX),
                y: Math.floor(worldY)
            };
        }
        
        function isValidTile(x, y) {
            return x >= 0 && x < CONFIG.GRID_WIDTH && y >= 0 && y < CONFIG.GRID_HEIGHT;
        }
        
        // =============================================================================
        // DRAWING FUNCTIONS
        // =============================================================================
        
        function drawIsometricTile(screenX, screenY, tileColor, strokeColor = null) {
            push();
            translate(screenX, screenY);
            
            if (strokeColor) {
                stroke(strokeColor);
                strokeWeight(2);
            } else {
                noStroke();
            }
            
            fill(tileColor);
            beginShape();
            vertex(0, -CONFIG.TILE_HEIGHT / 2);
            vertex(CONFIG.TILE_WIDTH / 2, 0);
            vertex(0, CONFIG.TILE_HEIGHT / 2);
            vertex(-CONFIG.TILE_WIDTH / 2, 0);
            endShape(CLOSE);
            
            pop();
        }
        
        // ENHANCED CROP DRAWING WITH PNG ASSETS AND ANIMATIONS
        function drawCrop(screenX, screenY, crop) {
            if (!crop) return;
            
            const cropColor = crop.getColor();
            const size = crop.getSize();
            const cropX = screenX;
            const cropY = screenY + CONFIG.TILE_HEIGHT / 4;
            
            push();
            
            // PLANT ANIMATION: Gentle sway for healthy plants
            if (crop.health > 50) {
                translate(cropX, cropY);
                rotate(sin(frameCount * 0.02 + crop.x * 0.5) * 0.05); // Gentle sway
                translate(-cropX, -cropY);
            }
            
            // PLANT ANIMATION: Pulse when growing
            let animationScale = 1.0;
            if (frameCount % 300 < 30) { // Growth pulse every 5 seconds
                animationScale = 1.0 + sin(frameCount * 0.3) * 0.1;
            }
            
            // Try to draw PNG sprite, fallback to original graphics
            if (crop.type === 'apple' && gameState.loadedAssets) {
                const assetKey = `apple_stage_${crop.stage + 1}`;
                const appleSprite = gameState.loadedAssets[assetKey];
                
                if (appleSprite && appleSprite.width > 0) {
                    // Calculate sprite size based on tile size (increased scale)
                    const spriteScale = (size * 8) / appleSprite.width * animationScale;
                    const spriteWidth = appleSprite.width * spriteScale;
                    const spriteHeight = appleSprite.height * spriteScale;
                    
                    // Position sprite based on growth stage - moved up to sit within grid boxes
                    let spriteY;
                    if (crop.stage === crop.maxStage || crop.stage === crop.maxStage - 1) {
                        // Stage 4 & 5: Move up to sit within the box
                        spriteY = cropY - spriteHeight / 2 - 25;
                    } else {
                        // Other stages: Move up more to sit within the box
                        spriteY = cropY - spriteHeight / 2 - 40;
                    }
                    
                    image(appleSprite, 
                          cropX - spriteWidth / 2,  // Center horizontally
                          spriteY,     // Stage-specific vertical positioning
                          spriteWidth, 
                          spriteHeight);
                } else {
                    // Fallback to original placeholder graphics
                    fill(cropColor);
                    noStroke();
                    const animatedSize = size * animationScale;
                    ellipse(cropX, cropY, animatedSize, animatedSize);
                    if (crop.stage === crop.maxStage) {
                        fill(255, 0, 0);
                        ellipse(cropX, cropY, animatedSize * 0.8, animatedSize * 0.8);
                    }
                }
            } else if (crop.type === 'carrot') {
                fill(cropColor);
                noStroke();
                const animatedSize = size * animationScale;
                triangle(
                    cropX, cropY - animatedSize / 2,
                    cropX - animatedSize / 2, cropY + animatedSize / 2,
                    cropX + animatedSize / 2, cropY + animatedSize / 2
                );
            } else {
                // Default drawing for other crop types
                fill(cropColor);
                noStroke();
                const animatedSize = size * animationScale;
                ellipse(cropX, cropY, animatedSize, animatedSize);
            }
            
            // STATUS INDICATORS WITH ANIMATIONS
            textAlign(CENTER);
            textSize(10);
            
            // Water meter/indicator
            if (crop.needsWater) {
                const bobOffset = sin(frameCount * 0.1) * 2;
                if (waterImage) {
                    // Draw custom water image
                    imageMode(CENTER);
                    image(waterImage, cropX + 15, cropY - 10 + bobOffset, 16, 16);
                } else {
                    // Fallback to emoji
                    fill(52, 152, 219);
                    text('ðŸ’§', cropX + 15, cropY - 10 + bobOffset);
                }
            }
            
            // Health indicator
            if (crop.health < 50) {
                fill(231, 76, 60);
                const flashAlpha = 150 + sin(frameCount * 0.2) * 105;
                fill(231, 76, 60, flashAlpha);
                text('ðŸ˜·', cropX - 15, cropY - 10);
            }
            
            // Ready to harvest glow
            if (crop.isReady) {
                const glowIntensity = 150 + sin(frameCount * 0.15) * 105;
                stroke(255, 255, 0, glowIntensity);
                strokeWeight(2);
                noFill();
                ellipse(cropX, cropY, size + 15, size + 15);
            }
            
            pop();
            
            // STATUS RING SYSTEM
            drawStatusRing(cropX, cropY, crop, size + 20);
        }
        
        // STATUS RING SYSTEM
        function drawStatusRing(x, y, crop, ringSize) {
            push();
            noFill();
            strokeWeight(2);
            
            let ringColor;
            if (crop.health < 30 || crop.needsWater) {
                ringColor = color(231, 76, 60); // Red for sick/needing care
            } else if (crop.needsWater || crop.health < 70) {
                ringColor = color(241, 196, 15); // Yellow for needs attention
            } else {
                ringColor = color(39, 174, 96); // Green for healthy
            }
            
            stroke(ringColor);
            
            // Pulsing animation
            const pulseScale = 1.0 + sin(frameCount * 0.1) * 0.1;
            ellipse(x, y, ringSize * pulseScale, ringSize * pulseScale);
            
            pop();
        }
        
        function drawTools() {
            // Draw sprinklers
            for (let sprinkler of gameState.placedSprinklers) {
                const screenPos = worldToScreen(sprinkler.x, sprinkler.y);
                if (waterImage) {
                    // Draw custom water image for sprinkler
                    imageMode(CENTER);
                    image(waterImage, screenPos.x + 20, screenPos.y - 15, 20, 20);
                } else {
                    // Fallback to emoji
                    fill(52, 152, 219);
                    textAlign(CENTER);
                    textSize(16);
                    text('ðŸ’§', screenPos.x + 20, screenPos.y - 15);
                }
            }
            
            // Draw greenhouses
            for (let greenhouse of gameState.placedGreenhouses) {
                const screenPos = worldToScreen(greenhouse.x, greenhouse.y);
                fill(39, 174, 96);
                textAlign(CENTER);
                textSize(16);
                text('ðŸ ', screenPos.x, screenPos.y - 20);
            }
            
            // Draw animal helpers
            for (let animal of gameState.animalHelpers) {
                const screenPos = worldToScreen(animal.x, animal.y);
                fill(241, 196, 15);
                textAlign(CENTER);
                textSize(14);
                text('ðŸ“', screenPos.x + 25, screenPos.y + 10);
            }
        }
        
        function drawGrid() {
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    const tile = gameState.grid[y][x];
                    const screenPos = worldToScreen(x, y);
                    
                    let tileColor = tile.type === 'soil' ? color(139, 69, 19) : color(34, 139, 34);
                    let strokeColor = null;
                    
                    if (gameState.selectedTile && 
                        gameState.selectedTile.x === x && 
                        gameState.selectedTile.y === y) {
                        strokeColor = color(255, 255, 0);
                    }
                    
                    drawIsometricTile(screenPos.x, screenPos.y, tileColor, strokeColor);
                    
                    if (tile.crop) {
                        drawCrop(screenPos.x, screenPos.y, tile.crop);
                    }
                }
            }
            
            drawTools();
        }
        
        function drawPlantMenu() {
            if (!gameState.showPlantMenu) return;
            
            push();
            fill(44, 62, 80, 240);
            stroke(241, 196, 15);
            strokeWeight(2);
            rect(gameState.plantMenuPos.x, gameState.plantMenuPos.y, 200, 120, 8);
            
            fill(241, 196, 15);
            textAlign(CENTER);
            textSize(12);
            text("Plant Seeds", gameState.plantMenuPos.x + 100, gameState.plantMenuPos.y + 25);
            
            // Apple button
            let appleButtonY = gameState.plantMenuPos.y + 45;
            fill(gameState.appleSeeds > 0 && gameState.coins >= PRICES['apple-seeds'] ? 
                 color(39, 174, 96) : color(127, 140, 141));
            rect(gameState.plantMenuPos.x + 10, appleButtonY, 180, 25, 4);
            
            fill(255);
            textAlign(LEFT);
            textSize(10);
                            text(`ðŸŒ° Plant Apple (${PRICES['apple-seeds']} coins)`, gameState.plantMenuPos.x + 15, appleButtonY + 16);
            
            // Carrot button
            let carrotButtonY = gameState.plantMenuPos.y + 75;
            fill(gameState.carrotSeeds > 0 && gameState.coins >= PRICES['carrot-seeds'] ? 
                 color(39, 174, 96) : color(127, 140, 141));
            rect(gameState.plantMenuPos.x + 10, carrotButtonY, 180, 25, 4);
            
            fill(255);
                            text(`ðŸ¥• Plant Carrot (${PRICES['carrot-seeds']} coins)`, gameState.plantMenuPos.x + 15, carrotButtonY + 16);
            
            pop();
        }
        
        // =============================================================================
        // ANIMATION UTILITY FUNCTIONS
        // =============================================================================
        
        // COIN COLLECTION ANIMATION
        function addCoinAnimation(tileX, tileY, amount) {
            const screenPos = worldToScreen(tileX, tileY);
            const coinElement = document.createElement('div');
            coinElement.className = 'coin-animation';
            coinElement.innerHTML = `+${amount} <img src="assets/coin.png" alt="coin" style="width: 16px; height: 16px; vertical-align: middle;">`;
            coinElement.style.left = screenPos.x + 'px';
            coinElement.style.top = screenPos.y + 'px';
            coinElement.style.position = 'fixed';
            document.body.appendChild(coinElement);
            
            setTimeout(() => {
                if (coinElement.parentNode) {
                    coinElement.parentNode.removeChild(coinElement);
                }
            }, 1000);
        }
        
        // WATER ANIMATION
        function addWaterAnimation(tileX, tileY) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create multiple water droplets
            for (let i = 0; i < 5; i++) {
                const dropElement = document.createElement('div');
                dropElement.className = 'water-effect';
                
                // Use custom water image instead of emoji
                dropElement.innerHTML = getWaterIconForDOM('small');
                
                dropElement.style.left = (screenPos.x + (i - 2) * 8) + 'px';
                dropElement.style.top = (screenPos.y - 20) + 'px';
                dropElement.style.position = 'fixed';
                document.body.appendChild(dropElement);
                
                setTimeout(() => {
                    if (dropElement.parentNode) {
                        dropElement.parentNode.removeChild(dropElement);
                    }
                }, 1000);
            }
        }
        
        // PESTICIDE ANIMATION
        function addPesticideAnimation(tileX, tileY) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create pesticide spray effect
            for (let i = 0; i < 8; i++) {
                const sprayElement = document.createElement('div');
                sprayElement.className = 'pesticide-effect';
                sprayElement.textContent = 'ðŸ§½';
                sprayElement.style.left = (screenPos.x + (i - 4) * 6) + 'px';
                sprayElement.style.top = (screenPos.y - 15 + (i % 2) * 10) + 'px';
                sprayElement.style.position = 'fixed';
                sprayElement.style.fontSize = '12px';
                sprayElement.style.opacity = '0.8';
                document.body.appendChild(sprayElement);
                
                setTimeout(() => {
                    if (sprayElement.parentNode) {
                        sprayElement.parentNode.removeChild(sprayElement);
                    }
                }, 1500);
            }
        }
        
        // NEW: HEALING ANIMATION
        function addHealingAnimation(tileX, tileY) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create healing sparkle effect
            for (let i = 0; i < 6; i++) {
                const healElement = document.createElement('div');
                healElement.className = 'healing-effect';
                healElement.textContent = 'âœ¨';
                healElement.style.left = (screenPos.x + (i - 3) * 8) + 'px';
                healElement.style.top = (screenPos.y - 20 - i * 4) + 'px';
                healElement.style.position = 'fixed';
                healElement.style.fontSize = '16px';
                healElement.style.opacity = '0.9';
                healElement.style.zIndex = '1000';
                document.body.appendChild(healElement);
                
                setTimeout(() => {
                    if (healElement.parentNode) {
                        healElement.parentNode.removeChild(healElement);
                    }
                }, 2000);
            }
        }
        
        // SUNLIGHT ANIMATION
        function addSunlightAnimation(tileX, tileY) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create sunlight beam effect
            for (let i = 0; i < 6; i++) {
                const lightElement = document.createElement('div');
                lightElement.className = 'sunlight-effect';
                lightElement.innerHTML = '<img src="assets/sun.png" alt="Sunlight" style="width: 16px; height: 16px;">';
                lightElement.style.left = (screenPos.x + (i - 3) * 8) + 'px';
                lightElement.style.top = (screenPos.y - 25 - i * 3) + 'px';
                lightElement.style.position = 'fixed';
                lightElement.style.fontSize = '14px';
                lightElement.style.opacity = '0.9';
                document.body.appendChild(lightElement);
                
                setTimeout(() => {
                    if (lightElement.parentNode) {
                        lightElement.parentNode.removeChild(lightElement);
                    }
                }, 2000);
            }
        }
        
        // REMOVE ANIMATION
        function addRemoveAnimation(tileX, tileY) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create removal effect
            for (let i = 0; i < 5; i++) {
                const removeElement = document.createElement('div');
                removeElement.className = 'remove-effect';
                removeElement.textContent = 'ðŸ—‘ï¸';
                removeElement.style.left = (screenPos.x + (i - 2) * 10) + 'px';
                removeElement.style.top = (screenPos.y - 20 + (i % 2) * 8) + 'px';
                removeElement.style.position = 'fixed';
                removeElement.style.fontSize = '16px';
                removeElement.style.opacity = '0.8';
                document.body.appendChild(removeElement);
                
                setTimeout(() => {
                    if (removeElement.parentNode) {
                        removeElement.parentNode.removeChild(removeElement);
                    }
                }, 1200);
            }
        }
        
        // ENHANCED WEATHER EFFECTS SYSTEM
        let currentWeatherEffect = null;
        let weatherTransitionInProgress = false;
        
        function createWeatherEffects(weatherCondition) {
            if (weatherTransitionInProgress) return;
            
            const overlay = document.getElementById('weather-overlay');
            if (!overlay) return;
            
            // If same weather, no need to transition
            if (currentWeatherEffect === weatherCondition) return;
            
            console.log(`ðŸŒ¤ï¸ Transitioning weather effects: ${currentWeatherEffect} â†’ ${weatherCondition}`);
            
            // Start transition
            weatherTransitionInProgress = true;
            
            // Fade out current effects
            overlay.style.opacity = '0';
            
            setTimeout(() => {
                // Clear and create new effects
                overlay.innerHTML = '';
                createWeatherVisuals(overlay, weatherCondition);
                currentWeatherEffect = weatherCondition;
                
                // Fade in new effects
                overlay.style.opacity = '1';
                weatherTransitionInProgress = false;
            }, 1000); // 1 second fade out, then fade in over 2 seconds (CSS transition)
        }
        
        function createWeatherVisuals(overlay, weatherCondition) {
            // Add background tint
            const tint = document.createElement('div');
            tint.className = 'weather-tint';
            
            switch(weatherCondition?.toLowerCase()) {
                case 'sunny':
                case 'clear':
                    tint.classList.add('sunny');
                    createSunEffects(overlay);
                    break;
                    
                case 'rainy':
                case 'rain':
                case 'light rain':
                case 'shower rain':
                case 'moderate rain':
                    tint.classList.add('rain');
                    createRainEffect(overlay, weatherCondition);
                    break;
                    
                case 'heavy rain':
                case 'heavy intensity rain':
                case 'thunderstorm':
                case 'stormy':
                    tint.classList.add('heavy-rain');
                    createRainEffect(overlay, weatherCondition);
                    break;
                    
                case 'snowy':
                case 'snow':
                    tint.classList.add('snow');
                    createSnowEffect(overlay);
                    break;
                    
                case 'cloudy':
                case 'overcast':
                case 'partly cloudy':
                case 'scattered clouds':
                case 'broken clouds':
                case 'overcast clouds':
                case 'few clouds':
                    tint.classList.add('cloudy');
                    createCloudyEffect(overlay);
                    break;
                    
                case 'foggy':
                case 'mist':
                case 'haze':
                case 'hazy':
                case 'dusty':
                    tint.classList.add('cloudy');
                    createMistEffect(overlay);
                    break;
                    
                default:
                    // Clear/default weather
                    tint.classList.add('sunny');
                    createSunEffects(overlay);
                    break;
            }
            
            overlay.appendChild(tint);
        }
        
        function createSunEffects(overlay) {
            // Main sun glow
            const sunGlow = document.createElement('div');
            sunGlow.className = 'sun-glow';
            overlay.appendChild(sunGlow);
            
            // Multiple sunbeams at different positions
            for (let i = 0; i < 4; i++) {
                const beam = document.createElement('div');
                beam.className = 'sunbeam';
                beam.style.left = Math.random() * 70 + 15 + '%';
                beam.style.top = Math.random() * 70 + 15 + '%';
                beam.style.animationDelay = Math.random() * 3 + 's';
                beam.style.animationDuration = (Math.random() * 2 + 4) + 's';
                overlay.appendChild(beam);
            }
        }
        
        function createRainEffect(overlay, intensity = 'rain') {
            const isHeavy = intensity?.toLowerCase().includes('heavy') || intensity?.toLowerCase().includes('thunderstorm');
            const isLight = intensity?.toLowerCase().includes('light') || intensity?.toLowerCase().includes('drizzle');
            
            // Use same drop count for both light rain and normal rain to make them identical
            const dropCount = isHeavy ? 150 : 50;
            
            for (let i = 0; i < dropCount; i++) {
                const drop = document.createElement('div');
                drop.className = 'rain-drop';
                
                if (isHeavy) {
                    drop.classList.add('heavy');
                }
                // Removed the light class application - light rain now uses same visuals as normal rain
                
                drop.style.left = Math.random() * 100 + '%';
                drop.style.animationDelay = Math.random() * (isHeavy ? 1 : 2) + 's';
                drop.style.animationDuration = isHeavy ? 
                    (Math.random() * 0.2 + 0.3) + 's' : 
                    (Math.random() * 0.5 + 0.6) + 's';
                
                // Heavy rain gets additional randomness for more chaotic appearance
                if (isHeavy) {
                    drop.style.transform = `rotate(${Math.random() * 10 + 10}deg)`;
                    if (Math.random() > 0.7) {
                        drop.style.opacity = '1';
                    }
                }
                
                overlay.appendChild(drop);
            }
        }
        
        function createSnowEffect(overlay) {
            for (let i = 0; i < 40; i++) {
                const flake = document.createElement('div');
                flake.className = 'snow-flake';
                
                const flakeTypes = ['â„', 'â…', 'âš¹'];
                flake.textContent = flakeTypes[Math.floor(Math.random() * flakeTypes.length)];
                
                const size = Math.random();
                if (size > 0.7) {
                    flake.classList.add('large');
                } else if (size < 0.3) {
                    flake.classList.add('small');
                }
                
                flake.style.left = Math.random() * 100 + '%';
                flake.style.animationDelay = Math.random() * 4 + 's';
                flake.style.animationDuration = (Math.random() * 3 + 4) + 's';
                overlay.appendChild(flake);
            }
        }
        
        function createCloudyEffect(overlay) {
            // Create moving clouds
            for (let i = 0; i < 3; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'cloud';
                
                const sizes = ['small', 'medium', 'large'];
                cloud.classList.add(sizes[i % sizes.length]);
                
                cloud.style.animationDelay = Math.random() * 10 + 's';
                cloud.style.animationDuration = (Math.random() * 20 + 30) + 's';
                
                overlay.appendChild(cloud);
            }
            
            // Dimmed sunbeams
            for (let i = 0; i < 2; i++) {
                const beam = document.createElement('div');
                beam.className = 'sunbeam';
                beam.style.left = Math.random() * 80 + 10 + '%';
                beam.style.top = Math.random() * 80 + 10 + '%';
                beam.style.opacity = '0.3';
                beam.style.animationDelay = Math.random() * 4 + 's';
                beam.style.animationDuration = (Math.random() * 3 + 6) + 's';
                overlay.appendChild(beam);
            }
        }
        
        function createMistEffect(overlay) {
            // Ground mist
            const mist = document.createElement('div');
            mist.className = 'mist';
            overlay.appendChild(mist);
            
            // Slow-moving clouds
            for (let i = 0; i < 2; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'cloud medium';
                cloud.style.opacity = '0.6';
                cloud.style.animationDelay = Math.random() * 15 + 's';
                cloud.style.animationDuration = (Math.random() * 30 + 45) + 's';
                overlay.appendChild(cloud);
            }
        }
        
        // PURCHASE NOTIFICATION
        function showPurchaseNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'purchase-notification';
            notification.innerHTML = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        // =============================================================================
        // UI UPDATE FUNCTIONS
        // =============================================================================
        
        function updateAllUI() {
            updateResourcesUI();
            updateInventoryUI();
            updateTopBarUI();
            updatePlantStatusUI();
            updateNarrativeUI();
            updateWeatherUI();
            updateShopButtons(); // NEW: Update shop button states when coins change
        }
        
        function updateResourcesUI() {
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('apple-seeds').textContent = gameState.appleSeeds;
            document.getElementById('carrot-seeds').textContent = gameState.carrotSeeds;
            document.getElementById('harvested').textContent = gameState.harvested;
            document.getElementById('garden-level').textContent = gameState.gardenLevel;
            console.log(`ðŸ’° Coins updated to: ${gameState.coins}`); // Debug log
        }
        
        // ENHANCED INVENTORY UPDATE
        function updateInventoryUI() {
            // Old panel updates
            if (document.getElementById('watering-cans')) {
                document.getElementById('watering-cans').textContent = gameState.wateringCans;
            }
            if (document.getElementById('sprinklers')) {
                document.getElementById('sprinklers').textContent = gameState.sprinklers;
            }
            if (document.getElementById('greenhouses')) {
                document.getElementById('greenhouses').textContent = gameState.greenhouses;
            }
            if (document.getElementById('animals')) {
                document.getElementById('animals').textContent = gameState.animals;
            }
            
            // Enhanced inventory panel updates with visual feedback
            if (document.getElementById('inv-apple-seeds')) {
                const appleSeedElement = document.getElementById('inv-apple-seeds');
                const oldValue = parseInt(appleSeedElement.textContent) || 0;
                const newValue = gameState.appleSeeds;
                appleSeedElement.textContent = newValue;
                
                // Add visual feedback when count changes
                if (newValue !== oldValue) {
                    appleSeedElement.style.animation = 'none';
                    setTimeout(() => {
                        appleSeedElement.style.animation = 'pulse 0.6s ease-in-out';
                    }, 10);
                }
            }
            if (document.getElementById('inv-carrot-seeds')) {
                const carrotSeedElement = document.getElementById('inv-carrot-seeds');
                const oldValue = parseInt(carrotSeedElement.textContent) || 0;
                const newValue = gameState.carrotSeeds;
                carrotSeedElement.textContent = newValue;
                
                // Add visual feedback when count changes
                if (newValue !== oldValue) {
                    carrotSeedElement.style.animation = 'none';
                    setTimeout(() => {
                        carrotSeedElement.style.animation = 'pulse 0.6s ease-in-out';
                    }, 10);
                }
            }
            if (document.getElementById('inv-watering-cans')) {
                document.getElementById('inv-watering-cans').textContent = gameState.wateringCans;
            }
            if (document.getElementById('inv-sprinklers')) {
                document.getElementById('inv-sprinklers').textContent = gameState.sprinklers;
            }
            if (document.getElementById('inv-greenhouses')) {
                document.getElementById('inv-greenhouses').textContent = gameState.greenhouses;
            }
            if (document.getElementById('inv-animals')) {
                document.getElementById('inv-animals').textContent = gameState.animals;
            }
            if (document.getElementById('inv-harvested-apples')) {
                document.getElementById('inv-harvested-apples').textContent = gameState.harvestedApples || 0;
            }
            if (document.getElementById('inv-harvested-carrots')) {
                document.getElementById('inv-harvested-carrots').textContent = gameState.harvestedCarrots || 0;
            }
        }
        
        // TOP BAR UI UPDATE
        function updateTopBarUI() {
            if (document.getElementById('top-coin-count')) {
                document.getElementById('top-coin-count').textContent = gameState.coins;
            }
            if (document.getElementById('top-weather-icon')) {
                document.getElementById('top-weather-icon').innerHTML = gameState.weather.icon;
            }
            if (document.getElementById('top-weather-condition')) {
                document.getElementById('top-weather-condition').textContent = gameState.weather.condition;
            }
            if (document.getElementById('xp-level')) {
                document.getElementById('xp-level').textContent = `Lv.${gameState.gardenLevel}`;
            }
            
            // XP bar animation
            const xpProgress = (gameState.harvested % 10) * 10; // Level up every 10 harvests
            if (document.getElementById('xp-fill')) {
                document.getElementById('xp-fill').style.width = xpProgress + '%';
            }
        }
        
        function updateWeatherUI() {
            // Top bar weather icon
            if (document.getElementById('top-weather-icon')) {
                document.getElementById('top-weather-icon').innerHTML = gameState.weather.icon;
            }
            
            // Weather panel updates
            if (document.getElementById('weather-icon')) {
                document.getElementById('weather-icon').innerHTML = gameState.weather.icon;
            }
            if (document.getElementById('weather-condition')) {
                document.getElementById('weather-condition').textContent = gameState.weather.condition;
            }
            if (document.getElementById('temperature')) {
                document.getElementById('temperature').textContent = gameState.weather.temperature + 'Â°C';
            }
            if (document.getElementById('humidity')) {
                document.getElementById('humidity').textContent = gameState.weather.humidity + '%';
            }
            if (document.getElementById('pollution')) {
                document.getElementById('pollution').textContent = gameState.weather.pollution || 'Low';
            }
            if (document.getElementById('soil-quality')) {
                document.getElementById('soil-quality').textContent = gameState.weather.soilQuality || 'Rich';
            }
            
            // NEW: Additional weather details
            if (document.getElementById('weather-location') && gameState.weather.location) {
                document.getElementById('weather-location').textContent = gameState.weather.location;
            }
            if (document.getElementById('weather-description') && gameState.weather.description) {
                document.getElementById('weather-description').textContent = gameState.weather.description;
            }
            if (document.getElementById('wind-speed') && gameState.weather.windSpeed !== undefined) {
                document.getElementById('wind-speed').textContent = gameState.weather.windSpeed + ' km/h';
            }
            if (document.getElementById('pressure') && gameState.weather.pressure) {
                document.getElementById('pressure').textContent = gameState.weather.pressure + ' hPa';
            }
            if (document.getElementById('visibility') && gameState.weather.visibility) {
                document.getElementById('visibility').textContent = gameState.weather.visibility + ' km';
            }
            
            // Update weather effects
            createWeatherEffects(gameState.weather.condition);
        }
        
        function updatePlantStatusUI() {
            const plantList = document.getElementById('plant-status-list');
            plantList.innerHTML = '';
            
            let cropCount = 0;
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    const tile = gameState.grid[y][x];
                    if (tile.crop) {
                        cropCount++;
                        const item = document.createElement('div');
                        item.className = 'plant-status-item';
                        
                        const icons = tile.crop.getStatusIcons();
                        const iconHTML = icons.map(icon => 
                            `<span class="status-icon ${icon.class}">${icon.icon}</span>`
                        ).join('');
                        
                        item.innerHTML = `
                            <span>${tile.crop.type} (${x},${y}) - Stage ${tile.crop.stage + 1}</span>
                            <div class="plant-icons">${iconHTML}</div>
                        `;
                        plantList.appendChild(item);
                    }
                }
            }
            
            if (cropCount === 0) {
                plantList.innerHTML = '<div style="text-align: center; color: #95a5a6; font-size: 8px;">No crops planted yet</div>';
            }
        }
        
        function updateNarrativeUI() {
            const now = Date.now();
            if (now - gameState.lastNarrativeUpdate > 20000) { // Every 20 seconds
                const message = NARRATIVE_MESSAGES[Math.floor(Math.random() * NARRATIVE_MESSAGES.length)];
                document.getElementById('narrative-text').textContent = `"${message}"`;
                gameState.lastNarrativeUpdate = now;
            }
        }
        
        // =============================================================================
        // INPUT HANDLING
        // =============================================================================
        
        function mouseMoved() {
            if (!gameState.gameStarted) return;
            
            // Get transformed mouse coordinates for game logic
            const transformedCoords = getTransformedMouseCoords();
            const worldPos = screenToWorld(transformedCoords.x, transformedCoords.y);
            
            // Check if hovering over a plant
            if (isValidTile(worldPos.x, worldPos.y)) {
                const tile = gameState.grid[worldPos.y][worldPos.x];
                if (tile.crop) {
                    // Use actual screen mouse coordinates for panel positioning (not transformed)
                    showPlantConditionPanel(tile.crop, mouseX, mouseY);
                    return;
                }
            }
            
            // Hide panel if not hovering over a plant
            hidePlantConditionPanel();
        }
        
        function mouseOut() {
            // Hide panel when mouse leaves canvas
            hidePlantConditionPanel();
        }
        
        function mousePressed() {
            if (!gameState.gameStarted) return;
            
            // Don't process clicks if we're dragging the viewport
            if (zoomPanState.isDragging) {
                console.log('ðŸš« Click ignored - dragging viewport');
                return;
            }
            
            // Get transformed mouse coordinates
            const transformedCoords = getTransformedMouseCoords();
            console.log('ðŸ–±ï¸ Mouse clicked:', {
                rawMouse: { x: mouseX, y: mouseY },
                transformed: transformedCoords,
                zoomPan: { 
                    scale: zoomPanState.scale.toFixed(2), 
                    translateX: zoomPanState.translateX.toFixed(2), 
                    translateY: zoomPanState.translateY.toFixed(2) 
                }
            });
            
            // Use transformed coordinates for game logic
            const worldPos = screenToWorld(transformedCoords.x, transformedCoords.y);
            console.log('ðŸŒŽ World position:', worldPos);
            
            // Handle plant menu
            if (gameState.showPlantMenu) {
                const menuX = gameState.plantMenuPos.x;
                const menuY = gameState.plantMenuPos.y;
                
                if (transformedCoords.x >= menuX && transformedCoords.x <= menuX + 200 && 
                    transformedCoords.y >= menuY && transformedCoords.y <= menuY + 120) {
                    
                    if (transformedCoords.y >= menuY + 45 && transformedCoords.y <= menuY + 70) {
                        if (gameState.selectedTile) {
                            const tile = gameState.grid[gameState.selectedTile.y][gameState.selectedTile.x];
                            tile.plantCrop('apple');
                        }
                        gameState.showPlantMenu = false;
                        return;
                    }
                    
                    if (mouseY >= menuY + 75 && mouseY <= menuY + 100) {
                        if (gameState.selectedTile) {
                            const tile = gameState.grid[gameState.selectedTile.y][gameState.selectedTile.x];
                            tile.plantCrop('carrot');
                        }
                        gameState.showPlantMenu = false;
                        return;
                    }
                } else {
                    gameState.showPlantMenu = false;
                    return;
                }
            }
            
            // Handle tile interaction
            if (isValidTile(worldPos.x, worldPos.y)) {
                const tile = gameState.grid[worldPos.y][worldPos.x];
                gameState.selectedTile = { x: worldPos.x, y: worldPos.y };
                
                console.log(`ðŸ–±ï¸ Clicked on tile (${worldPos.x}, ${worldPos.y}) with tool: ${gameState.selectedTool || 'none'}`);
                if (tile.crop) {
                    console.log(`ðŸŒ± Crop info: type=${tile.crop.type}, stage=${tile.crop.stage}/${tile.crop.maxStage}, applesAvailable=${tile.crop.applesAvailable}, isClickable=${tile.crop.isClickable()}`);
                }
                console.log(`ðŸ”§ Available tools:`, gameState.tools);
                
                // NEW: Tool usage system (exclude shovel - it has its own logic)
                if (gameState.selectedTool && gameState.selectedTool !== 'shovel' && tile.crop) {
                    if (useTool(tile)) {
                        showPurchaseNotification(`âœ… Used ${gameState.selectedTool.replace('_', ' ')}!`);
                    } else {
                        showPurchaseNotification(`âŒ Cannot use ${gameState.selectedTool.replace('_', ' ')} here!`);
                    }
                    return;
                }
                
                if (mouseButton === RIGHT) {
                    // Right-click handling - for watering and tool usage
                    if (tile.crop && tile.crop.isClickable()) {
                        // ENHANCED: Use selected tool or water plant
                        if (gameState.selectedTool === 'pesticide' && gameState.tools.pesticide > 0) {
                            console.log(`ðŸ§ª PESTICIDE DEBUG - Plant has pests: ${tile.crop.hasPests}, Plant status: ${tile.crop.status}`);
                            if (tile.crop.treatPests()) {
                                gameState.tools.pesticide--;
                                updateToolUI();
                                addPesticideAnimation(worldPos.x, worldPos.y);
                                showPurchaseNotification('ðŸ§ª Pests cured! Plant can grow again! ðŸŒ±');
                                console.log(`ðŸ§ª Pesticide applied successfully! Remaining: ${gameState.tools.pesticide}`);
                                
                                // Update hover panel if it's currently showing this plant
                                updateHoverPanelIfVisible(tile.crop);
                            } else {
                                showPurchaseNotification('No pests to treat! âœ…');
                                console.log(`ðŸ§ª Pesticide not needed - Plant has no pests`);
                            }
                        } else if (gameState.selectedTool === 'solar_lamp' && gameState.tools.solar_lamp > 0) {
                            if (tile.crop.giveSunlight()) {
                                gameState.tools.solar_lamp--;
                                updateToolUI();
                                addSunlightAnimation(worldPos.x, worldPos.y);
                                showPurchaseNotification('Sunlight provided! â˜€ï¸');
                                
                                // Update hover panel if it's currently showing this plant
                                updateHoverPanelIfVisible(tile.crop);
                            } else {
                                showPurchaseNotification('Plant has enough sunlight! â˜€ï¸');
                            }
                        } else {
                            // Default: Water plant using new health system
                            if (tile.crop.waterPlant()) {
                                addWaterAnimation(worldPos.x, worldPos.y);
                                showPurchaseNotification(`Crop watered! ${getWaterIconForDOM()}`);
                                
                                // Update hover panel if it's currently showing this plant
                                updateHoverPanelIfVisible(tile.crop);
                            } else {
                                showPurchaseNotification('Cannot water dead plant! ðŸ’€');
                            }
                        }
                    }
                } else {
                    // Left-click handling - for harvesting and digging
                    console.log(`ðŸ” Checking shovel conditions: tool=${gameState.selectedTool}, hasCrop=${!!tile.crop}, clickable=${tile.crop ? tile.crop.isClickable() : 'N/A'}`);
                    if (gameState.selectedTool === 'shovel' && tile.crop) {
                        // Shovel selected + left-click on fully grown tree - dig up tree
                        console.log('ðŸ—¡ï¸ Shovel selected - digging up tree');
                        console.log(`ðŸ—¡ï¸ Shovel conditions: selectedTool=${gameState.selectedTool}, hasCrop=${!!tile.crop}, isClickable=${tile.crop.isClickable()}`);
                        if (tile.digUpTree()) {
                            console.log('ðŸ—¡ï¸ Successfully dug up tree');
                        } else {
                            console.log('ðŸ—¡ï¸ Failed to dig up tree');
                            showPurchaseNotification('âŒ Cannot use shovel on this tree');
                        }
                    } else if (tile.crop && tile.crop.type === 'apple' && tile.crop.stage === tile.crop.maxStage && tile.crop.applesAvailable && tile.crop.isClickable()) {
                        // Left-click on apple tree with apples available - harvest apples only
                        tile.harvestApples();
                    } else if (tile.crop && tile.crop.type === 'apple' && tile.crop.stage === tile.crop.maxStage && !tile.crop.applesAvailable && tile.crop.isClickable()) {
                        // Left-click on apple tree without apples available - show message
                        const timeLeft = tile.crop.lastHarvestTime ? 
                            Math.max(0, tile.crop.appleRegenTime - (Date.now() - tile.crop.lastHarvestTime)) : 0;
                        const minutesLeft = Math.ceil(timeLeft / 60000);
                        showPurchaseNotification(`ðŸŽ Apples will be ready in ${minutesLeft} minutes. Use shovel to dig up tree.`);
                    } else if (tile.crop && tile.crop.isReady && tile.crop.isClickable() && tile.crop.type !== 'apple') {
                        // Regular harvest for non-apple crops (removes entire plant)
                        tile.harvestCrop();
                    } else if (tile.crop && tile.crop.status === 'dead') {
                        // Remove dead tree
                        if (tile.crop.removeDeadTree()) {
                            tile.crop = null; // Clear the tile
                            addRemoveAnimation(worldPos.x, worldPos.y);
                            showPurchaseNotification('Dead tree removed! ðŸ—‘ï¸');
                        }
                    } else if (!tile.crop) {
                        gameState.showPlantMenu = true;
                        gameState.plantMenuPos = { x: mouseX + 10, y: mouseY - 60 };
                        
                        if (gameState.plantMenuPos.x + 200 > width) {
                            gameState.plantMenuPos.x = width - 210;
                        }
                        if (gameState.plantMenuPos.y < 0) {
                            gameState.plantMenuPos.y = 10;
                        }
                    } else if (tile.crop && !tile.crop.isClickable()) {
                        showPurchaseNotification('This plant is dead! ðŸ’€ Click to remove it.');
                    }
                }
            }
        }
        
        function keyPressed() {
            if (!gameState.gameStarted) return;
            
            if (key === ' ') {
                // Water all crops with animations
                let wateredCount = 0;
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        const tile = gameState.grid[y][x];
                        if (tile.crop && tile.crop.needsWater) {
                            tile.crop.water();
                            // Add water animation
                            addWaterAnimation(x, y);
                            wateredCount++;
                        }
                    }
                }
                if (wateredCount > 0) {
                    showPurchaseNotification(`${getWaterIconForDOM()} Watered ${wateredCount} crops!`);
                }
            }
            
            // NEW: Debug mode toggle (press D)
            if (key === 'd' || key === 'D') {
                CONFIG.DEBUG_MODE = !CONFIG.DEBUG_MODE;
                showPurchaseNotification(`ðŸ› Debug mode ${CONFIG.DEBUG_MODE ? 'ON' : 'OFF'}`);
                console.log(`Debug mode: ${CONFIG.DEBUG_MODE}`);
            }
            
            // NEW: Add test pesticide (press P)
            if ((key === 'p' || key === 'P') && CONFIG.DEBUG_MODE) {
                gameState.tools.pesticide += 5;
                updateToolUI();
                showPurchaseNotification(`ðŸ§ª Added 5 pesticide for testing!`);
            }
            
            // NEW: Add test solar lamps (press L)  
            if ((key === 'l' || key === 'L') && CONFIG.DEBUG_MODE) {
                gameState.tools.solar_lamp += 3;
                updateToolUI();
                showPurchaseNotification(`ðŸ’¡ Added 3 solar lamps for testing!`);
            }
        }
        
        // =============================================================================
        // SHOP SYSTEM
        // =============================================================================
        

        
        // =============================================================================
        // SIMPLE INVENTORY SELECTION (VISUAL ONLY)
        // =============================================================================
        
        let selectedInventoryItem = null;
        
        function selectItem(itemType) {
            // Clear previous selection
            document.querySelectorAll('.clickable-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelectorAll('.selected-indicator').forEach(indicator => {
                indicator.style.display = 'none';
            });
            
            // Set new selection
            const itemElement = document.getElementById(`item-${itemType}`);
            const indicator = itemElement.querySelector('.selected-indicator');
            
            if (selectedInventoryItem === itemType) {
                // Deselect if clicking the same item
                selectedInventoryItem = null;
            } else {
                // Select new item
                selectedInventoryItem = itemType;
                itemElement.classList.add('selected');
                indicator.style.display = 'inline';
                
                // Show selection notification
                const itemName = itemType.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
                showPurchaseNotification(`ðŸ“¦ Selected: ${itemName}`);
            }
        }
        
        // =============================================================================
        // ENHANCED SHOP SYSTEM WITH ANIMATIONS
        // =============================================================================
        
        function buyItem(itemType, cost, amount) {
            console.log(`ðŸ›’ Purchase attempt: ${itemType} x${amount} for ${cost} coins (have: ${gameState.coins})`);
            
            // Check if player has enough coins
            if (gameState.coins >= cost) {
                // Deduct coins with animation
                gameState.coins -= cost;
                console.log(`ðŸ’° Coins after purchase: ${gameState.coins}`);
                
                let itemName = '';
                let icon = '';
                
                switch(itemType) {
                    case 'apple-seeds':
                        gameState.appleSeeds += amount;
                        itemName = `Apple Seeds x${amount}`;
                        icon = 'ðŸŒ°';
                        break;
                    case 'carrot-seeds':
                        gameState.carrotSeeds += amount;
                        itemName = `Carrot Seeds x${amount}`;
                        icon = 'ðŸ¥•';
                        break;
                    case 'sprinkler':
                        gameState.sprinklers += amount;
                        itemName = `Sprinkler x${amount}`;
                        icon = getWaterIconForDOM();
                        break;
                    case 'greenhouse':
                        gameState.greenhouses += amount;
                        itemName = `Greenhouse x${amount}`;
                        icon = 'ðŸ ';
                        break;
                    case 'pesticide':
                        gameState.tools.pesticide += amount;
                        itemName = `Pesticide x${amount}`;
                        icon = 'ðŸ§ª';
                        break;
                    case 'solar_lamp':
                        gameState.tools.solar_lamp += amount;
                        itemName = `Solar Lamp x${amount}`;
                        icon = '<img src="assets/sun.png" alt="Solar Lamp" style="width: 16px; height: 16px; vertical-align: middle;">';
                        break;
                    case 'animal':
                        gameState.animals += amount;
                        itemName = `Chicken Helper x${amount}`;
                        icon = 'ðŸ“';
                        // Place animal randomly
                        const x = Math.floor(Math.random() * CONFIG.GRID_WIDTH);
                        const y = Math.floor(Math.random() * CONFIG.GRID_HEIGHT);
                        gameState.animalHelpers.push({ x, y });
                        break;
                }
                
                // Update UI immediately
                updateAllUI();
                
                // Synchronize inventory states with purchases
                synchronizeInventoryStates();
                
                // Show purchase notification with animation
                showPurchaseNotification(`${icon} ${itemName} Purchased!`);
                
                // Update shop button states
                updateShopButtons();
                

                
                console.log(`âœ… Purchased: ${itemName} for ${cost} coins`);
            } else {
                // Not enough coins - show error
                showPurchaseNotification(`âŒ Need ${cost - gameState.coins} more coins!`);
                
                // Shake effect on buttons (visual feedback)
                const buttons = document.querySelectorAll('.shop-button');
                buttons.forEach(button => {
                    button.style.animation = 'none';
                    setTimeout(() => {
                        button.style.animation = 'shake 0.5s ease-in-out';
                    }, 10);
                });
                
                console.log(`âŒ Purchase failed: ${itemType} costs ${cost}, have ${gameState.coins} coins`);
            }
        }
        
        // SYNCHRONIZE INVENTORY STATES WITH PURCHASES
        function synchronizeInventoryStates() {
            console.log('ðŸ”„ Synchronizing inventory states...');
            console.log('ðŸ› ï¸ Current tools:', gameState.tools);
            console.log('ðŸ“¦ Current inventory:', { sprinklers: gameState.sprinklers, greenhouses: gameState.greenhouses, animals: gameState.animals });
            
            // Define which items should be enabled by default (core tools)
            const defaultActiveItems = ['watering_can', 'shovel'];
            
            // Define purchase requirements for other items
            const purchaseRequirements = {
                'pesticide': () => gameState.tools.pesticide > 0,
                'solar_lamp': () => gameState.tools.solar_lamp > 0,
                'sprinkler': () => gameState.sprinklers > 0,
                'greenhouse': () => gameState.greenhouses > 0,
                'chicken': () => gameState.animals > 0
            };
            
            // Update tool buttons
            const toolButtons = {
                'watering_can': document.getElementById('tool-watering-can'),
                'pesticide': document.getElementById('tool-pesticide'),
                'solar_lamp': document.getElementById('tool-solar-lamp'),
                'shovel': document.getElementById('tool-shovel')
            };
            
            Object.keys(toolButtons).forEach(toolType => {
                const button = toolButtons[toolType];
                if (button) {
                    const shouldBeActive = defaultActiveItems.includes(toolType) || 
                                         (purchaseRequirements[toolType] && purchaseRequirements[toolType]());
                    
                    if (shouldBeActive) {
                        button.classList.remove('disabled', 'disabled-overlay');
                        button.style.pointerEvents = 'auto';
                        button.style.opacity = '1';
                    } else {
                        button.classList.add('disabled', 'disabled-overlay');
                        button.style.pointerEvents = 'none';
                        button.style.opacity = '0.4';
                    }
                }
            });
            
            // Update inventory items
            const inventoryItems = {
                'sprinkler': document.getElementById('item-sprinkler'),
                'greenhouse': document.getElementById('item-greenhouse'),
                'chicken': document.getElementById('item-chicken')
            };
            
            Object.keys(inventoryItems).forEach(itemType => {
                const item = inventoryItems[itemType];
                if (item) {
                    const shouldBeActive = purchaseRequirements[itemType] && purchaseRequirements[itemType]();
                    
                    if (shouldBeActive) {
                        item.classList.remove('disabled', 'disabled-overlay');
                    } else {
                        item.classList.add('disabled', 'disabled-overlay');
                    }
                }
            });
        }
        
        // UPDATE SHOP BUTTON STATES
        function updateShopButtons() {
            const buttons = document.querySelectorAll('.shop-button');
            console.log(`ðŸ›’ Updating ${buttons.length} shop buttons. Current coins: ${gameState.coins}`);
            
            buttons.forEach(button => {
                const onclick = button.getAttribute('onclick');
                if (onclick) {
                    // Extract cost from onclick (e.g. "buyItem('apple-seeds', 15, 3)")
                    const match = onclick.match(/buyItem\('([^']+)', (\d+), \d+\)/);
                    if (match) {
                        const itemType = match[1];
                        const cost = parseInt(match[2]);
                        const canAfford = gameState.coins >= cost;
                        
                        if (!canAfford) {
                            button.disabled = true;
                            button.style.opacity = '0.5';
                            console.log(`ðŸ”’ Disabled ${itemType} (cost: ${cost}, have: ${gameState.coins})`);
                        } else {
                            button.disabled = false;
                            button.style.opacity = '1';
                            console.log(`âœ… Enabled ${itemType} (cost: ${cost}, have: ${gameState.coins})`);
                        }
                    }
                }
            });
        }
        
        // =============================================================================
        // NEW: UI UPDATE FUNCTIONS
        // =============================================================================
        
        // Update tool UI to show selection and counts
        function updateToolUI() {
            // Update tool counts
            document.getElementById('tool-watering-count').textContent = gameState.tools.watering_can;
            document.getElementById('tool-pesticide-count').textContent = gameState.tools.pesticide;
            document.getElementById('tool-solar-count').textContent = gameState.tools.solar_lamp;
            document.getElementById('tool-shovel-count').textContent = gameState.tools.shovel;
            
            // Update selected tool display
            const selectedDisplay = document.getElementById('selected-tool-display');
            selectedDisplay.textContent = gameState.selectedTool ? 
                gameState.selectedTool.replace('_', ' ').toLowerCase() : 'None';
            
            // Update button states
            const buttons = document.querySelectorAll('.tool-button');
            buttons.forEach(button => {
                const toolType = button.id.replace('tool-', '').replace('-', '_');
                
                // Remove selected class from all buttons
                button.classList.remove('selected');
                
                // Add selected class to current tool
                if (gameState.selectedTool === toolType) {
                    button.classList.add('selected');
                }
                
                // Disable button if no tools available
                if (gameState.tools[toolType] <= 0) {
                    button.disabled = true;
                } else {
                    button.disabled = false;
                }
            });
        }
        
        // =============================================================================
        // NOTIFICATIONS
        // =============================================================================
        
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        // =============================================================================
        // INTRO SYSTEM
        // =============================================================================
        
        function showIntroPopup2() {
            document.getElementById('intro-popup-1').style.display = 'none';
            document.getElementById('intro-popup-2').style.display = 'flex';
        }
        
        // Garden background music system
        let gardenBackgroundMusic = null;
        
        function initializeGardenBackgroundMusic() {
            if (!gardenBackgroundMusic) {
                gardenBackgroundMusic = new Audio('assets/Audios/background.mp3');
                gardenBackgroundMusic.loop = true;
                gardenBackgroundMusic.volume = 0.3; // Lower volume for background
                
                gardenBackgroundMusic.addEventListener('canplay', () => {
                    console.log('ðŸŽµ Garden background music ready');
                });
                
                gardenBackgroundMusic.addEventListener('error', (e) => {
                    console.error('ðŸŽµ Garden background music error:', e);
                });
            }
        }
        
        function startGardenBackgroundMusic() {
            if (gardenBackgroundMusic && !gameState.focusMode.isActive) {
                gardenBackgroundMusic.play().then(() => {
                    console.log('ðŸŽµ Garden background music started');
                }).catch(e => {
                    console.error('ðŸŽµ Garden background music play error:', e);
                });
            }
        }
        
        function stopGardenBackgroundMusic() {
            if (gardenBackgroundMusic) {
                gardenBackgroundMusic.pause();
                gardenBackgroundMusic.currentTime = 0;
                console.log('ðŸŽµ Garden background music stopped');
            }
        }
        
        function startGame() {
            document.getElementById('intro-popup-2').style.display = 'none';
            gameState.gameStarted = true;
            
            // NEW: Initialize live geolocation weather system
            updateLiveWeather();
            setInterval(updateLiveWeather, 60000); // Update weather every minute
            
            // Initialize enhancement features
            updateShopButtons();
            createWeatherEffects(gameState.weather.condition);
            
            // Initialize and start garden background music
            initializeGardenBackgroundMusic();
            startGardenBackgroundMusic();
            
            showPurchaseNotification('ðŸŒ± Welcome to your new garden!');
            
            // NEW: Show debug mode status
            if (CONFIG.DEBUG_MODE) {
                showPurchaseNotification('ðŸ› Debug mode enabled!');
            }
        }
        
        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        
        function initializeGrid() {
            gameState.grid = [];
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    gameState.grid[y][x] = new Tile(x, y);
                }
            }
        }
        
        // =============================================================================
        // ENHANCED DRAWING SYSTEM
        // =============================================================================
        
        // NEW: Main grid drawing function with enhanced visuals
        function drawGrid() {
                    // Note: Camera zoom is now handled by CSS transform on game-container
            
            // Draw tiles row by row for proper isometric layering
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    const tile = gameState.grid[y][x];
                    const screenPos = worldToScreen(x, y);
                    
                    // Draw tile base
                    drawTile(screenPos.x, screenPos.y, tile, x, y);
                    
                    // Draw crop if exists with enhanced status system
                    if (tile.crop) {
                        drawCropWithStatus(screenPos.x, screenPos.y, tile.crop);
                    }
                    
                    // Draw tool cursor if tool is selected
                    drawToolCursor(screenPos.x, screenPos.y, tile);
                }
            }
            
            // Draw selected tile highlight
            if (gameState.selectedTile) {
                drawTileSelection();
            }
            
            // Note: Camera zoom is now handled by CSS transform on game-container
        }
        
        // NEW: Enhanced tile drawing (transparent for background image)
        function drawTile(screenX, screenY, tile, tileX, tileY) {
            push();
            
            // Make tiles completely transparent so background image shows through
            noFill(); // No fill - completely transparent
            noStroke(); // No stroke by default
            
            // Only show subtle outline on hover for feedback
            const worldPos = screenToWorld(mouseX, mouseY);
            const hoverX = Math.floor(worldPos.x);
            const hoverY = Math.floor(worldPos.y);
            
            // Show very subtle hover highlight
            if (isValidTile(hoverX, hoverY) && hoverX === tileX && hoverY === tileY) {
                stroke(255, 255, 255, 150); // Subtle white outline on hover
                strokeWeight(2);
                
                // Isometric diamond outline for hover feedback
                beginShape();
                vertex(screenX, screenY - CONFIG.TILE_HEIGHT / 2);
                vertex(screenX + CONFIG.TILE_WIDTH / 2, screenY);
                vertex(screenX, screenY + CONFIG.TILE_HEIGHT / 2);
                vertex(screenX - CONFIG.TILE_WIDTH / 2, screenY);
                endShape(CLOSE);
            }
            
            pop();
        }
        
        // NEW: Enhanced crop drawing with status system
        function drawCropWithStatus(screenX, screenY, crop) {
            if (!crop) return;
            
            const cropColor = crop.getColor();
            const size = crop.getSize();
            const cropX = screenX;
            const cropY = screenY + CONFIG.TILE_HEIGHT / 4;
            
            push();
            
            // ENHANCED: Apply plant health visual effects
            let tintAlpha = 255;
            
            // Apply status-based tinting
            if (crop.hasYellowTint && !crop.isDead) {
                // Yellow tint for sick plants with conditions
                tint(255, 255, 100, tintAlpha);
            } else if (crop.isDead) {
                // Gray tint for dead plants
                tint(100, 100, 100, tintAlpha);
            } else {
                // Normal tint for healthy plants
                tint(255, 255, 255, tintAlpha);
            }
            
            // ENHANCED: Apply health status visual effects
            if (crop.visualEffects) {
                // Apply flash effect for warning/sick plants
                if (crop.visualEffects.flashIntensity > 0) {
                    const flashColor = color(255, 0, 0, crop.visualEffects.flashIntensity * 255);
                    tint(255, 255 - crop.visualEffects.flashIntensity * 100, 255 - crop.visualEffects.flashIntensity * 100, tintAlpha);
                }
                
                // Apply desaturation for dead plants
                if (crop.visualEffects.desaturation > 0) {
                    const grayValue = 255 * (1 - crop.visualEffects.desaturation);
                    tint(grayValue, grayValue, grayValue, tintAlpha);
                }
            }
            
            // ENHANCED: Apply shake effect for sick plants
            let shakeOffset = 0;
            if (crop.visualEffects && crop.visualEffects.shakeIntensity > 0) {
                shakeOffset = crop.visualEffects.shakeIntensity;
                translate(shakeOffset, 0);
            }
            
            // PLANT ANIMATION: Gentle sway for healthy plants (only if not shaking)
            if (crop.health > 50 && (!crop.visualEffects || crop.visualEffects.shakeIntensity === 0)) {
                translate(cropX, cropY);
                rotate(sin(frameCount * 0.02 + crop.x * 0.5) * 0.05); // Gentle sway
                translate(-cropX, -cropY);
            }
            
            // PLANT ANIMATION: Pulse when growing
            let animationScale = 1.0;
            if (frameCount % 300 < 30) { // Growth pulse every 5 seconds
                animationScale = 1.0 + sin(frameCount * 0.3) * 0.1;
            }
            
            // Try to draw PNG sprite, fallback to original graphics
            if (crop.type === 'apple' && gameState.loadedAssets) {
                const assetKey = `apple_stage_${crop.stage + 1}`;
                const appleSprite = gameState.loadedAssets[assetKey];
                
                // DEBUG: Log which stage is being drawn
                if (CONFIG.DEBUG_MODE && frameCount % 120 === 0) { // Log every 2 seconds
                    console.log(`ðŸŽ¨ DRAWING ${crop.type}(${crop.x},${crop.y}): stage=${crop.stage}, assetKey=${assetKey}, spriteExists=${!!appleSprite}, spriteValid=${!!(appleSprite && appleSprite.width > 0)}`);
                }
                
                if (appleSprite && appleSprite.width > 0) {
                    // Calculate sprite size based on tile size (increased scale)
                    const spriteScale = (size * 8) / appleSprite.width * animationScale;
                    const spriteWidth = appleSprite.width * spriteScale;
                    const spriteHeight = appleSprite.height * spriteScale;
                    
                    // Position sprite based on growth stage - moved up to sit within grid boxes
                    let spriteY;
                    if (crop.stage === crop.maxStage || crop.stage === crop.maxStage - 1) {
                        // Stage 4 & 5: Move up to sit within the box
                        spriteY = cropY - spriteHeight / 2 - 25;
                    } else {
                        // Other stages: Move up more to sit within the box
                        spriteY = cropY - spriteHeight / 2 - 40;
                    }
                    
                    image(appleSprite, 
                          cropX - spriteWidth / 2,  // Center horizontally
                          spriteY,     // Stage-specific vertical positioning
                          spriteWidth, 
                          spriteHeight);
                } else {
                    // Fallback to original placeholder graphics
                    noTint();
                    fill(cropColor);
                    noStroke();
                    const animatedSize = size * animationScale;
                    ellipse(cropX, cropY, animatedSize, animatedSize);
                    if (crop.stage === crop.maxStage) {
                        fill(255, 0, 0);
                        ellipse(cropX, cropY, animatedSize * 0.8, animatedSize * 0.8);
                    }
                }
            } else if (crop.type === 'carrot') {
                noTint();
                fill(cropColor);
                noStroke();
                const animatedSize = size * animationScale;
                triangle(
                    cropX, cropY - animatedSize / 2,
                    cropX - animatedSize / 2, cropY + animatedSize / 2,
                    cropX + animatedSize / 2, cropY + animatedSize / 2
                );
            } else {
                // Default drawing for other crop types
                noTint();
                fill(cropColor);
                noStroke();
                const animatedSize = size * animationScale;
                ellipse(cropX, cropY, animatedSize, animatedSize);
            }
            
            pop();
            
            // NEW: Draw floating status emoji with animation
            if (crop.statusEmoji) {
                drawFloatingEmoji(cropX, cropY - 40, crop.statusEmoji);
            }
            
            // NEW: Draw status ring around plant
            if (CONFIG.DEBUG_MODE || crop.tintColor !== 'healthy') {
                drawStatusRing(cropX, cropY, crop, size + 20);
            }
            
            // NEW: Draw condition icon above plant
            drawConditionIcon(cropX, cropY - size/2 - 30, crop);
        }
        
        // NEW: Draw condition icon above plant
        function drawConditionIcon(x, y, crop) {
            if (crop.conditionIcon && crop.currentCondition !== null) {
                push();
                
                // Create floating effect
                const bounce = sin(frameCount * 0.1) * 3;
                
                // Draw background circle for better visibility
                fill(255, 255, 255, 200);
                stroke(0, 0, 0, 100);
                strokeWeight(1);
                ellipse(x, y + bounce, 24, 24);
                
                // Draw condition icon
                fill(0);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(14);
                text(crop.conditionIcon, x, y + bounce);
                
                pop();
            }
        }

        // NEW: Floating emoji animation
        function drawFloatingEmoji(x, y, emoji) {
            push();
            
            // Gentle bounce animation
            const bounce = sin(frameCount * 0.1) * 3;
            
            if (emoji === 'APPLE_IMAGE' && appleImage) {
                // Draw custom apple image
                const size = 20; // Size of the apple icon
                imageMode(CENTER);
                image(appleImage, x, y + bounce, size, size);
            } else if (emoji === 'WATER_IMAGE' && waterImage) {
                // Draw custom water image
                const size = 20; // Size of the water icon
                imageMode(CENTER);
                image(waterImage, x, y + bounce, size, size);
            } else {
                // Draw regular emoji text
                fill(255);
                textAlign(CENTER);
                textSize(16);
                let displayEmoji = emoji;
                if (emoji === 'APPLE_IMAGE') displayEmoji = 'ðŸŽ';
                if (emoji === 'WATER_IMAGE') displayEmoji = 'ðŸ’§';
                text(displayEmoji, x, y + bounce);
            }
            
            pop();
        }
        
        // NEW: Status ring system
        function drawStatusRing(x, y, crop, ringSize) {
            push();
            noFill();
            strokeWeight(2);
            
            let ringColor;
            if (crop.tintColor === 'healthy') {
                ringColor = color(39, 174, 96, 150); // Green
            } else if (crop.tintColor === 'attention') {
                ringColor = color(243, 156, 18, 150); // Yellow
            } else if (crop.tintColor === 'sick') {
                ringColor = color(231, 76, 60, 150); // Red
            } else {
                ringColor = color(127, 140, 141, 150); // Gray
            }
            
            stroke(ringColor);
            
            // Pulsing animation
            const pulse = 1 + sin(frameCount * 0.1) * 0.1;
            ellipse(x, y, ringSize * pulse, ringSize * pulse);
            
            pop();
        }
        
        // NEW: Tool cursor system
        function drawToolCursor(screenX, screenY, tile) {
            if (!gameState.selectedTool || !tile.crop) return;
            
            // Check if mouse is over this tile
            const worldPos = screenToWorld(mouseX, mouseY);
            if (Math.floor(worldPos.x) === tile.x && Math.floor(worldPos.y) === tile.y) {
                push();
                
                // Change cursor appearance based on tool
                let cursorEmoji = 'ðŸ”§';
                let canUse = false;
                
                switch(gameState.selectedTool) {
                    case 'watering_can':
                        cursorEmoji = 'ðŸª£';
                        canUse = tile.crop && tile.crop.currentCondition === 'water';
                        break;
                    case 'pesticide':
                        cursorEmoji = 'ðŸ§ª';
                        canUse = tile.crop && tile.crop.currentCondition === 'pests';
                        break;
                    case 'solar_lamp':
                        cursorEmoji = 'â˜€ï¸'; // Will show sun cursor
                        canUse = tile.crop && tile.crop.currentCondition === 'sunlight';
                        break;
                }
                
                // Draw tool cursor with availability indicator
                fill(canUse ? color(100, 255, 100, 180) : color(255, 100, 100, 180));
                ellipse(screenX, screenY, 50, 25);
                
                fill(255);
                textAlign(CENTER);
                textSize(20);
                text(cursorEmoji, screenX, screenY + 5);
                
                pop();
            }
        }
        
        // NEW: Selected tile highlight
        function drawTileSelection() {
            if (!gameState.selectedTile) return;
            
            const screenPos = worldToScreen(gameState.selectedTile.x, gameState.selectedTile.y);
            
            push();
            noFill();
            stroke(255, 255, 0);
            strokeWeight(3);
            
            // Pulsing selection highlight
            const pulse = 1 + sin(frameCount * 0.2) * 0.2;
            
            beginShape();
            vertex(screenPos.x, screenPos.y - CONFIG.TILE_HEIGHT / 2 * pulse);
            vertex(screenPos.x + CONFIG.TILE_WIDTH / 2 * pulse, screenPos.y);
            vertex(screenPos.x, screenPos.y + CONFIG.TILE_HEIGHT / 2 * pulse);
            vertex(screenPos.x - CONFIG.TILE_WIDTH / 2 * pulse, screenPos.y);
            endShape(CLOSE);
            
            pop();
        }
        
        // =============================================================================
        // NEW: TOOL SELECTION SYSTEM
        // =============================================================================
        
        // Handle tool selection from UI
        function selectTool(toolType) {
            console.log(`ðŸ”§ Tool selection attempt: ${toolType}, Available: ${gameState.tools[toolType]}`);
            if (gameState.tools[toolType] > 0) {
                gameState.selectedTool = gameState.selectedTool === toolType ? null : toolType;
                console.log(`ðŸ”§ Selected tool: ${gameState.selectedTool}`);
                updateToolUI();
                showPurchaseNotification(`ðŸ”§ Selected: ${toolType.replace('_', ' ')}`);
                
                // Special message for shovel
                if (toolType === 'shovel') {
                    showPurchaseNotification(`ðŸ—¡ï¸ Shovel selected! Left-click on apple trees to dig them up.`);
                }
            } else {
                showPurchaseNotification(`âŒ No ${toolType.replace('_', ' ')} available!`);
            }
        }
        
        // Use tool on tile
        function useTool(tile) {
            if (!gameState.selectedTool || !tile.crop) return false;
            
            const toolConfig = CONFIG.TOOL_EFFECTS[gameState.selectedTool];
            if (!toolConfig) return false;
            
            // Check cost
            if (gameState.coins < toolConfig.cost) {
                showPurchaseNotification(`âŒ Need ${toolConfig.cost} coins!`);
                return false;
            }
            
            // Use tool on crop
            const success = tile.crop.useTool(gameState.selectedTool);
            
            if (success) {
                // Deduct cost
                gameState.coins -= toolConfig.cost;
                
                // Add visual feedback
                addToolAnimation(tile.x, tile.y, gameState.selectedTool);
                
                // Update UI
                updateAllUI();
                
                console.log(`Used ${gameState.selectedTool} on crop at (${tile.x}, ${tile.y})`);
                return true;
            }
            
            return false;
        }
        
        // NEW: Tool animation effects
        function addToolAnimation(tileX, tileY, toolType) {
            const screenPos = worldToScreen(tileX, tileY);
            
            // Create animation element
            const animElement = document.createElement('div');
            animElement.style.position = 'fixed';
            animElement.style.left = screenPos.x + 'px';
            animElement.style.top = screenPos.y + 'px';
            animElement.style.fontSize = '24px';
            animElement.style.pointerEvents = 'none';
            animElement.style.zIndex = '1000';
            
            switch(toolType) {
                case 'watering_can':
                    animElement.innerHTML = getWaterIconForDOM('large');
                    animElement.style.animation = 'waterDrop 1s ease-out forwards';
                    break;
                case 'pesticide':
                    animElement.textContent = 'âœ¨';
                    animElement.style.animation = 'sparkle 1s ease-out forwards';
                    break;
                case 'solar_lamp':
                    animElement.innerHTML = '<img src="assets/sun.png" alt="Solar Lamp" style="width: 20px; height: 20px;">';
                    animElement.style.animation = 'sunbeamPulse 1s ease-out forwards';
                    break;
                case 'shovel':
                    animElement.textContent = 'ðŸ—¡ï¸';
                    animElement.style.animation = 'removeTree 1.2s ease-out forwards';
                    break;
            }
            
            document.body.appendChild(animElement);
            
            setTimeout(() => {
                if (animElement.parentNode) {
                    animElement.parentNode.removeChild(animElement);
                }
            }, 1000);
        }
        
        // =============================================================================
        // ENHANCED WEATHER SYSTEM
        // =============================================================================
        
        // NEW: Update weather with enhanced API integration
        async function updateEnhancedWeather() {
            const now = Date.now();
            
            // Only update from API every 5 minutes
            if (now - gameState.weather.lastApiUpdate < CONFIG.WEATHER_UPDATE_INTERVAL) {
                return;
            }
            
            try {
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=San Francisco&appid=${CONFIG.WEATHER_API_KEY}&units=metric`);
                const data = await response.json();
                
                // Enhanced weather mapping
                const weatherMap = {
                    'clear sky': { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                    'few clouds': { condition: 'Sunny', icon: 'â›…' },
                    'scattered clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'broken clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'overcast clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'shower rain': { condition: 'Rain', icon: 'ðŸŒ§ï¸' },
                    'rain': { condition: 'Rain', icon: 'ðŸŒ§ï¸' },
                    'thunderstorm': { condition: 'Rain', icon: 'â›ˆï¸' },
                    'snow': { condition: 'Snow', icon: 'â„ï¸' },
                    'mist': { condition: 'Cloudy', icon: 'ðŸŒ«ï¸' }
                };
                
                const weather = weatherMap[data.weather[0].description] || { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' };
                
                gameState.weather = {
                    condition: weather.condition,
                    temperature: Math.round(data.main.temp),
                    humidity: data.main.humidity,
                    pollution: Math.random() > 0.7 ? 'High' : 'Low',
                    soilQuality: 'Rich',
                    icon: weather.icon,
                    lastApiUpdate: now
                };
                
                console.log('ðŸŒ¤ï¸ Weather updated from API:', gameState.weather);
                showPurchaseNotification(`ðŸŒ¤ï¸ Weather: ${weather.condition} ${weather.icon}`);
                
            } catch (error) {
                console.log('âš ï¸ Weather API failed, using simulation:', error);
                simulateEnhancedWeather();
            }
            
            // Update all UI elements
            updateWeatherUI();
            createWeatherEffects(gameState.weather.condition);
        }
        
        // =============================================================================
        // ENHANCED GEOLOCATION WEATHER SYSTEM
        // =============================================================================

        // NEW: Geolocation-based weather system
        async function getCurrentLocationWeather() {
            try {
                // Get user's current position
                const position = await new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        reject(new Error('Geolocation not supported'));
                        return;
                    }
                    
                    navigator.geolocation.getCurrentPosition(
                        resolve,
                        reject,
                        { timeout: 10000, enableHighAccuracy: true }
                    );
                });
                
                const { latitude, longitude } = position.coords;
                console.log(`ðŸŒ User location: ${latitude}, ${longitude}`);
                
                // Fetch weather using coordinates
                const response = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${CONFIG.WEATHER_API_KEY}&units=metric`
                );
                
                if (!response.ok) {
                    throw new Error(`Weather API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('ðŸŒ¤ï¸ Live weather data:', data);
                
                // Map API conditions to game conditions
                const weatherCondition = mapWeatherCondition(data.weather[0].main.toLowerCase());
                const tempCondition = mapTemperatureCondition(data.main.temp);
                const weatherStatus = calculateWeatherStatus(weatherCondition, tempCondition);
                
                // Enhanced weather mapping with live data
                const weatherMap = {
                    'clear sky': { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                    'few clouds': { condition: 'Partly Cloudy', icon: 'â›…' },
                    'scattered clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'broken clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'overcast clouds': { condition: 'Overcast', icon: 'â˜ï¸' },
                    'shower rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'light rain': { condition: 'Light Rain', icon: 'ðŸŒ¦ï¸' },
                    'moderate rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'heavy intensity rain': { condition: 'Heavy Rain', icon: 'ðŸŒ§ï¸' },
                    'thunderstorm': { condition: 'Stormy', icon: 'â›ˆï¸' },
                    'snow': { condition: 'Snowy', icon: 'â„ï¸' },
                    'mist': { condition: 'Foggy', icon: 'ðŸŒ«ï¸' },
                    'haze': { condition: 'Hazy', icon: 'ðŸŒ«ï¸' },
                    'dust': { condition: 'Dusty', icon: 'ðŸŒ«ï¸' }
                };
                
                const weather = weatherMap[data.weather[0].description] || 
                               { condition: data.weather[0].main, icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' };
                
                // Update game state with live weather
                gameState.weather = {
                    condition: weather.condition,
                    temperature: Math.round(data.main.temp),
                    humidity: data.main.humidity,
                    pressure: data.main.pressure,
                    windSpeed: data.wind ? Math.round(data.wind.speed * 3.6) : 0, // Convert m/s to km/h
                    cloudiness: data.clouds.all,
                    visibility: data.visibility ? Math.round(data.visibility / 1000) : 10, // Convert to km
                    location: data.name + ', ' + data.sys.country,
                    icon: weather.icon,
                    lastApiUpdate: Date.now(),
                    weatherCondition: weatherCondition,
                    tempCondition: tempCondition,
                    weatherStatus: weatherStatus,
                    description: data.weather[0].description
                };
                
                console.log('ðŸŒ¤ï¸ Live weather updated:', gameState.weather);
                showPurchaseNotification(`ðŸŒ Live Weather: ${weather.condition} in ${data.name} (${Math.round(data.main.temp)}Â°C)`);
                
                return true;
                
            } catch (error) {
                console.log('âš ï¸ Geolocation weather failed:', error);
                
                // Fallback to city-based weather if geolocation fails
                try {
                    return await getCityWeather('San Francisco'); // Fallback city
                } catch (fallbackError) {
                    console.log('âš ï¸ Fallback weather also failed:', fallbackError);
                    return false;
                }
            }
        }

        // Fallback: City-based weather
        async function getCityWeather(city = 'San Francisco') {
            try {
                const response = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${CONFIG.WEATHER_API_KEY}&units=metric`
                );
                
                if (!response.ok) {
                    throw new Error(`Weather API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Same mapping as geolocation weather
                const weatherCondition = mapWeatherCondition(data.weather[0].main.toLowerCase());
                const tempCondition = mapTemperatureCondition(data.main.temp);
                const weatherStatus = calculateWeatherStatus(weatherCondition, tempCondition);
                
                const weatherMap = {
                    'clear sky': { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                    'few clouds': { condition: 'Partly Cloudy', icon: 'â›…' },
                    'scattered clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'broken clouds': { condition: 'Cloudy', icon: 'â˜ï¸' },
                    'overcast clouds': { condition: 'Overcast', icon: 'â˜ï¸' },
                    'shower rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'light rain': { condition: 'Light Rain', icon: 'ðŸŒ¦ï¸' },
                    'moderate rain': { condition: 'Rainy', icon: 'ðŸŒ§ï¸' },
                    'heavy intensity rain': { condition: 'Heavy Rain', icon: 'ðŸŒ§ï¸' },
                    'thunderstorm': { condition: 'Stormy', icon: 'â›ˆï¸' },
                    'snow': { condition: 'Snowy', icon: 'â„ï¸' },
                    'mist': { condition: 'Foggy', icon: 'ðŸŒ«ï¸' },
                    'haze': { condition: 'Hazy', icon: 'ðŸŒ«ï¸' },
                    'dust': { condition: 'Dusty', icon: 'ðŸŒ«ï¸' }
                };
                
                const weather = weatherMap[data.weather[0].description] || 
                               { condition: data.weather[0].main, icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' };
                
                gameState.weather = {
                    condition: weather.condition,
                    temperature: Math.round(data.main.temp),
                    humidity: data.main.humidity,
                    pressure: data.main.pressure,
                    windSpeed: data.wind ? Math.round(data.wind.speed * 3.6) : 0,
                    cloudiness: data.clouds.all,
                    visibility: data.visibility ? Math.round(data.visibility / 1000) : 10,
                    location: data.name + ', ' + data.sys.country,
                    icon: weather.icon,
                    lastApiUpdate: Date.now(),
                    weatherCondition: weatherCondition,
                    tempCondition: tempCondition,
                    weatherStatus: weatherStatus,
                    description: data.weather[0].description
                };
                
                console.log('ðŸŒ¤ï¸ City weather updated:', gameState.weather);
                showPurchaseNotification(`ðŸŒ Weather: ${weather.condition} in ${data.name} (${Math.round(data.main.temp)}Â°C)`);
                
                return true;
                
            } catch (error) {
                console.log('âš ï¸ City weather failed:', error);
                return false;
            }
        }

        // Weather condition mapping functions
        function mapWeatherCondition(weatherMain) {
            const mapping = {
                'clear': 'sunny',
                'clouds': 'cloudy',
                'rain': 'rainy',
                'drizzle': 'rainy',
                'thunderstorm': 'rainy',
                'snow': 'snowy',
                'mist': 'cloudy',
                'smoke': 'cloudy',
                'haze': 'cloudy',
                'dust': 'cloudy',
                'fog': 'cloudy',
                'sand': 'cloudy',
                'ash': 'cloudy',
                'squall': 'rainy',
                'tornado': 'rainy'
            };
            
            return mapping[weatherMain] || 'sunny';
        }

        function mapTemperatureCondition(temp) {
            if (temp < 10) return 'cold';
            if (temp > 25) return 'hot';
            return 'cozy';
        }

        function calculateWeatherStatus(weatherCondition, tempCondition) {
            if (weatherCondition === 'rainy' || tempCondition === 'cold') return 'harsh';
            if (weatherCondition === 'cloudy' || tempCondition === 'hot') return 'wet';
            return 'ideal';
        }

        // NEW: Request location permission and update weather
        async function requestLocationWeather() {
            const btn = document.getElementById('location-weather-btn');
            btn.textContent = 'ðŸ”„ Getting location...';
            btn.disabled = true;
            
            try {
                const success = await getCurrentLocationWeather();
                if (success) {
                    btn.textContent = 'âœ… Live Weather Active';
                    btn.style.background = '#27ae60';
                    setTimeout(() => {
                        btn.style.display = 'none';
                    }, 2000);
                } else {
                    btn.textContent = 'âŒ Location Failed';
                    btn.style.background = '#e74c3c';
                    setTimeout(() => {
                        btn.textContent = 'ðŸŒ Try Again';
                        btn.style.background = '#3498db';
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                btn.textContent = 'âŒ Permission Denied';
                btn.style.background = '#e74c3c';
                setTimeout(() => {
                    btn.textContent = 'ðŸŒ Enable Live Weather';
                    btn.style.background = '#3498db';
                    btn.disabled = false;
                }, 3000);
            }
        }

        // NEW: Main weather update function with geolocation
        async function updateLiveWeather() {
            const now = Date.now();
            
            // Only update from API every 10 minutes (but allow forced updates)
            if (now - gameState.weather.lastApiUpdate < CONFIG.WEATHER_UPDATE_INTERVAL && gameState.weather.lastApiUpdate > 0) {
                return;
            }
            
            console.log('ðŸŒ Updating live weather...');
            
            // Try geolocation first, fallback to city weather, then simulation
            const success = await getCurrentLocationWeather();
            
            if (!success) {
                console.log('âš ï¸ All weather sources failed, using simulation');
                simulateEnhancedWeather();
            }
            
            // Update all UI elements
            updateWeatherUI();
        }
        
        // NEW: Enhanced weather simulation
        function simulateEnhancedWeather() {
            const conditions = [
                { condition: 'Sunny', icon: '<img src="assets/sun.png" alt="Sun" style="width: 20px; height: 20px;">' },
                { condition: 'Cloudy', icon: 'â˜ï¸' },
                { condition: 'Rain', icon: 'ðŸŒ§ï¸' },
                { condition: 'Snow', icon: 'â„ï¸' }
            ];
            
            const weather = conditions[Math.floor(Math.random() * conditions.length)];
            gameState.weather = {
                ...weather,
                temperature: Math.floor(Math.random() * 20) + 15,
                humidity: Math.floor(Math.random() * 40) + 40,
                pollution: Math.random() > 0.8 ? 'High' : 'Low',
                soilQuality: 'Rich',
                lastApiUpdate: Date.now()
            };
            
            console.log('ðŸŒ¤ï¸ Simulated weather:', gameState.weather);
            
            // Trigger weather effects for simulated weather
            createWeatherEffects(gameState.weather.condition);
        }
        
        // DEBUG: Manual weather refresh function
        function refreshWeather() {
            console.log('ðŸ”„ Manually refreshing weather...');
            gameState.weather.lastApiUpdate = 0; // Reset cooldown
            updateLiveWeather();
            setTimeout(() => updateWeatherUI(), 1000);
        }
        
        // DEBUG: Manual weather effect testing
        function testWeatherEffect(condition) {
            console.log(`ðŸ§ª Testing weather effect: ${condition}`);
            
            // Force reset the current weather effect to ensure transition
            currentWeatherEffect = null;
            weatherTransitionInProgress = false;
            
            createWeatherEffects(condition);
            showPurchaseNotification(`ðŸŒ¤ï¸ Testing: ${condition} weather effects`);
            
            // Update the weather display to match the test
            document.getElementById('weather-condition').textContent = condition;
            
            // Update weather icon for visual consistency
            const iconMap = {
                'Sunny': '<img src="assets/sun.png" alt="Sun" style="width: 24px; height: 24px;">',
                'Rain': 'ðŸŒ§ï¸',
                'Heavy Rain': 'â›ˆï¸', 
                'Light Rain': 'ðŸŒ¦ï¸',
                'Snow': 'â„ï¸',
                'Cloudy': 'â˜ï¸',
                'Foggy': 'ðŸŒ«ï¸'
            };
            
            if (iconMap[condition]) {
                document.getElementById('weather-icon').innerHTML = iconMap[condition];
            }
        }
        
        // Clear all weather effects
        function clearWeatherEffects() {
            console.log('ðŸ§ª Clearing all weather effects');
            const overlay = document.getElementById('weather-overlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.innerHTML = '';
                    overlay.style.opacity = '1';
                }, 500);
            }
            
            // Reset weather tracking
            currentWeatherEffect = null;
            weatherTransitionInProgress = false;
            
            showPurchaseNotification('ðŸš« Weather effects cleared');
            
            // Reset weather display
            document.getElementById('weather-condition').textContent = 'Clear';
            document.getElementById('weather-icon').innerHTML = '<img src="assets/sun.png" alt="Sun" style="width: 24px; height: 24px;">';
        }
        
        // Enhanced testing with descriptions
        function showWeatherEffectInfo(condition) {
            const descriptions = {
                'Sunny': 'Bright sun glow + rotating sunbeams + warm yellow tint',
                            'Rain': 'Falling raindrops + blue atmospheric tint + subtle effects + 50 drops',
            'Heavy Rain': 'Large obvious raindrops + glow effects + dark storm atmosphere + 150 drops',
            'Light Rain': 'Gentle drizzle + slower drops + light blue tint + 30 drops',
                'Snow': 'Floating snowflakes + swirling motion + white winter tint',
                'Cloudy': 'Moving clouds + dimmed sun + gray atmosphere',
                'Foggy': 'Ground mist + slow clouds + reduced visibility'
            };
            
            if (descriptions[condition]) {
                showPurchaseNotification(`ðŸ“ ${condition}: ${descriptions[condition]}`);
            }
        }
        
        // Auto demo function to cycle through all weather effects
        function runWeatherDemo() {
            const weatherTypes = ['Sunny', 'Cloudy', 'Light Rain', 'Rain', 'Heavy Rain', 'Snow', 'Foggy'];
            let currentIndex = 0;
            
            showPurchaseNotification('ðŸŽ¬ Starting weather effects demo...');
            
            function showNextWeather() {
                if (currentIndex < weatherTypes.length) {
                    const weatherType = weatherTypes[currentIndex];
                    testWeatherEffect(weatherType);
                    showPurchaseNotification(`ðŸŽ¬ Demo ${currentIndex + 1}/${weatherTypes.length}: ${weatherType}`);
                    currentIndex++;
                    
                    // Show each effect for 4 seconds
                    setTimeout(showNextWeather, 4000);
                } else {
                    // Demo finished, clear effects
                    setTimeout(() => {
                        clearWeatherEffects();
                        showPurchaseNotification('ðŸŽ¬ Demo complete! All weather effects previewed.');
                    }, 2000);
                }
            }
            
            // Start the demo
            showNextWeather();
        }
        
        // Keyboard shortcuts for quick testing
        function handleWeatherShortcuts(event) {
            if (event.altKey) { // Alt + key combinations
                switch(event.key) {
                    case '1': testWeatherEffect('Sunny'); event.preventDefault(); break;
                    case '2': testWeatherEffect('Rain'); event.preventDefault(); break;
                    case '3': testWeatherEffect('Snow'); event.preventDefault(); break;
                    case '4': testWeatherEffect('Cloudy'); event.preventDefault(); break;
                    case '5': testWeatherEffect('Foggy'); event.preventDefault(); break;
                    case '0': clearWeatherEffects(); event.preventDefault(); break;
                    case 'd': runWeatherDemo(); event.preventDefault(); break;
                }
            }
        }
        
        // Add keyboard event listener
        document.addEventListener('keydown', handleWeatherShortcuts);
        
        // Make weather testing available globally for console testing
        window.testWeather = testWeatherEffect;
        window.clearWeather = clearWeatherEffects;
        window.weatherInfo = showWeatherEffectInfo;
        window.weatherDemo = runWeatherDemo;
        
        // Responsive scaling testing functions
        window.getScaleInfo = () => {
            return {
                scaleFactor: currentScaleFactor,
                tileSize: `${CONFIG.TILE_WIDTH.toFixed(1)}x${CONFIG.TILE_HEIGHT.toFixed(1)}`,
                containerSize: `${document.getElementById('game-container').offsetWidth}x${document.getElementById('game-container').offsetHeight}`,
                gridOffset: `${gridOffsetX.toFixed(1)}, ${gridOffsetY.toFixed(1)}`
            };
        };
        window.forceScaleUpdate = () => {
            updateResponsiveScaling();
            showPurchaseNotification(`ðŸ”§ Scale recalculated: ${currentScaleFactor.toFixed(3)}x`);
        };
        
        // Pomodoro testing functions
        window.pomodoroDebug = {
            getState: () => gameState.pomodoro,
            start: () => startPomodoroTimer(),
            pause: () => pausePomodoroTimer(),
            resume: () => resumePomodoroTimer(),
            skip: () => skipPomodoroSession(),
            reset: () => resetPomodoroTimer(),
            complete: () => completePomodoroSession()
        };
        
        // =============================================================================
        // ZOOM AND PAN SYSTEM
        // =============================================================================
        
        let zoomPanState = {
            scale: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            isMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            minZoom: 0.5,
            maxZoom: 3
        };
        
        function initializeZoomPan() {
            const gameContainer = document.getElementById('game-container');
            const viewport = document.getElementById('grid-viewport');
            
            // Center the initial view
            const centerX = (window.innerWidth - CONFIG.CANVAS_WIDTH * zoomPanState.scale) / 2;
            const centerY = (window.innerHeight - CONFIG.CANVAS_HEIGHT * zoomPanState.scale) / 2;
            zoomPanState.translateX = centerX;
            zoomPanState.translateY = centerY;
            updateViewportTransform();
            
            // Mouse wheel zoom
            gameContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const rect = gameContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(zoomPanState.minZoom, Math.min(zoomPanState.maxZoom, zoomPanState.scale * scaleFactor));
                
                if (newScale !== zoomPanState.scale) {
                    const scaleChange = newScale / zoomPanState.scale;
                    
                    // Zoom towards mouse position
                    zoomPanState.translateX = mouseX - (mouseX - zoomPanState.translateX) * scaleChange;
                    zoomPanState.translateY = mouseY - (mouseY - zoomPanState.translateY) * scaleChange;
                    zoomPanState.scale = newScale;
                    
                    updateViewportTransform();
                }
            });
            
            // Mouse drag pan
            gameContainer.addEventListener('mousedown', (e) => {
                if (e.target === gameContainer || e.target.tagName === 'CANVAS') {
                    // Don't start dragging immediately, wait for actual movement
                    zoomPanState.isDragging = false;
                    zoomPanState.lastMouseX = e.clientX;
                    zoomPanState.lastMouseY = e.clientY;
                    zoomPanState.isMouseDown = true;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (zoomPanState.isMouseDown) {
                    const deltaX = e.clientX - zoomPanState.lastMouseX;
                    const deltaY = e.clientY - zoomPanState.lastMouseY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Only start dragging if we've moved more than 3 pixels
                    if (!zoomPanState.isDragging && distance > 3) {
                        zoomPanState.isDragging = true;
                        gameContainer.style.cursor = 'grabbing';
                    }
                    
                    if (zoomPanState.isDragging) {
                        zoomPanState.translateX += deltaX;
                        zoomPanState.translateY += deltaY;
                        updateViewportTransform();
                    }
                    
                    zoomPanState.lastMouseX = e.clientX;
                    zoomPanState.lastMouseY = e.clientY;
                }
            });
            
            document.addEventListener('mouseup', () => {
                zoomPanState.isMouseDown = false;
                if (zoomPanState.isDragging) {
                    zoomPanState.isDragging = false;
                    gameContainer.style.cursor = 'grab';
                }
            });
            
            // Enhanced touch support for mobile (gardening game style)
            let touchStartDistance = 0;
            let touchStartScale = 1;
            let touchStartCenter = { x: 0, y: 0 };
            let lastTouchCount = 0;
            
            gameContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                lastTouchCount = e.touches.length;
                
                if (e.touches.length === 2) {
                    // Two finger zoom
                    touchStartDistance = getTouchDistance(e.touches[0], e.touches[1]);
                    touchStartScale = zoomPanState.scale;
                    
                    // Store the center point for zoom focus
                    touchStartCenter.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    touchStartCenter.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    zoomPanState.isDragging = false; // Stop any pan gesture
                } else if (e.touches.length === 1) {
                    // Single finger pan (only if not transitioning from two fingers)
                    setTimeout(() => {
                        if (e.touches.length === 1) {
                            zoomPanState.isDragging = true;
                            zoomPanState.lastMouseX = e.touches[0].clientX;
                            zoomPanState.lastMouseY = e.touches[0].clientY;
                        }
                    }, 100); // Small delay to prevent accidental pan after pinch
                }
            });
            
            gameContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 2) {
                    // Two finger zoom (like gardening games)
                    const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                    const currentCenter = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };
                    
                    // Calculate zoom
                    const scaleRatio = currentDistance / touchStartDistance;
                    const newScale = Math.max(zoomPanState.minZoom, 
                                            Math.min(zoomPanState.maxZoom, touchStartScale * scaleRatio));
                    
                    if (Math.abs(newScale - zoomPanState.scale) > 0.01) {
                        // Zoom towards the center of the pinch gesture
                        const rect = gameContainer.getBoundingClientRect();
                        const focusX = touchStartCenter.x - rect.left;
                        const focusY = touchStartCenter.y - rect.top;
                        
                        const scaleChange = newScale / zoomPanState.scale;
                        zoomPanState.translateX = focusX - (focusX - zoomPanState.translateX) * scaleChange;
                        zoomPanState.translateY = focusY - (focusY - zoomPanState.translateY) * scaleChange;
                        zoomPanState.scale = newScale;
                        
                        updateViewportTransform();
                    }
                    
                    // Allow panning while pinching (common in gardening games)
                    const centerDeltaX = currentCenter.x - touchStartCenter.x;
                    const centerDeltaY = currentCenter.y - touchStartCenter.y;
                    
                    if (Math.abs(centerDeltaX) > 5 || Math.abs(centerDeltaY) > 5) {
                        zoomPanState.translateX += centerDeltaX * 0.5; // Damped movement
                        zoomPanState.translateY += centerDeltaY * 0.5;
                        touchStartCenter = currentCenter;
                        updateViewportTransform();
                    }
                    
                } else if (e.touches.length === 1 && zoomPanState.isDragging && lastTouchCount === 1) {
                    // Single finger pan
                    const deltaX = e.touches[0].clientX - zoomPanState.lastMouseX;
                    const deltaY = e.touches[0].clientY - zoomPanState.lastMouseY;
                    
                    zoomPanState.translateX += deltaX;
                    zoomPanState.translateY += deltaY;
                    
                    zoomPanState.lastMouseX = e.touches[0].clientX;
                    zoomPanState.lastMouseY = e.touches[0].clientY;
                    
                    updateViewportTransform();
                }
                
                lastTouchCount = e.touches.length;
            });
            
            gameContainer.addEventListener('touchend', (e) => {
                if (e.touches.length === 0) {
                    zoomPanState.isDragging = false;
                    lastTouchCount = 0;
                } else {
                    lastTouchCount = e.touches.length;
                }
            });
            
            // Keyboard shortcuts for zoom control
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch(e.key) {
                    case '+':
                    case '=':
                        e.preventDefault();
                        zoomIn();
                        break;
                    case '-':
                    case '_':
                        e.preventDefault();
                        zoomOut();
                        break;
                    case '0':
                        e.preventDefault();
                        resetZoom();
                        break;
                }
            });
        }
        
        // Zoom control functions
        function zoomIn() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const scaleFactor = 1.2;
            const newScale = Math.min(zoomPanState.maxZoom, zoomPanState.scale * scaleFactor);
            
            if (newScale !== zoomPanState.scale) {
                const scaleChange = newScale / zoomPanState.scale;
                zoomPanState.translateX = centerX - (centerX - zoomPanState.translateX) * scaleChange;
                zoomPanState.translateY = centerY - (centerY - zoomPanState.translateY) * scaleChange;
                zoomPanState.scale = newScale;
                updateViewportTransform();
            }
        }
        
        function zoomOut() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const scaleFactor = 0.8;
            const newScale = Math.max(zoomPanState.minZoom, zoomPanState.scale * scaleFactor);
            
            if (newScale !== zoomPanState.scale) {
                const scaleChange = newScale / zoomPanState.scale;
                zoomPanState.translateX = centerX - (centerX - zoomPanState.translateX) * scaleChange;
                zoomPanState.translateY = centerY - (centerY - zoomPanState.translateY) * scaleChange;
                zoomPanState.scale = newScale;
                updateViewportTransform();
            }
        }
        
        function resetZoom() {
            zoomPanState.scale = 1;
            const centerX = (window.innerWidth - CONFIG.CANVAS_WIDTH * zoomPanState.scale) / 2;
            const centerY = (window.innerHeight - CONFIG.CANVAS_HEIGHT * zoomPanState.scale) / 2;
            zoomPanState.translateX = centerX;
            zoomPanState.translateY = centerY;
            updateViewportTransform();
        }
        
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function updateViewportTransform() {
            const viewport = document.getElementById('grid-viewport');
            if (viewport) {
                // Temporarily disable transform to test basic functionality
                // viewport.style.transform = `translate(${zoomPanState.translateX}px, ${zoomPanState.translateY}px) scale(${zoomPanState.scale})`;
                viewport.style.transform = 'none';
            }
            
            // Update zoom indicator
            const zoomIndicator = document.getElementById('zoom-indicator');
            if (zoomIndicator) {
                const zoomLevel = zoomIndicator.querySelector('.zoom-level');
                if (zoomLevel) {
                    zoomLevel.textContent = `Zoom: ${Math.round(zoomPanState.scale * 100)}% (DISABLED)`;
                }
            }
        }
        
        // Update mouse coordinates for P5.js based on zoom/pan
        function getTransformedMouseCoords() {
            // Temporarily disable transformation to test basic functionality
            // TODO: Fix coordinate transformation properly
            return { x: mouseX, y: mouseY };
            
            // The CSS transform on the viewport affects how P5.js interprets mouse coordinates
            // Since the viewport has: transform: translate(tx, ty) scale(s)
            // P5.js mouse coordinates are already affected by this transform
            // We need to reverse it to get the logical canvas coordinates
            
            // Get mouse position relative to the transformed canvas
            // The transform is applied as: translate then scale
            // To reverse: (mousePos / scale) - (translate / scale)
            
            // const logicalX = mouseX / zoomPanState.scale - zoomPanState.translateX / zoomPanState.scale;
            // const logicalY = mouseY / zoomPanState.scale - zoomPanState.translateY / zoomPanState.scale;
            
            // return { x: logicalX, y: logicalY };
        }
        
        // =============================================================================
        // P5.JS MAIN FUNCTIONS
        // =============================================================================
        
        function preload() {
            console.log('âœ… P5.js Isometric Garden MVP Loading...');
            
            // Initialize assets objects
            gameState.loadedAssets = {};
            gameState.toolAssets = {};
            gameState.weatherAssets = {};
            
            // Load custom apple icon for canvas rendering
            appleImage = loadImage('assets/apple/apple.png',
                () => console.log('âœ… Loaded custom apple.png for icons'),
                () => console.log('âš ï¸ Failed to load apple.png - using fallback emoji')
            );
            
            // Load custom water image for all water effects
            waterImage = loadImage('assets/water.png',
                () => console.log('âœ… Loaded custom water.png for water effects'),
                () => console.log('âš ï¸ Failed to load water.png - using fallback emoji')
            );
            
            // Load Apple Tree PNG assets
            try {
                gameState.loadedAssets.apple_stage_1 = loadImage('assets/apple/apple_stage_01.png', 
                    () => console.log('âœ… Loaded apple_stage_01.png'),
                    () => console.log('âš ï¸ Failed to load apple_stage_01.png - using fallback graphics')
                );
                gameState.loadedAssets.apple_stage_2 = loadImage('assets/apple/apple_stage_02.png',
                    () => console.log('âœ… Loaded apple_stage_02.png'),
                    () => console.log('âš ï¸ Failed to load apple_stage_02.png - using fallback graphics')
                );
                gameState.loadedAssets.apple_stage_3 = loadImage('assets/apple/apple_stage_03.png',
                    () => console.log('âœ… Loaded apple_stage_03.png'),
                    () => console.log('âš ï¸ Failed to load apple_stage_03.png - using fallback graphics')
                );
                gameState.loadedAssets.apple_stage_4 = loadImage('assets/apple/apple_stage_04.png',
                    () => console.log('âœ… Loaded apple_stage_04.png'),
                    () => console.log('âš ï¸ Failed to load apple_stage_04.png - using fallback graphics')
                );
                gameState.loadedAssets.apple_stage_5 = loadImage('assets/apple/apple_stage_05.png',
                    () => console.log('âœ… Loaded apple_stage_05.png'),
                    () => console.log('âš ï¸ Failed to load apple_stage_05.png - using fallback graphics')
                );
                console.log('ðŸŽ Attempting to load apple tree PNG assets...');
            } catch (error) {
                console.log('âš ï¸ Apple PNG asset loading failed, using fallback graphics:', error);
            }
            
            // NEW: Load Tool Assets (with fallback handling)
            try {
                console.log('ðŸ§° Loading tool assets...');
                // For now, we'll create placeholder assets if they don't exist
                // Users can replace these with actual PNGs later
            } catch (error) {
                console.log('âš ï¸ Tool asset loading failed, using fallback graphics:', error);
            }
            
            // NEW: Load Weather Icons (with fallback handling)
            try {
                console.log('ðŸŒ¤ï¸ Loading weather assets...');
                // For now, we'll use emoji fallbacks
                // Users can replace these with actual PNGs later
            } catch (error) {
                console.log('âš ï¸ Weather asset loading failed, using fallback graphics:', error);
            }
        }
        
        function setup() {
            console.log('ðŸŽ¨ P5.js setup() function called');
            console.log('ðŸ“ Canvas dimensions:', CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            console.log('ðŸŽ® GameState exists:', !!gameState);
            console.log('ðŸ”§ CONFIG exists:', !!CONFIG);
            
            const canvas = createCanvas(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            console.log('ðŸ–¼ï¸ Canvas created:', !!canvas);
            
            // Debug: Show available tools on startup
            console.log('ðŸ”§ Available tools on startup:', gameState.tools);
            
            // Create viewport wrapper for zoom/pan
            const gameContainer = document.getElementById('game-container');
            console.log('ðŸŽ¯ Game container found:', !!gameContainer);
            
            const viewport = document.createElement('div');
            viewport.id = 'grid-viewport';
            viewport.style.width = '100%';
            viewport.style.height = '100%';
            viewport.style.position = 'relative';
            gameContainer.appendChild(viewport);
            console.log('ðŸ“¦ Viewport created and added');
            
            // Parent canvas to the viewport
            canvas.parent('grid-viewport');
            console.log('ðŸ–¼ï¸ Canvas parented to viewport');
            
            // Make sure canvas is visible
            const canvasElement = document.querySelector('#grid-viewport canvas');
            if (canvasElement) {
                canvasElement.style.display = 'block';
                canvasElement.style.position = 'relative';
                canvasElement.style.zIndex = '10';
                console.log('ðŸ‘ï¸ Canvas visibility ensured');
            }
            
            // Initialize zoom and pan system
            initializeZoomPan();
            
            // Ensure assets object exists even if preload failed
            if (!gameState.loadedAssets) {
                gameState.loadedAssets = {};
                console.log('âš ï¸ Assets not loaded, using fallback graphics');
            }
            
            // Initialize responsive scaling system
            calculateResponsiveScale();
            
            initializeGrid();
            updateAllUI();
            updateWeatherUI();
            
            // AUTO-START GAME (bypass intro for now)
            gameState.gameStarted = true;
            console.log('ðŸš€ Game auto-started for testing');
            console.log('ðŸ“¦ Inventory structure:', gameState.inventory);
            console.log('ðŸŒ± Grid initialized:', !!gameState.grid, 'Size:', gameState.grid?.length);
            
            // Initialize garden background music
            initializeGardenBackgroundMusic();
            
            // Initialize live weather with geolocation
            updateLiveWeather();
            
            // Initialize weather effects with current condition
            setTimeout(() => {
                createWeatherEffects(gameState.weather.condition);
            }, 500); // Small delay to ensure weather data is available
            
            // Initialize enhancement features
            updateShopButtons();
            updateToolUI(); // NEW: Initialize tool UI
            synchronizeInventoryStates(); // NEW: Initialize inventory states
            
            // Debug: Test shop button functionality
            console.log('ðŸ›’ Shop buttons initialized. Testing affordability...');
            setTimeout(() => {
                updateShopButtons(); // Force a shop button update after setup
                console.log('ðŸ›’ Shop buttons refreshed after setup');
            }, 100);
            
            // ENHANCED: Initialize plant health system
            initializePlantHealthSystem();
            
            // Initialize Focus Mode button state
            updateFocusModeButton();
            
            // Add Focus Mode button event listener
            const focusButton = document.getElementById('focus-mode-button');
            if (focusButton) {
                focusButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('ðŸ–±ï¸ Focus Mode button clicked!');
                    toggleFocusMode();
                });
                console.log('âœ… Focus Mode button event listener added');
            } else {
                console.log('âŒ Focus Mode button not found for event listener');
            }
            
            // Add keyboard shortcut for Focus Mode (F key)
            document.addEventListener('keydown', function(e) {
                if (e.key === 'f' || e.key === 'F') {
                    console.log('âŒ¨ï¸ F key pressed - toggling Focus Mode');
                    toggleFocusMode();
                }
                if (e.key === 'Escape') {
                    console.log('âŒ¨ï¸ Escape key pressed - forcing exit Focus Mode');
                    if (gameState.focusMode.isActive) {
                        resetFocusMode();
                    }
                }
            });
            
            // Visual effects temporarily disabled
            // FocusModeVisuals.init();
            
            // Handle window resize for full-screen responsiveness
            window.addEventListener('resize', () => {
                resizeCanvas(window.innerWidth, window.innerHeight);
                CONFIG.CANVAS_WIDTH = window.innerWidth;
                CONFIG.CANVAS_HEIGHT = window.innerHeight;
                
                // Update responsive scaling for new window size
                updateResponsiveScaling();
                
                // Re-center the view
                const centerX = (window.innerWidth - CONFIG.CANVAS_WIDTH * zoomPanState.scale) / 2;
                const centerY = (window.innerHeight - CONFIG.CANVAS_HEIGHT * zoomPanState.scale) / 2;
                zoomPanState.translateX = centerX;
                zoomPanState.translateY = centerY;
                updateViewportTransform();
            });
            
            console.log('ðŸŒ± P5.js Isometric Garden MVP Enhanced Ready!');
        }
        
        function draw() {
            clear(); // Make canvas transparent so background image shows through
            
            // Debug logging (only first few frames)
            if (frameCount <= 3) {
                console.log(`ðŸŽ¬ Draw() frame ${frameCount}, gameStarted: ${gameState.gameStarted}`);
            }
            
            if (gameState.gameStarted) {
                // Update all tiles
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        gameState.grid[y][x].update();
                    }
                }
                
                drawGrid();
                drawPlantMenu();
                updatePlantStatusUI();
                
                // DEBUG: Show responsive scaling info
                if (CONFIG.DEBUG_MODE && frameCount % 180 === 0) { // Every 3 seconds
                    console.log(`ðŸ“ Current responsive scale: ${currentScaleFactor.toFixed(3)}x | Tile size: ${CONFIG.TILE_WIDTH.toFixed(1)}x${CONFIG.TILE_HEIGHT.toFixed(1)}`);
                }
                updateNarrativeUI();
                
                        // Visual effects temporarily disabled
        // FocusModeVisuals.update();
            } else {
                // Show intro screen
                fill(255);
                textAlign(CENTER);
                textSize(16);
                text('ðŸŒ± Growtopia Garden', width/2, height/2);
            }
        }
        
                    console.log('ðŸš€ P5.js Isometric Garden MVP loaded! Complete with intro, weather, and all features!');
        
        // =============================================================================
        // FOCUS MODE FUNCTIONS
        // =============================================================================
        
        // Toggle Focus Mode - Direct garden activation with transition
        function toggleFocusMode() {
            console.log('ðŸŽ¯ Toggle Focus Mode called. Current state:', gameState.focusMode.isActive);
            
            try {
                // Force toggle the state first
                const wasActive = gameState.focusMode.isActive;
                gameState.focusMode.isActive = !wasActive;
                console.log('ðŸ”„ Force toggled state from', wasActive, 'to', gameState.focusMode.isActive);
                
                // Play appropriate transition video based on mode
                if (gameState.focusMode.isActive) {
                    // Entering Focus Mode - use entry transition (zoom out)
                    playFocusModeTransition(true).then(() => {
                        completeFocusModeToggle();
                    });
                } else {
                    // Exiting Focus Mode - use exit transition (zoom in)
                    playFocusModeExitTransition().then(() => {
                        completeFocusModeToggle();
                    });
                }
                
                // Always update button immediately for responsiveness
                updateFocusModeButton();
                
                console.log('ðŸŽ¯ Focus Mode transition started:', gameState.focusMode.isActive);
            } catch (error) {
                console.error('âŒ Error in toggleFocusMode:', error);
                // Emergency reset
                resetFocusMode();
            }
        }
        
        // Complete the Focus Mode toggle after transition
        function completeFocusModeToggle() {
            try {
                if (gameState.focusMode.isActive) {
                    // Turn ON Focus Mode
                    console.log('ðŸŽ¯ Completing Focus Mode ON');
                    gameState.focusMode.isInSession = false; // Reset session state
                    
                    // Stop garden background music when entering focus mode
                    stopGardenBackgroundMusic();
                    
                    // Hide normal panels and show focus panels
                    hideNormalUIPanels();
                    showFocusModePanels();
                    
                    // Show floating timer and badge
                    showFloatingTimer();
                    const badge = document.getElementById('focus-mode-badge');
                    if (badge) badge.classList.add('active');
                    
                    // Show main garden timer panel
                    showMainGardenTimer();
                    
                    // Initialize music player
                    initializeMusicPlayer();
                    updateFocusModeDisplay();
                    
                    // Apply visual effects
                    applyFocusModeVisuals(true);
                    
                } else {
                    // Turn OFF Focus Mode
                    console.log('ðŸŽ¯ Completing Focus Mode OFF');
                    gameState.focusMode.isInSession = false;
                    
                    // Stop music and timer
                    stopMusicPlayer();
                    if (gameState.focusMode.timer.isRunning) {
                        stopTimer();
                    }
                    
                    // Start garden background music when returning to garden mode
                    startGardenBackgroundMusic();
                    
                    // Hide focus panels and show normal panels
                    hideFocusModePanels();
                    showNormalUIPanels();
                    
                    // Hide floating timer and badge
                    hideFloatingTimer();
                    const badge = document.getElementById('focus-mode-badge');
                    if (badge) badge.classList.remove('active');
                    
                    // Hide main garden timer panel
                    hideMainGardenTimer();
                    
                    // Remove visual effects
                    applyFocusModeVisuals(false);
                }
                
                console.log('ðŸŽ¯ Focus Mode toggle completed:', gameState.focusMode.isActive);
            } catch (error) {
                console.error('âŒ Error completing Focus Mode toggle:', error);
                resetFocusMode();
            }
        }
        
        // Enter Focus Mode - Switch UI panels to Focus Mode
        function enterFocusMode() {
            gameState.focusMode.isActive = true;
            
            // Load focus mode data from localStorage
            loadFocusModeData();
            
            // Hide normal UI panels
            hideNormalUIPanels();
            
            // Show Focus Mode panels
            showFocusModePanels();
            
            // Show floating timer widget
            showFloatingTimer();
            
            // Show focus badge
            document.getElementById('focus-mode-badge').classList.add('active');
            
            // Apply visual effects
            applyFocusModeVisuals(true);
            
            // Initialize Focus Mode UI
            updateFocusModeUI();
            generateStreakCalendar();
            
            // Initialize music player
            initializeMusicPlayer();
            
            // Update Focus Mode display with current data
            updateFocusModeDisplay();
            
            // Initialize or resume Pomodoro timer
            if (gameState.pomodoro.isPaused) {
                // Resume if timer was paused
                updateFocusTimerDisplay();
                updateFocusTimerControls();
                resumeFocusTimer();
            } else {
                // Initialize fresh timer
                initializeFocusTimer();
            }
            
            // Update button state
            updateFocusModeButton();
            
            console.log('ðŸŽ¯ Focus Mode activated - UI panels switched');
        }
        
        // Exit Focus Mode - Restore normal UI panels
        function exitFocusMode() {
            console.log('ðŸšª EXIT Focus Mode called');
            
            gameState.focusMode.isActive = false;
            gameState.focusMode.isInSession = false;
            console.log('ðŸšª Focus Mode state set to false');
            
            // Pause Pomodoro timer (preserve state for resume)
            if (gameState.pomodoro.isRunning) {
                console.log('ðŸ… Pausing Pomodoro timer');
                pauseFocusTimer();
            }
            
            // Stop music player
            console.log('ðŸŽµ Stopping music player');
            stopMusicPlayer();
            
            // Hide Focus Mode panels
            console.log('ðŸ«¥ Hiding Focus Mode panels');
            hideFocusModePanels();
            
            // Show normal UI panels
            console.log('ðŸ‘ï¸ Showing normal UI panels');
            showNormalUIPanels();
            
            // Hide floating timer widget
            console.log('â±ï¸ Hiding floating timer');
            hideFloatingTimer();
            
            // Hide focus badge
            console.log('ðŸ·ï¸ Hiding focus badge');
            const badge = document.getElementById('focus-mode-badge');
            if (badge) {
                badge.classList.remove('active');
            } else {
                console.log('âŒ Focus badge not found');
            }
            
            // Remove visual effects
            console.log('âœ¨ Removing visual effects');
            applyFocusModeVisuals(false);
            
            // Save focus mode data
            console.log('ðŸ’¾ Saving focus mode data');
            saveFocusModeData();
            
            // Update button state
            console.log('ðŸ”„ Updating button state');
            updateFocusModeButton();
            
            console.log('âŒ Focus Mode deactivated - UI panels restored');
        }
        
        // Emergency Focus Mode reset function (call from console if stuck)
        function resetFocusMode() {
            console.log('ðŸš¨ EMERGENCY: Resetting Focus Mode');
            gameState.focusMode.isActive = false;
            gameState.focusMode.isInSession = false;
            
            // Force show normal panels
            showNormalUIPanels();
            
            // Force hide focus panels
            hideFocusModePanels();
            
            // Update button
            updateFocusModeButton();
            
            // Hide any focus overlays
            const overlays = ['focus-mode-overlay', 'focus-game-overlay', 'focus-mode-badge'];
            overlays.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.remove('active');
                    element.style.display = 'none';
                }
            });
            
            console.log('ðŸš¨ Focus Mode emergency reset complete');
        }
        
        // =============================================================================
        // FOCUS MODE UI PANEL MANAGEMENT
        // =============================================================================
        
        // Hide normal game UI panels
        function hideNormalUIPanels() {
            console.log('ðŸ«¥ Hiding normal UI panels...');
            const normalPanels = [
                'tool-panel',
                'resources-panel', 
                'weather-panel',
                'plant-status-panel',
                'inventory-panel',
                'shop-panel',
                'narrative-panel'
            ];
            
            normalPanels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.style.display = 'none';
                    console.log(`âœ… Hidden panel: ${panelId}`);
                } else {
                    console.log(`âŒ Panel not found: ${panelId}`);
                }
            });
            
            // Hide top UI bar
            const topBar = document.querySelector('.top-ui-bar');
            if (topBar) {
                topBar.style.display = 'none';
                console.log('âœ… Hidden top UI bar');
            } else {
                console.log('âŒ Top UI bar not found');
            }
        }
        
        // Show normal game UI panels
        function showNormalUIPanels() {
            console.log('ðŸ‘ï¸ Showing normal UI panels...');
            const normalPanels = [
                'tool-panel',
                'resources-panel',
                'weather-panel', 
                'plant-status-panel',
                'inventory-panel',
                'shop-panel',
                'narrative-panel'
            ];
            
            normalPanels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.style.display = 'block';
                    console.log(`âœ… Shown panel: ${panelId}`);
                } else {
                    console.log(`âŒ Panel not found: ${panelId}`);
                }
            });
            
            // Show top UI bar
            const topBar = document.querySelector('.top-ui-bar');
            if (topBar) {
                topBar.style.display = 'flex';
                console.log('âœ… Shown top UI bar');
            } else {
                console.log('âŒ Top UI bar not found');
            }
        }
        
        // Show Focus Mode UI panels
        function showFocusModePanels() {
            // Show Focus Mode top bar
            let focusTopBar = document.getElementById('focus-top-bar');
            if (!focusTopBar) {
                createFocusTopBar();
                focusTopBar = document.getElementById('focus-top-bar');
            }
            focusTopBar.style.display = 'flex';
            
            // Show Focus Mode side panel
            let focusSidePanel = document.getElementById('focus-side-panel');
            if (!focusSidePanel) {
                createFocusSidePanel();
                focusSidePanel = document.getElementById('focus-side-panel');
            }
            focusSidePanel.style.display = 'block';
            
            // Show music player
            let musicPlayer = document.getElementById('focus-music-player');
            if (!musicPlayer) {
                createMusicPlayer();
                musicPlayer = document.getElementById('focus-music-player');
            }
            musicPlayer.style.display = 'flex';
        }
        
        // Hide Focus Mode UI panels
        function hideFocusModePanels() {
            const focusPanels = [
                'focus-top-bar',
                'focus-side-panel', 
                'focus-music-player'
            ];
            
            focusPanels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.style.display = 'none';
                }
            });
        }
        
        // =============================================================================
        // FOCUS MODE PANEL CREATION
        // =============================================================================
        
        // Create Focus Mode top bar
        function createFocusTopBar() {
            const focusTopBar = document.createElement('div');
            focusTopBar.id = 'focus-top-bar';
            focusTopBar.className = 'focus-top-bar';
            focusTopBar.innerHTML = `
                <div class="focus-streak-info">
                    <div class="focus-streak">ðŸ”¥ Streak: <span id="focus-streak-count">0</span> days</div>
                    <div class="focus-sessions">ðŸ“Š Sessions: <span id="focus-session-count">0</span></div>
                </div>
                <div class="focus-timer-display">
                    <div class="pomodoro-timer">
                        <span id="focus-timer-display">25:00</span>
                        <button id="focus-timer-btn" onclick="toggleFocusTimer()">â–¶ï¸ Start</button>
                    </div>
                </div>
                <div class="focus-stats">
                    <div class="total-time">â±ï¸ Total: <span id="focus-total-time">0h 0m</span></div>
                </div>
            `;
            document.body.appendChild(focusTopBar);
        }
        
        // Create Focus Mode side panel
        function createFocusSidePanel() {
            const focusSidePanel = document.createElement('div');
            focusSidePanel.id = 'focus-side-panel';
            focusSidePanel.className = 'focus-side-panel';
            focusSidePanel.innerHTML = `
                <h3>ðŸŽ¯ Focus Stats</h3>
                <div class="focus-tip">
                    <h4>ðŸ’¡ Focus Tip</h4>
                    <p id="focus-tip-text">Take breaks every 25 minutes to stay productive!</p>
                </div>
                <div class="focus-progress">
                    <h4>ðŸ“ˆ Today's Progress</h4>
                    <div class="progress-bar">
                        <div class="progress-fill" id="focus-progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-text"><span id="focus-progress-sessions">0</span>/8 sessions</div>
                </div>
                <div class="focus-tasks">
                    <h4>âœ… Focus Tasks</h4>
                    <div id="focus-task-list">
                        <div class="focus-task">ðŸŒ± Tend to your garden</div>
                        <div class="focus-task">ðŸŽµ Enjoy peaceful music</div>
                        <div class="focus-task">ðŸ§˜ Stay focused and calm</div>
                    </div>
                </div>
            `;
            document.body.appendChild(focusSidePanel);
        }
        
        // Create music player
        function createMusicPlayer() {
            const musicPlayerElement = document.createElement('div');
            musicPlayerElement.id = 'focus-music-player';
            musicPlayerElement.className = 'focus-music-player';
            musicPlayerElement.innerHTML = `
                <div class="music-controls">
                    <button id="music-prev" onclick="previousTrack()">â®ï¸</button>
                    <button id="music-play-pause" onclick="toggleMusic()">â–¶ï¸</button>
                    <button id="music-next" onclick="nextTrack()">â­ï¸</button>
                </div>
                <div class="music-info">
                    <div class="track-title" id="current-track">ðŸŽ· Jazz Vibes</div>
                    <select id="track-selector" onchange="selectTrack(this.value)">
                        ${musicPlayer.tracks.map((track, index) => 
                            `<option value="${index}" ${index === 0 ? 'selected' : ''}>${track.name}</option>`
                        ).join('')}
                    </select>
                    <div class="music-progress">
                        <div class="music-progress-bar">
                            <div class="music-progress-fill" id="music-progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="volume-control">
                    <span>ðŸ”Š</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="50">
                </div>
            `;
            document.body.appendChild(musicPlayerElement);
        }
        
        // =============================================================================
        // FOCUS MODE TRANSITION SYSTEM
        // =============================================================================
        
        // Play transition video and change background
        function playFocusModeTransition(enteringFocusMode) {
            const video = document.getElementById('focus-transition-video');
            const gameContainer = document.getElementById('game-container');
            
            if (!video || !gameContainer) {
                console.log('âŒ Transition elements not found');
                return Promise.resolve(); // Continue without transition
            }
            
            return new Promise((resolve) => {
                console.log(`ðŸŽ¬ Playing transition video with zoom (entering: ${enteringFocusMode})`);
                
                // Reset video properties
                video.style.display = 'block';
                video.style.transform = 'scale(1.3)'; // Start at 130%
                video.classList.remove('zoom-out');
                video.currentTime = 0;
                
                // Start zoom out animation
                setTimeout(() => {
                    video.classList.add('zoom-out');
                }, 100); // Small delay to ensure initial scale is applied
                
                // Play the video
                const playPromise = video.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('ðŸŽ¬ Video started playing with zoom animation');
                    }).catch(error => {
                        console.log('ðŸŽ¬ Video autoplay prevented:', error);
                        // Continue without video if autoplay is blocked
                        video.style.display = 'none';
                        video.classList.remove('zoom-out');
                        changeBackgroundAfterTransition(enteringFocusMode);
                        resolve();
                    });
                }
                
                // When video ends, change background and hide video
                const onVideoEnd = () => {
                    console.log('ðŸŽ¬ Video finished, changing background');
                    video.style.display = 'none';
                    video.classList.remove('zoom-out');
                    changeBackgroundAfterTransition(enteringFocusMode);
                    video.removeEventListener('ended', onVideoEnd);
                    resolve();
                };
                
                video.addEventListener('ended', onVideoEnd);
                
                // Fallback: if video doesn't end in reasonable time, continue anyway
                setTimeout(() => {
                    if (video.style.display !== 'none') {
                        console.log('ðŸŽ¬ Video timeout, forcing transition');
                        video.pause();
                        video.style.display = 'none';
                        video.classList.remove('zoom-out');
                        changeBackgroundAfterTransition(enteringFocusMode);
                        video.removeEventListener('ended', onVideoEnd);
                        resolve();
                    }
                }, 5000); // 5 second timeout
            });
        }
        
        // Play exit transition video (zoom in from 100% to 130%)
        function playFocusModeExitTransition() {
            const video = document.getElementById('focus-exit-transition-video');
            const gameContainer = document.getElementById('game-container');
            
            if (!video || !gameContainer) {
                console.log('âŒ Exit transition elements not found');
                return Promise.resolve(); // Continue without transition
            }
            
            return new Promise((resolve) => {
                console.log('ðŸŽ¬ Playing exit transition video with zoom-in animation');
                
                // Reset video properties
                video.style.display = 'block';
                video.style.transform = 'scale(1.0)'; // Start at 100%
                video.classList.remove('zoom-in');
                video.currentTime = 0;
                
                // Start zoom in animation
                setTimeout(() => {
                    video.classList.add('zoom-in');
                }, 100); // Small delay to ensure initial scale is applied
                
                // Play the video
                const playPromise = video.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('ðŸŽ¬ Exit video started playing with zoom-in animation');
                    }).catch(error => {
                        console.log('ðŸŽ¬ Exit video autoplay prevented:', error);
                        // Continue without video if autoplay is blocked
                        video.style.display = 'none';
                        video.classList.remove('zoom-in');
                        changeBackgroundAfterTransition(false); // Restore daytime background
                        resolve();
                    });
                }
                
                // When video ends, change background and hide video
                const onVideoEnd = () => {
                    console.log('ðŸŽ¬ Exit video finished, restoring daytime background');
                    video.style.display = 'none';
                    video.classList.remove('zoom-in');
                    changeBackgroundAfterTransition(false); // Restore daytime background
                    video.removeEventListener('ended', onVideoEnd);
                    resolve();
                };
                
                video.addEventListener('ended', onVideoEnd);
                
                // Fallback: if video doesn't end in reasonable time, continue anyway
                setTimeout(() => {
                    if (video.style.display !== 'none') {
                        console.log('ðŸŽ¬ Exit video timeout, forcing transition');
                        video.pause();
                        video.style.display = 'none';
                        video.classList.remove('zoom-in');
                        changeBackgroundAfterTransition(false); // Restore daytime background
                        video.removeEventListener('ended', onVideoEnd);
                        resolve();
                    }
                }, 5000); // 5 second timeout
            });
        }
        
        // Change background image after transition
        function changeBackgroundAfterTransition(enteringFocusMode) {
            const gameContainer = document.getElementById('game-container');
            // Try multiple possible canvas IDs for P5.js
            const canvas = document.getElementById('defaultCanvas0') || 
                          document.querySelector('canvas') || 
                          document.querySelector('#game-container canvas');
            if (!gameContainer) return;
            
            if (enteringFocusMode) {
                // Switch to night background at 100% scale
                gameContainer.style.backgroundImage = "url('assets/night.png')";
                gameContainer.style.backgroundSize = "100% 100%"; // Ensure full coverage
                gameContainer.style.backgroundPosition = "center center";
                gameContainer.style.backgroundRepeat = "no-repeat";
                
                // Scale down game elements to match 100% background
                if (canvas) {
                    canvas.style.transform = "scale(0.77)"; // 100/130 = 0.77 to match background
                    canvas.style.transformOrigin = "center center";
                }
                
                console.log('ðŸŒ™ Switched to night background at 100% scale, scaled game elements to 77%');
            } else {
                // Switch back to day background at 130% scale
                gameContainer.style.backgroundImage = "url('assets/isometric_garden.png')";
                gameContainer.style.backgroundSize = "130%";
                
                // Scale up game elements to match 130% background
                if (canvas) {
                    canvas.style.transform = "scale(1)"; // Back to 100% (normal size)
                    canvas.style.transformOrigin = "center center";
                }
                
                console.log('â˜€ï¸ Switched to day background at 130% scale, restored game elements to 100%');
            }
        }
        
        // =============================================================================
        // FOCUS MODE MUSIC PLAYER
        // =============================================================================
        
        // Music player state with real audio files
        const musicPlayer = {
            isPlaying: false,
            currentTrack: 0,
            volume: 0.5,
            audio: null, // HTML5 Audio element
            tracks: [
                { name: 'ðŸŽ· Jazz Vibes', file: 'assets/Audios/jazz.mp3' },
                { name: 'â„ï¸ Chill Beats', file: 'assets/Audios/chill.mp3' },
                { name: 'ðŸŒŠ Ambient Sounds', file: 'assets/Audios/ambient.mp3' },
                { name: 'ðŸ§˜ Calm Melodies', file: 'assets/Audios/calm.mp3' },
                { name: 'âš¡ Upbeat Energy', file: 'assets/Audios/upbeat.mp3' },
                { name: 'ðŸƒ Mellow Tunes', file: 'assets/Audios/mellow.mp3' }
            ]
        };
        
        // Initialize music player with real audio
        function initializeMusicPlayer() {
            // Create audio element if it doesn't exist
            if (!musicPlayer.audio) {
                musicPlayer.audio = new Audio();
                musicPlayer.audio.loop = true;
                musicPlayer.audio.volume = musicPlayer.volume;
                
                // Add event listeners for audio
                musicPlayer.audio.addEventListener('loadstart', () => {
                    console.log('ðŸŽµ Loading track...');
                });
                
                musicPlayer.audio.addEventListener('canplay', () => {
                    console.log('ðŸŽµ Track ready to play');
                });
                
                musicPlayer.audio.addEventListener('ended', () => {
                    console.log('ðŸŽµ Track ended, looping...');
                });
                
                musicPlayer.audio.addEventListener('error', (e) => {
                    console.error('ðŸŽµ Audio error:', e);
                    showFocusNotification('ðŸŽµ Audio Error', 'Could not load music track');
                });
                
                // Update progress bar
                musicPlayer.audio.addEventListener('timeupdate', updateProgressBar);
            }
            
            // Load first track and auto-start
            loadTrack(0);
            updateTrackDisplay();
            updateVolumeSlider();
            
            // Auto-start playing jazz.mp3
            setTimeout(() => {
                toggleMusic();
            }, 500);
        }
        
        // Load a specific track
        function loadTrack(trackIndex) {
            if (musicPlayer.audio && musicPlayer.tracks[trackIndex]) {
                const wasPlaying = musicPlayer.isPlaying;
                
                // Pause current track
                musicPlayer.audio.pause();
                
                // Load new track
                musicPlayer.currentTrack = trackIndex;
                musicPlayer.audio.src = musicPlayer.tracks[trackIndex].file;
                
                // Resume playing if was playing
                if (wasPlaying) {
                    musicPlayer.audio.play().catch(e => {
                        console.error('ðŸŽµ Playback error:', e);
                        musicPlayer.isPlaying = false;
                        updatePlayPauseButton();
                    });
                }
                
                updateTrackDisplay();
                updateTrackSelector();
                console.log('ðŸŽµ Loaded track:', musicPlayer.tracks[trackIndex].name);
            }
        }
        
        // Toggle music play/pause
        function toggleMusic() {
            const playPauseBtn = document.getElementById('music-play-pause');
            
            if (musicPlayer.isPlaying) {
                // Pause
                musicPlayer.audio.pause();
                musicPlayer.isPlaying = false;
                playPauseBtn.textContent = 'â–¶ï¸';
                console.log('ðŸŽµ Music paused');
            } else {
                // Play
                musicPlayer.audio.play().then(() => {
                    musicPlayer.isPlaying = true;
                    playPauseBtn.textContent = 'â¸ï¸';
                    console.log('ðŸŽµ Music playing:', musicPlayer.tracks[musicPlayer.currentTrack].name);
                }).catch(e => {
                    console.error('ðŸŽµ Playback error:', e);
                    showFocusNotification('ðŸŽµ Playback Error', 'Could not play music');
                });
            }
        }
        
        // Next track
        function nextTrack() {
            const nextIndex = (musicPlayer.currentTrack + 1) % musicPlayer.tracks.length;
            loadTrack(nextIndex);
            console.log('â­ï¸ Next track:', musicPlayer.tracks[nextIndex].name);
        }
        
        // Previous track
        function previousTrack() {
            const prevIndex = musicPlayer.currentTrack === 0 ? 
                musicPlayer.tracks.length - 1 : musicPlayer.currentTrack - 1;
            loadTrack(prevIndex);
            console.log('â®ï¸ Previous track:', musicPlayer.tracks[prevIndex].name);
        }
        
        // Select track from dropdown
        function selectTrack(trackIndex) {
            const index = parseInt(trackIndex);
            loadTrack(index);
            console.log('ðŸŽµ Selected track:', musicPlayer.tracks[index].name);
        }
        
        // Update track display
        function updateTrackDisplay() {
            const trackTitle = document.getElementById('current-track');
            if (trackTitle && musicPlayer.tracks[musicPlayer.currentTrack]) {
                trackTitle.textContent = musicPlayer.tracks[musicPlayer.currentTrack].name;
            }
        }
        
        // Update track selector dropdown
        function updateTrackSelector() {
            const selector = document.getElementById('track-selector');
            if (selector) {
                selector.value = musicPlayer.currentTrack;
            }
        }
        
        // Update play/pause button
        function updatePlayPauseButton() {
            const playPauseBtn = document.getElementById('music-play-pause');
            if (playPauseBtn) {
                playPauseBtn.textContent = musicPlayer.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';
            }
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progressFill = document.getElementById('music-progress-fill');
            if (progressFill && musicPlayer.audio && musicPlayer.audio.duration) {
                const progress = (musicPlayer.audio.currentTime / musicPlayer.audio.duration) * 100;
                progressFill.style.width = progress + '%';
            }
        }
        
        // Update volume slider
        function updateVolumeSlider() {
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) {
                volumeSlider.value = musicPlayer.volume * 100;
                volumeSlider.addEventListener('input', (e) => {
                    musicPlayer.volume = e.target.value / 100;
                    if (musicPlayer.audio) {
                        musicPlayer.audio.volume = musicPlayer.volume;
                    }
                    console.log('ðŸ”Š Volume:', Math.round(musicPlayer.volume * 100) + '%');
                });
            }
        }
        
        // Stop music player
        function stopMusicPlayer() {
            if (musicPlayer.audio) {
                musicPlayer.audio.pause();
                musicPlayer.audio.currentTime = 0;
            }
            musicPlayer.isPlaying = false;
            updatePlayPauseButton();
            console.log('ðŸŽµ Music player stopped');
        }
        
        // Update Focus Mode UI with current data
        function updateFocusModeDisplay() {
            // Update streak count
            const streakElement = document.getElementById('focus-streak-count');
            if (streakElement) {
                streakElement.textContent = gameState.focusMode.streak;
            }
            
            // Update session count
            const sessionElement = document.getElementById('focus-session-count');
            if (sessionElement) {
                sessionElement.textContent = gameState.focusMode.sessionsToday;
            }
            
            // Update total time
            const totalTimeElement = document.getElementById('focus-total-time');
            if (totalTimeElement) {
                const totalMinutes = gameState.focusMode.totalFocusTime;
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                totalTimeElement.textContent = `${hours}h ${minutes}m`;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('focus-progress-fill');
            const progressSessions = document.getElementById('focus-progress-sessions');
            if (progressFill && progressSessions) {
                const progress = (gameState.focusMode.sessionsToday / 8) * 100;
                progressFill.style.width = `${Math.min(progress, 100)}%`;
                progressSessions.textContent = gameState.focusMode.sessionsToday;
            }
            
            // Update timer display
            const timerDisplay = document.getElementById('focus-timer-display');
            if (timerDisplay) {
                const minutes = Math.floor(gameState.focusMode.timer.timeLeft / 60);
                const seconds = gameState.focusMode.timer.timeLeft % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update timer button
            const timerBtn = document.getElementById('focus-timer-btn');
            if (timerBtn) {
                timerBtn.textContent = gameState.focusMode.timer.isRunning ? 'â¸ï¸ Pause' : 'â–¶ï¸ Start';
            }
        }
        
        // =============================================================================
        // RESTART GAME FUNCTIONS
        // =============================================================================
        
        // Confirm restart with user
        function confirmRestart() {
            const confirmed = confirm('Are you sure you want to restart the game? This will clear all your progress including:\n\nâ€¢ All planted crops\nâ€¢ Coins and resources\nâ€¢ Tools and items\nâ€¢ Focus mode data\nâ€¢ Saved game state\n\nThis action cannot be undone!');
            
            if (confirmed) {
                restartGame();
            }
        }
        
        // Clear planted crops only (keep all other progress)
        function restartGame() {
            // Only clear planted crops from the grid
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    if (gameState.grid[y] && gameState.grid[y][x]) {
                        // Remove any planted crops but keep the tile
                        gameState.grid[y][x].crop = null;
                        gameState.grid[y][x].isOccupied = false;
                    }
                }
            }
            
            // Reset only plant menu state
            gameState.showPlantMenu = false;
            gameState.plantMenuPos = { x: 0, y: 0 };
            gameState.selectedCrop = null;
            
            // Clear only plant health data from localStorage
            localStorage.removeItem('growtopiaPlantHealth');
            
            // Hide plant condition panel if visible
            hidePlantConditionPanel();
            
            // Update UI to reflect changes
            updateAllUI();
            
            // Show restart notification
            showPurchaseNotification('ðŸŒ± All crops cleared! Your garden is ready for replanting! ðŸ”„');
            
            console.log('ðŸ”„ Crops cleared successfully');
        }
        
        // Start Focus Session
        function startFocusSession() {
            if (gameState.focusMode.isInSession) {
                alert('A focus session is already active!');
                return;
            }
            
            gameState.focusMode.isInSession = true;
            gameState.focusMode.currentPhase = 'focus';
            
            // Set timer duration from settings
            const focusMinutes = parseInt(document.getElementById('focus-duration').value);
            gameState.focusMode.timer.duration = focusMinutes * 60 * 1000;
            gameState.focusMode.timer.remaining = gameState.focusMode.timer.duration;
            
            // Start timer
            startTimer();
            
            // Show game overlay
            document.getElementById('focus-game-overlay').style.display = 'flex';
            document.getElementById('focus-overlay-title').textContent = 'Focus Session Active';
            document.getElementById('focus-overlay-message').textContent = 'Stay focused! Your plants are growing while you work.';
            
            console.log('ðŸš€ Focus session started');
        }
        
        // =============================================================================
        // POMODORO TIMER FUNCTIONS (Replacing old Focus Mode timer)
        // =============================================================================
        
        // Main timer toggle function
        function toggleFocusTimer() {
            if (!gameState.pomodoro.isRunning && !gameState.pomodoro.isPaused) {
                startFocusTimer();
            } else if (gameState.pomodoro.isRunning) {
                pauseFocusTimer();
            } else if (gameState.pomodoro.isPaused) {
                resumeFocusTimer();
            }
        }
        
        // Start Pomodoro timer
        function startFocusTimer() {
            if (!gameState.focusMode.isActive) return; // Only work in Focus Mode
            
            console.log('ðŸ… Starting Pomodoro timer');
            
            // Reset session leaf coins at start of new session
            gameState.focusMode.rewards.sessionLeafCoins = 0;
            updateFocusSessionCoinsDisplay();
            
            gameState.pomodoro.isActive = true;
            gameState.pomodoro.isRunning = true;
            gameState.pomodoro.isPaused = false;
            gameState.pomodoro.timer.startTime = Date.now();
            gameState.pomodoro.timer.lastUpdate = Date.now();
            
            updateFocusTimerDisplay();
            updateFocusTimerControls();
            
            // Start the timer loop
            if (gameState.pomodoro.timer.interval) {
                clearInterval(gameState.pomodoro.timer.interval);
            }
            gameState.pomodoro.timer.interval = setInterval(updateFocusTimer, 1000);
            
            showFocusNotification('ðŸ… Pomodoro Started', `${getPomodoroPhase()} session began!`);
        }
        
        // Pause Pomodoro timer
        function pauseFocusTimer() {
            if (!gameState.pomodoro.isRunning) return;
            
            console.log('â¸ï¸ Pausing Pomodoro timer');
            
            gameState.pomodoro.isRunning = false;
            gameState.pomodoro.isPaused = true;
            
            if (gameState.pomodoro.timer.interval) {
                clearInterval(gameState.pomodoro.timer.interval);
            }
            
            updateFocusTimerDisplay();
            updateFocusTimerControls();
            
            showFocusNotification('â¸ï¸ Paused', 'Timer paused');
        }
        
        // Resume Pomodoro timer
        function resumeFocusTimer() {
            if (!gameState.pomodoro.isPaused) return;
            
            console.log('â–¶ï¸ Resuming Pomodoro timer');
            
            gameState.pomodoro.isRunning = true;
            gameState.pomodoro.isPaused = false;
            gameState.pomodoro.timer.lastUpdate = Date.now();
            
            gameState.pomodoro.timer.interval = setInterval(updateFocusTimer, 1000);
            
            updateFocusTimerDisplay();
            updateFocusTimerControls();
            
            showFocusNotification('â–¶ï¸ Resumed', 'Timer resumed');
        }
        
        // Stop/Reset Pomodoro timer
        function stopFocusTimer() {
            console.log('ðŸ”„ Resetting Pomodoro timer');
            
            // Update settings from UI before resetting
            updatePomodoroSettings();
            
            gameState.pomodoro.isActive = false;
            gameState.pomodoro.isRunning = false;
            gameState.pomodoro.isPaused = false;
            gameState.pomodoro.currentPhase = 'focus';
            gameState.pomodoro.currentSession = 1;
            gameState.pomodoro.completedSessions = 0;
            gameState.pomodoro.timer.remaining = gameState.pomodoro.settings.focusDuration * 60 * 1000;
            gameState.pomodoro.timer.duration = gameState.pomodoro.settings.focusDuration * 60 * 1000;
            
            if (gameState.pomodoro.timer.interval) {
                clearInterval(gameState.pomodoro.timer.interval);
            }
            
            updateFocusTimerDisplay();
            updateFocusTimerControls();
            
            showFocusNotification('ðŸ”„ Timer Reset', 'Ready for a new session');
        }
        
        // Update Pomodoro timer
        function updateFocusTimer() {
            if (!gameState.pomodoro.isRunning) return;
            
            const now = Date.now();
            const elapsed = now - gameState.pomodoro.timer.lastUpdate;
            gameState.pomodoro.timer.remaining -= elapsed;
            gameState.pomodoro.timer.lastUpdate = now;
            
            if (gameState.pomodoro.timer.remaining <= 0) {
                completeFocusTimerPhase();
            } else {
                updateFocusTimerDisplay();
            }
        }
        
        // Complete current Pomodoro session
        function completeFocusTimerPhase() {
            console.log('âœ… Pomodoro session completed');
            
            gameState.pomodoro.isRunning = false;
            gameState.pomodoro.completedSessions++;
            
            if (gameState.pomodoro.timer.interval) {
                clearInterval(gameState.pomodoro.timer.interval);
            }
            
            // Show completion sparkle effect
            showPomodoroCompletionSparkle();
            
            // Start next phase
            startNextPomodoroPhase();
        }
        
        // Start next Pomodoro phase
        function startNextPomodoroPhase() {
            if (gameState.pomodoro.currentPhase === 'focus') {
                // Focus session completed - update Focus Mode stats
                gameState.focusMode.stats.totalSessions++;
                gameState.focusMode.stats.totalFocusTime += gameState.pomodoro.settings.focusDuration;
                updateFocusStreak();
                awardFocusRewards();
                
                // Update settings from UI before setting durations
                updatePomodoroSettings();
                
                // Check if it's time for long break
                if (gameState.pomodoro.currentSession % gameState.pomodoro.totalCycles === 0) {
                    // Time for long break
                    gameState.pomodoro.currentPhase = 'long_break';
                    gameState.pomodoro.timer.duration = gameState.pomodoro.settings.longBreakDuration * 60 * 1000;
                    showFocusNotification('ðŸŽ‰ Long Break Time!', `Great work! Take a ${gameState.pomodoro.settings.longBreakDuration}-minute break.`);
                } else {
                    // Time for short break
                    gameState.pomodoro.currentPhase = 'short_break';
                    gameState.pomodoro.timer.duration = gameState.pomodoro.settings.shortBreakDuration * 60 * 1000;
                    showFocusNotification('â˜• Break Time!', `Time for a ${gameState.pomodoro.settings.shortBreakDuration}-minute break.`);
                }
            } else {
                // Break completed, start next focus session
                gameState.pomodoro.currentPhase = 'focus';
                gameState.pomodoro.currentSession++;
                gameState.pomodoro.timer.duration = gameState.pomodoro.settings.focusDuration * 60 * 1000;
                showFocusNotification('ðŸŽ¯ Focus Time!', `Session ${gameState.pomodoro.currentSession} - Let's focus!`);
            }
            
            gameState.pomodoro.timer.remaining = gameState.pomodoro.timer.duration;
            updateFocusTimerDisplay();
            
            // Auto-start next session
            setTimeout(() => {
                startFocusTimer();
            }, 2000); // 2 second delay for notification
        }
        
        // Update Pomodoro timer display
        function updateFocusTimerDisplay() {
            const timeElement = document.getElementById('focus-timer-display');
            const phaseElement = document.getElementById('focus-timer-phase');
            const sessionElement = document.getElementById('focus-timer-session');
            const displayElement = document.querySelector('.pomodoro-main-display');
            
            if (!timeElement || !phaseElement || !sessionElement) return;
            
            // Update time display
            const minutes = Math.floor(gameState.pomodoro.timer.remaining / 60000);
            const seconds = Math.floor((gameState.pomodoro.timer.remaining % 60000) / 1000);
            timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update phase display
            phaseElement.textContent = getPomodoroPhase();
            
            // Update session info
            if (gameState.pomodoro.currentPhase === 'focus') {
                sessionElement.textContent = `Session ${gameState.pomodoro.currentSession} of ${gameState.pomodoro.totalCycles}`;
            } else {
                sessionElement.textContent = `Break Time`;
            }
            
            // Update styling based on phase
            if (displayElement) {
                displayElement.className = `pomodoro-main-display ${gameState.pomodoro.currentPhase.replace('_', '-')}`;
            }
            
            // Also update main garden timer display (synchronization)
            updateMainGardenTimerDisplay();
        }
        
        // Update Pomodoro timer controls
        function updateFocusTimerControls() {
            const startBtn = document.getElementById('focus-timer-btn');
            const pauseBtn = document.getElementById('focus-timer-pause');
            const stopBtn = document.getElementById('focus-timer-stop');
            
            if (!startBtn || !pauseBtn || !stopBtn) return;
            
            if (gameState.pomodoro.isRunning) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = 'â¸ï¸ Pause';
                pauseBtn.onclick = pauseFocusTimer;
                stopBtn.style.display = 'inline-block';
            } else if (gameState.pomodoro.isPaused) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = 'â–¶ï¸ Resume';
                pauseBtn.onclick = resumeFocusTimer;
                stopBtn.style.display = 'inline-block';
            } else {
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
            }
            
            // Also update main garden timer controls (synchronization)
            updateMainGardenTimerControls();
        }
        
        // Get current phase name
        function getPomodoroPhase() {
            switch (gameState.pomodoro.currentPhase) {
                case 'focus': return gameState.pomodoro.isActive ? 'Focus Time' : 'Ready to Focus';
                case 'short_break': return 'Short Break';
                case 'long_break': return 'Long Break';
                default: return 'Ready';
            }
        }
        
        // Adjust total cycles (+ and - buttons)
        function adjustCycles(delta) {
            const newTotal = gameState.pomodoro.totalCycles + delta;
            if (newTotal >= 1 && newTotal <= 8) {
                gameState.pomodoro.totalCycles = newTotal;
                
                // Update both Focus Mode and main garden cycle counts
                const focusCycleCount = document.getElementById('cycle-count');
                const mainCycleCount = document.getElementById('main-cycle-count');
                
                if (focusCycleCount) focusCycleCount.textContent = newTotal;
                if (mainCycleCount) mainCycleCount.textContent = newTotal;
                
                updateFocusTimerDisplay(); // Update session display (this also syncs main garden timer)
                console.log(`ðŸ”„ Cycles adjusted to: ${newTotal}`);
            }
        }
        
        // Show completion sparkle effect
        function showPomodoroCompletionSparkle() {
            const timer = document.querySelector('.pomodoro-main-display');
            if (!timer) return;
            
            // Add sparkle effect
            timer.style.boxShadow = '0 0 30px rgba(243, 156, 18, 0.8)';
            timer.style.transform = 'scale(1.02)';
            
            setTimeout(() => {
                timer.style.boxShadow = '0 0 20px rgba(243, 156, 18, 0.3)';
                timer.style.transform = 'scale(1)';
            }, 1000);
        }
        
        // Initialize Pomodoro timer when Focus Mode starts
        function initializeFocusTimer() {
            console.log('ðŸ… Initializing Focus Mode Pomodoro timer');
            
            // Load settings from UI inputs
            updatePomodoroSettings();
            
            // Reset timer to initial state
            stopFocusTimer();
            
            // Update display
            updateFocusTimerDisplay();
            updateFocusTimerControls();
            
            // Auto-start the first focus session
            setTimeout(() => {
                startFocusTimer();
            }, 1000); // 1 second delay to allow UI to settle
        }
        
        // =============================================================================
        // MAIN GARDEN TIMER PANEL FUNCTIONS (Synchronized with Focus Mode timer)
        // =============================================================================
        
        // Show main garden timer panel
        function showMainGardenTimer() {
            const timerPanel = document.getElementById('main-garden-timer-panel');
            if (timerPanel) {
                timerPanel.style.display = 'block';
                updateMainGardenTimerDisplay();
                updateMainGardenTimerControls();
                console.log('ðŸ… Main garden timer panel shown');
            }
        }
        
        // Hide main garden timer panel
        function hideMainGardenTimer() {
            const timerPanel = document.getElementById('main-garden-timer-panel');
            if (timerPanel) {
                timerPanel.style.display = 'none';
                console.log('ðŸ… Main garden timer panel hidden');
            }
        }
        
        // Update main garden timer display (synchronized with Focus Mode timer)
        function updateMainGardenTimerDisplay() {
            const timeElement = document.getElementById('main-timer-time');
            const phaseElement = document.getElementById('main-timer-phase');
            const sessionElement = document.getElementById('main-timer-session');
            const displayElement = document.querySelector('.main-timer-display');
            const cycleCountElement = document.getElementById('main-cycle-count');
            
            if (!timeElement || !phaseElement || !sessionElement || !displayElement) return;
            
            // Update time display (same as Focus Mode timer)
            const minutes = Math.floor(gameState.pomodoro.timer.remaining / 60000);
            const seconds = Math.floor((gameState.pomodoro.timer.remaining % 60000) / 1000);
            timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update phase display
            phaseElement.textContent = getPomodoroPhase();
            
            // Update session info
            if (gameState.pomodoro.currentPhase === 'focus') {
                sessionElement.textContent = `Session ${gameState.pomodoro.currentSession} of ${gameState.pomodoro.totalCycles}`;
            } else {
                sessionElement.textContent = `Break Time`;
            }
            
            // Update styling based on phase
            displayElement.className = `main-timer-display ${gameState.pomodoro.currentPhase.replace('_', '-')}`;
            
            // Update cycle count
            if (cycleCountElement) {
                cycleCountElement.textContent = gameState.pomodoro.totalCycles;
            }
            
            // Sync timer settings inputs with current values
            syncMainTimerSettings();
        }
        
        // Sync main garden timer settings with Focus Mode timer settings
        function syncMainTimerSettings() {
            const mainFocusInput = document.getElementById('main-focus-duration');
            const mainBreakInput = document.getElementById('main-break-duration');
            const mainLongBreakInput = document.getElementById('main-long-break-duration');
            
            const focusInput = document.getElementById('focus-duration');
            const breakInput = document.getElementById('break-duration');
            const longBreakInput = document.getElementById('long-break-duration');
            
            if (mainFocusInput && focusInput) {
                mainFocusInput.value = focusInput.value;
            }
            if (mainBreakInput && breakInput) {
                mainBreakInput.value = breakInput.value;
            }
            if (mainLongBreakInput && longBreakInput) {
                mainLongBreakInput.value = longBreakInput.value;
            }
        }
        
        // Handle timer setting changes from main garden timer
        function onMainTimerSettingChange() {
            const mainFocusInput = document.getElementById('main-focus-duration');
            const mainBreakInput = document.getElementById('main-break-duration');
            const mainLongBreakInput = document.getElementById('main-long-break-duration');
            
            const focusInput = document.getElementById('focus-duration');
            const breakInput = document.getElementById('break-duration');
            const longBreakInput = document.getElementById('long-break-duration');
            
            // Sync changes to Focus Mode timer inputs
            if (mainFocusInput && focusInput) {
                focusInput.value = mainFocusInput.value;
            }
            if (mainBreakInput && breakInput) {
                breakInput.value = mainBreakInput.value;
            }
            if (mainLongBreakInput && longBreakInput) {
                longBreakInput.value = mainLongBreakInput.value;
            }
            
            // Apply the settings changes
            updatePomodoroSettings();
            
            // Show feedback only if timer is not running
            if (!gameState.pomodoro.isRunning) {
                showFocusNotification('âš™ï¸ Timer Settings Updated', 'Pomodoro durations have been updated');
            }
        }
        
        // Update main garden timer controls (synchronized with Focus Mode timer)
        function updateMainGardenTimerControls() {
            const startBtn = document.getElementById('main-timer-start');
            const pauseBtn = document.getElementById('main-timer-pause');
            const stopBtn = document.getElementById('main-timer-stop');
            
            if (!startBtn || !pauseBtn || !stopBtn) return;
            
            if (gameState.pomodoro.isRunning) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = 'â¸ï¸ Pause';
                pauseBtn.onclick = pauseFocusTimer;
                stopBtn.style.display = 'inline-block';
            } else if (gameState.pomodoro.isPaused) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = 'â–¶ï¸ Resume';
                pauseBtn.onclick = resumeFocusTimer;
                stopBtn.style.display = 'inline-block';
            } else {
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
            }
        }
        
        // Update Pomodoro settings from UI inputs
        function updatePomodoroSettings() {
            const focusDuration = parseInt(document.getElementById('focus-duration').value) || 25;
            const breakDuration = parseInt(document.getElementById('break-duration').value) || 5;
            const longBreakDuration = parseInt(document.getElementById('long-break-duration').value) || 15;
            
            // Update settings
            gameState.pomodoro.settings.focusDuration = focusDuration;
            gameState.pomodoro.settings.shortBreakDuration = breakDuration;
            gameState.pomodoro.settings.longBreakDuration = longBreakDuration;
            
            // If timer is not running and in focus phase, update the timer duration
            if (!gameState.pomodoro.isRunning && gameState.pomodoro.currentPhase === 'focus') {
                gameState.pomodoro.timer.duration = focusDuration * 60 * 1000;
                gameState.pomodoro.timer.remaining = focusDuration * 60 * 1000;
                updateFocusTimerDisplay();
            }
            
            console.log(`ðŸ… Timer settings updated: Focus ${focusDuration}min, Break ${breakDuration}min, Long Break ${longBreakDuration}min`);
        }
        
        // Handle timer setting changes from Focus Mode timer
        function onTimerSettingChange() {
            updatePomodoroSettings();
            
            // Sync changes to main garden timer inputs
            syncMainTimerSettings();
            
            // Show feedback only if timer is not running (to avoid disrupting active sessions)
            if (!gameState.pomodoro.isRunning) {
                showFocusNotification('âš™ï¸ Settings Updated', 'Timer durations have been updated');
            }
        }
        
        // =============================================================================
        // OLD TIMER FUNCTIONS REMOVED - Now using Pomodoro timer functions above
        // =============================================================================
        
        // Scroll to Top Function
        function scrollToTop() {
            const overlay = document.getElementById('focus-mode-overlay');
            overlay.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // =============================================================================
        // ENHANCED PLANT HEALTH SYSTEM - SAVE/LOAD FUNCTIONS
        // =============================================================================
        
        // Save plant health data to localStorage
        function savePlantHealthData() {
            const plantData = [];
            
            // Collect all plant data from the grid
            for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    const tile = gameState.grid[y][x];
                    if (tile.crop) {
                        plantData.push({
                            x: x,
                            y: y,
                            cropData: tile.crop.toSaveData()
                        });
                    }
                }
            }
            
            const saveData = {
                plantHealthData: plantData,
                saveTime: Date.now()
            };
            
            localStorage.setItem('growtopiaPlantHealth', JSON.stringify(saveData));
            console.log('ðŸ’¾ Plant health data saved:', plantData.length, 'plants');
        }
        
        // Load plant health data from localStorage
        function loadPlantHealthData() {
            const saved = localStorage.getItem('growtopiaPlantHealth');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.plantHealthData) {
                        let loadedCount = 0;
                        
                        data.plantHealthData.forEach(plantInfo => {
                            const tile = gameState.grid[plantInfo.y][plantInfo.x];
                            if (tile && plantInfo.cropData) {
                                // Create new crop instance and load data
                                tile.crop = new Crop(plantInfo.cropData.type, plantInfo.x, plantInfo.y);
                                tile.crop.fromSaveData(plantInfo.cropData);
                                loadedCount++;
                            }
                        });
                        
                        console.log('ðŸ“ Plant health data loaded:', loadedCount, 'plants');
                        
                        // Show offline consequences notification
                        const timeSinceSave = Date.now() - (data.saveTime || Date.now());
                        if (timeSinceSave > 5 * 60 * 1000) { // More than 5 minutes
                            const minutesOffline = Math.floor(timeSinceSave / (1000 * 60));
                            showPurchaseNotification(`ðŸŒ± Plants were offline for ${minutesOffline} minutes - check their health!`);
                        }
                    }
                } catch (error) {
                    console.log('âš ï¸ Error loading plant health data:', error);
                }
            }
        }
        
        // Auto-save plant health data every 30 seconds
        function startPlantHealthAutoSave() {
            setInterval(() => {
                if (gameState.gameStarted) {
                    savePlantHealthData();
                }
            }, 30000); // 30 seconds
        }
        
        // Initialize plant health system
        function initializePlantHealthSystem() {
            loadPlantHealthData();
            startPlantHealthAutoSave();
            console.log('ðŸŒ± Plant health system initialized');
        }
        
        // =============================================================================
        // PLANT CONDITION HOVER PANEL FUNCTIONS
        // =============================================================================
        
        // Helper function to update hover panel if it's currently visible
        function updateHoverPanelIfVisible(crop) {
            const panel = document.getElementById('plant-condition-panel');
            if (panel && panel.style.display === 'block') {
                updatePlantConditionPanel(crop);
            }
        }
        
        // Show plant condition panel on hover
        function showPlantConditionPanel(crop, mouseX, mouseY) {
            const panel = document.getElementById('plant-condition-panel');
            if (!panel || !crop) return;
            
            // Update panel content
            updatePlantConditionPanel(crop);
            
            // Position panel near mouse but keep it on screen
            const panelWidth = 280;
            const panelHeight = 200;
            const padding = 20;
            
            let x = mouseX + 15;
            let y = mouseY - panelHeight / 2;
            
            // Adjust if panel would go off screen
            if (x + panelWidth > window.innerWidth - padding) {
                x = mouseX - panelWidth - 15;
            }
            if (y < padding) {
                y = padding;
            }
            if (y + panelHeight > window.innerHeight - padding) {
                y = window.innerHeight - panelHeight - padding;
            }
            
            panel.style.left = x + 'px';
            panel.style.top = y + 'px';
            panel.style.display = 'block';
            
            // Animate in
            setTimeout(() => {
                panel.classList.add('visible');
            }, 10);
        }
        
        // Hide plant condition panel
        function hidePlantConditionPanel() {
            const panel = document.getElementById('plant-condition-panel');
            if (panel) {
                panel.classList.remove('visible');
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 300);
            }
        }
        
        // Update panel content with plant data
        function updatePlantConditionPanel(crop) {
            // Update header
            document.getElementById('hover-plant-icon').innerHTML = getPlantIcon(crop);
            document.getElementById('hover-plant-name').textContent = crop.type.charAt(0).toUpperCase() + crop.type.slice(1);
            document.getElementById('hover-plant-stage').textContent = `Stage ${crop.stage + 1}`;
            
            // Update health bar
            const healthPercent = Math.max(0, Math.min(100, crop.health));
            document.getElementById('hover-health-fill').style.width = healthPercent + '%';
            document.getElementById('hover-health-value').textContent = Math.round(healthPercent) + '%';
            
            // Update water bar
            const waterPercent = Math.max(0, Math.min(100, crop.waterLevel));
            document.getElementById('hover-water-fill').style.width = waterPercent + '%';
            document.getElementById('hover-water-value').textContent = Math.round(waterPercent) + '%';
            
            // Update sunlight bar
            const sunlightPercent = Math.max(0, Math.min(100, crop.sunlightLevel));
            document.getElementById('hover-sunlight-fill').style.width = sunlightPercent + '%';
            document.getElementById('hover-sunlight-value').textContent = Math.round(sunlightPercent) + '%';
            
            // Update status
            updateStatusDisplay(crop);
            
            // Update treatment recommendations
            updateTreatmentRecommendations(crop);
        }
        
        // Get appropriate plant icon (for DOM elements)
        function getPlantIcon(crop) {
            if (crop.isReady) return getAppleIconForDOM('small');
            if (crop.status === 'dead') return 'ðŸ’€';
            if (crop.status === 'sick') return 'ðŸ˜·';
            if (crop.hasPests) return 'ðŸ›';
            if (crop.needsWater) return getWaterIconForDOM('small');
            if (crop.sunlightLevel < 30) return 'â˜€ï¸'; // Will render as sun.png
            return 'ðŸŒ±';
        }
        
        // Update status display
        function updateStatusDisplay(crop) {
            const statusItem = document.getElementById('hover-status-item');
            const statusIcon = statusItem.querySelector('.status-icon');
            const statusText = statusItem.querySelector('.status-text');
            
            let icon, text, color;
            
            if (crop.status === 'dead') {
                icon = 'ðŸ’€';
                text = 'Dead';
                color = '#e74c3c';
            } else if (crop.hasPests) {
                icon = 'ðŸ›';
                text = 'Infested with Pests';
                color = '#e67e22';
            } else if (crop.status === 'sick') {
                icon = 'ðŸ˜·';
                text = 'Sick';
                color = '#e67e22';
            } else if (crop.sunlightLevel < 20) {
                icon = 'â˜€ï¸'; // Will render as sun.png
                text = 'Needs Sunlight';
                color = '#f39c12';
            } else if (crop.isReady) {
                icon = getAppleIconForDOM('small');
                text = 'Ready to Harvest';
                color = '#27ae60';
            } else {
                icon = 'âœ…';
                text = 'Healthy';
                color = '#27ae60';
            }
            
            statusIcon.innerHTML = icon;
            statusText.textContent = text;
            statusItem.style.borderLeft = `3px solid ${color}`;
        }
        
        // Update treatment recommendations with detailed task list
        function updateTreatmentRecommendations(crop) {
            console.log(`ðŸ” updateTreatmentRecommendations called!`);
            const treatmentList = document.getElementById('hover-treatment-list');
            const treatments = [];
            
            // Debug logging to see actual plant values
            console.log(`ðŸ” DEBUG - Plant conditions:`, {
                waterLevel: crop.waterLevel,
                sunlightLevel: crop.sunlightLevel,
                hasPests: crop.hasPests,
                health: crop.health,
                status: crop.status,
                needsWater: crop.needsWater,
                needsSunlight: crop.needsSunlight
            });
            
            if (crop.status === 'dead') {
                treatments.push({
                    text: 'ðŸ’€ PLANT IS DEAD',
                    class: 'treatment-dead',
                    priority: 'critical'
                });
                treatments.push({
                    text: 'ðŸ—‘ï¸ TASK: Left-click to remove dead tree',
                    class: 'treatment-task',
                    priority: 'action'
                });
                treatments.push({
                    text: 'âš ï¸ NOTE: No rewards will be given',
                    class: 'treatment-note',
                    priority: 'info'
                });
            } else {
                // Create detailed task list based on current conditions
                let taskNumber = 1;
                
                // ALWAYS show current condition levels for debugging
                treatments.push({
                    text: `ðŸ“Š CURRENT CONDITIONS:`,
                    class: 'treatment-info',
                    priority: 'info'
                });
                treatments.push({
                    text: `   ${getWaterIconForDOM('small')} Water: ${Math.round(crop.waterLevel)}% ${crop.waterLevel < 30 ? '(DEFICIENT)' : '(OK)'}`,
                    class: 'treatment-info',
                    priority: 'info'
                });
                treatments.push({
                    text: `   â˜€ï¸ Sunlight: ${Math.round(crop.sunlightLevel)}% ${crop.sunlightLevel < 30 ? '(DEFICIENT)' : '(OK)'}`,
                    class: 'treatment-info',
                    priority: 'info'
                });
                treatments.push({
                    text: `   ðŸ› Pests: ${crop.hasPests ? 'YES (INFESTED)' : 'NO'}`,
                    class: 'treatment-info',
                    priority: 'info'
                });
                treatments.push({
                    text: `   â¤ï¸ Health: ${Math.round(crop.health)}%`,
                    class: 'treatment-info',
                    priority: 'info'
                });
                
                // Water deficiency task
                if (crop.waterLevel < 30) {
                    console.log(`ðŸ” Adding water deficiency treatment - waterLevel: ${crop.waterLevel}`);
                    treatments.push({
                        text: `${taskNumber}. ${getWaterIconForDOM('small')} WATER DEFICIENCY (${Math.round(crop.waterLevel)}%)`,
                        class: 'treatment-condition',
                        priority: 'urgent'
                    });
                    treatments.push({
                        text: '   TASK: Right-click plant to water it',
                        class: 'treatment-task',
                        priority: 'action'
                    });
                    treatments.push({
                        text: '   RESULT: Restores water level and +20 health',
                        class: 'treatment-result',
                        priority: 'info'
                    });
                    taskNumber++;
                }
                
                // Pest infestation task
                if (crop.hasPests) {
                    console.log(`ðŸ” Adding pest treatment - hasPests: ${crop.hasPests}`);
                    treatments.push({
                        text: `${taskNumber}. ðŸ› PEST INFESTATION DETECTED`,
                        class: 'treatment-condition',
                        priority: 'urgent'
                    });
                    treatments.push({
                        text: '   TASK: Select pesticide tool from toolbar',
                        class: 'treatment-task',
                        priority: 'action'
                    });
                    treatments.push({
                        text: '   TASK: Right-click plant to apply pesticide',
                        class: 'treatment-task',
                        priority: 'action'
                    });
                    treatments.push({
                        text: '   RESULT: Removes pests and +10 health',
                        class: 'treatment-result',
                        priority: 'info'
                    });
                    taskNumber++;
                }
                
                // Sunlight deficiency task
                if (crop.sunlightLevel < 30) {
                    console.log(`ðŸ” Adding sunlight deficiency treatment - sunlightLevel: ${crop.sunlightLevel}`);
                    treatments.push({
                        text: `${taskNumber}. â˜€ï¸ SUNLIGHT DEFICIENCY (${Math.round(crop.sunlightLevel)}%)`,
                        class: 'treatment-condition',
                        priority: 'urgent'
                    });
                    treatments.push({
                        text: '   TASK: Select solar lamp tool from toolbar',
                        class: 'treatment-task',
                        priority: 'action'
                    });
                    treatments.push({
                        text: '   TASK: Right-click plant to provide sunlight',
                        class: 'treatment-task',
                        priority: 'action'
                    });
                    treatments.push({
                        text: '   RESULT: +30 sunlight level and +5 health',
                        class: 'treatment-result',
                        priority: 'info'
                    });
                    taskNumber++;
                }
                
                // If no specific conditions are found but plant is sick, force trigger them
                if (crop.status === 'sick' && taskNumber === 1) {
                    treatments.push({
                        text: `ðŸš¨ PLANT IS SICK BUT CONDITIONS UNCLEAR`,
                        class: 'treatment-warning',
                        priority: 'warning'
                    });
                    treatments.push({
                        text: `   Forcing condition refresh...`,
                        class: 'treatment-note',
                        priority: 'info'
                    });
                    
                    // Force apply all conditions if plant is sick but none are detected
                    crop.waterLevel = Math.min(crop.waterLevel, 20);
                    crop.sunlightLevel = Math.min(crop.sunlightLevel, 20);
                    crop.hasPests = true;
                    
                    treatments.push({
                        text: `   CONDITIONS FORCED: Water=${Math.round(crop.waterLevel)}%, Sunlight=${Math.round(crop.sunlightLevel)}%, Pests=YES`,
                        class: 'treatment-note',
                        priority: 'info'
                    });
                }
                
                // General health warning
                if (crop.health < 50 && crop.status !== 'dead') {
                    treatments.push({
                        text: `âš ï¸ LOW HEALTH WARNING (${Math.round(crop.health)}%)`,
                        class: 'treatment-warning',
                        priority: 'warning'
                    });
                    treatments.push({
                        text: '   NOTE: Plant will die if health reaches 0',
                        class: 'treatment-note',
                        priority: 'info'
                    });
                }
                
                // Success message - only show if ALL conditions are actually good
                if (crop.waterLevel >= 30 && !crop.hasPests && crop.sunlightLevel >= 30 && crop.health >= 50 && crop.status === 'healthy') {
                    treatments.push({
                        text: 'âœ… ALL CONDITIONS OPTIMAL',
                        class: 'treatment-success',
                        priority: 'success'
                    });
                    treatments.push({
                        text: 'ðŸŒ± Plant is healthy and growing well',
                        class: 'treatment-note',
                        priority: 'info'
                    });
                }
                
                // If no treatments were added but plant is not healthy, show status mismatch warning
                if (treatments.length === 0 && crop.status !== 'healthy') {
                    treatments.push({
                        text: `âš ï¸ STATUS: ${crop.status.toUpperCase()}`,
                        class: 'treatment-warning',
                        priority: 'warning'
                    });
                    treatments.push({
                        text: 'Check plant conditions above',
                        class: 'treatment-note',
                        priority: 'info'
                    });
                }
            }
            
            // Debug logging to see final treatments array
            console.log(`ðŸ” Final treatments array length: ${treatments.length}`, treatments);
            
            // Render treatments with proper styling
            treatmentList.innerHTML = treatments.map(treatment => 
                `<div class="treatment-item ${treatment.class}" data-priority="${treatment.priority}">${treatment.text}</div>`
            ).join('');
        }
        
        // Call initialization when game starts
        document.addEventListener('DOMContentLoaded', function() {
            initializeFocusMode();
            
            // Add event listeners for timer settings
            document.getElementById('focus-duration').addEventListener('change', onTimerSettingChange);
            document.getElementById('break-duration').addEventListener('change', onTimerSettingChange);
            document.getElementById('long-break-duration').addEventListener('change', onTimerSettingChange);
                });
        
        console.log('ðŸŽ¯ Focus Mode system loaded! Complete with Pomodoro timer, music, pets, and streak tracking!');
        // DEBUG: Global functions for testing (accessible from browser console)
        window.debugGame = {
            getGameState: () => gameState,
            testShovel: () => {
                console.log('ðŸ”§ Testing shovel functionality...');
                console.log('Available tools:', gameState.tools);
                console.log('Current selected tool:', gameState.selectedTool);
                selectTool('shovel');
                console.log('After selecting shovel:', gameState.selectedTool);
            },
            selectTool: (tool) => selectTool(tool)
        };
    </script>
</body>
</html> 